"use strict"

// ********************************************************************************************
// *********  Manager for the airports data                ************************************
//
// Loaded from AIRPORTS_JSON_URL (in this repo as airports/airports.json)
// Note each 'airport' entry in the JSON is a LIST, so the downloaded JSON is more compact
// so the JSON includes an "airport_keys" dictionary that maps property_name -> index.
// e.g. Mifflin County is:
// ['KRVL', 40.6773872375488, -77.6268310546875, 'Mifflin Co', 'msfs_airport', 247.80239207032346, '06 24']
// and airports_data.airports_keys is:
// "airport_keys": {"ident": 0, "lat": 1, "lng": 2, "name": 3, "type": 4, "alt_m": 5, "runways": 6}
// Note the "airport_keys" data is generated by the program that creates the airports data, and we
// may add additional properties, so the key indexes could change.
//
// Downloaded airports_data is:
// {
//      "airport_keys": KEY -> INDEX dictionary for airport properties (as above)
//      "box_coords":   BOX_ID -> BOX COORDINATES dictionary for each 'box' of airports
//      "boxes": BOX_ID -> list of airports (& each airport is a list of property values)
// }
//
// The whole point of this airports_data structure is to support fast lookup of airports within
// a given lat/lng box (i.e. the map bounds).
//
// ********************************************************************************************

/*
This class is usable in B21 Task Planner and B21LeafletMap used in MSFS Nav instruments, with the parent object
given in the constructor as "mapper". The mapper interface required is:

mapper.airport_markers = Leaflet layerGroup e.g. L.layerGroup().addTo(parent.map);
mapper.canvas_renderer = L.canvas()
mapper.task.add_new_poi(position, type, info) -- only used for planner, i.e. is_instrument() == false
*/

class B21_Airports {

    constructor(mapper, options) {
        this.AIRPORTS_JSON_URL = options["json_url"];
        this.AIRPORT_IMG_URL = options["airport_img_url"];

        this.DEBUG_DRAW_MAP_BOXES = false;

        this.mapper = mapper;
        this.airports_data = null;
        this.markers = null; // dictionary IDENT -> marker for each airport drawn on map
        this.search_ident = null; // ident of an airport search result to be highlighted on map

        new LeafletCanvasMarker(); // Extend leaflet so we can add markers to the canvas

        this.available = false;
    }

    // init() will asynchronously download the airports data
    init(map) {
        fetch(this.AIRPORTS_JSON_URL).then(response => {
            if (!response.ok) {
                alert("Failed to download the airports data")
                return null;
            }
            //response.headers.set('content-type','application/json');
            return response.text();
        }).then(results => {
            console.log("airports.json loaded");
            this.airports_data = JSON.parse(results);
            this.KEY_LAT = this.airports_data.airport_keys['lat'];
            this.KEY_LNG = this.airports_data.airport_keys['lng'];
            this.KEY_NAME = this.airports_data.airport_keys['name'];
            this.KEY_IDENT = this.airports_data.airport_keys['ident'];
            this.KEY_TYPE = this.airports_data.airport_keys['type']; //"closed_airport", "heliport", "large_airport", "medium_airport", "seaplane_base", "small_airport", "msfs_airport"
            this.KEY_ALT_M = this.airports_data.airport_keys['alt_m'];
            this.KEY_RUNWAYS = this.airports_data.airport_keys['runways'];
            this.available = true;
            this.draw(map);
        }).catch(error => {
            console.error('Network error accessing airports.json:', error);
        });
    }

    draw(map) {
        const ZOOM_MIN_MSFS = 8;
        const ZOOM_MIN_OTHER = 9;

        this.mapper.airport_markers.clearLayers();

        if (!this.available) {
            console.log("b21_airports.draw(), airports not available, returning.");
            return;
        }

        this.markers = {};

        let zoom = map.getZoom();
        if (zoom < ZOOM_MIN_MSFS) {
            console.log("Too zoomed out to display airports");
            return;
        }
        //console.log("airports.draw(map) drawing");

        let map_bounds = map.getBounds();
        let map_box = {
            "min_lat": map_bounds.getSouth(),
            "min_lng": map_bounds.getWest(),
            "max_lat": map_bounds.getNorth(),
            "max_lng": map_bounds.getEast()
        }
        //console.log("draw_airports", map_box);

        for (let box_id in this.airports_data.box_coords) {
            let box = this.airports_data.box_coords[box_id];
            if (this.DEBUG_DRAW_MAP_BOXES) {
                L.rectangle([
                    [box.min_lat, box.min_lng],
                    [box.max_lat, box.max_lng]
                ]).addTo(map);
            }
            if (Geo.box_overlap(box, map_box)) {
                //console.log("overlap",box_id, box);
                let airports = this.airports_data.boxes[box_id];
                for (let i = 0; i < airports.length; i++) {
                    let airport = airports[i];
                    let type = airport[this.KEY_TYPE];
                    if (type.includes("airport")) {
                        // Skip this airport if it's non-msfs and insufficient zoom
                        if (! type.includes("msfs") && zoom < ZOOM_MIN_OTHER) {
                            continue;
                        }
                        let position = new L.latLng(airport[this.KEY_LAT], airport[this.KEY_LNG]);
                        let runways = airport[this.KEY_RUNWAYS];

                        let marker;
                        if (type == "msfs_airport") {
                            // For MSFS airports we use a "canvasMarker" i.e. place a rotated 20x20 IMAGE on the canvas
                            // Calculate the first runway direction
                            let px = Math.max(14,Math.min(60,10 * (zoom - 7)));

                            let airport_rotate = null;
                            if (runways != null && runways.length > 0) {
                                airport_rotate = parseInt(runways) * 10;
                            }

                            marker = L.canvasMarker(position, {
                                renderer: this.mapper.canvas_renderer,
                                img: {  url: this.AIRPORT_IMG_URL,
                                        rotate: airport_rotate,
                                        size: [px,px]
                                }
                            });
                        } else {
                            // For non-MSFS airports we use a light green circle
                            let circle_radius = 3 * (zoom - 7);
                            if (type == "large_airport") {
                                circle_radius *= 3;
                            } else if (type == "medium_airport") {
                                circle_radius *= 2;
                            }

                            marker = L.circleMarker(position, {
                                renderer: this.mapper.canvas_renderer,
                                color: '#33ff88',
                                radius: circle_radius
                            });
                        }
                        marker.addTo(this.mapper.airport_markers);

                        if (!this.is_instrument()) {
                            let ident = airport[this.KEY_IDENT];
                            //let name = airport[this.KEY_NAME].replaceAll('"', ""); // Remove double quotes if original name includes those.
                            let name = airport[this.KEY_NAME].replace(/"/g, '');
                            let alt_m = airport[this.KEY_ALT_M];
                            // add popup
                            let popup_content = name + "<br/>" + type + "<br/>" + ident;
                            let popup = L.popup({
                                autoPan: false,
                                className: "airport_popup"
                            }).setContent(popup_content);
                            marker.bindPopup(popup);

                            marker.on('mouseover', function(event) {
                                marker.openPopup();
                            });
                            marker.on('mouseout', function(event) {
                                marker.closePopup();
                            });
                            marker.on('click', (e) => {
                                console.log("User click:", ident, name);
                                this.mapper.task.add_new_poi(position, type, {
                                    "ident": ident,
                                    "name": name,
                                    "alt_m": alt_m,
                                    "runways": runways
                                });
                            });
                            if (ident == this.search_ident) {
                                marker.openPopup();
                                this.search_ident = null;
                            }
                        }
                    }
                }
            }
        }
    }

    // Return true if given airport "type" represents an MSFS airport
    is_msfs_airport(type) {
        return type != null && type.includes("msfs") && type.includes("airport")
    }

    // Return true if these airports are being displayed in an MSFS instrument
    is_instrument() {
        return this.instrument != null;
    }

    // Return airport info given ident e.g. lookup("LSMM") returns
    // { alt_m: 579.1, ident: "LSMM", lat: 46.74333, lng: 8.109999, name: "Meiringen Mil", runways: "28 10", type: "msfs_airport" }
    // Note our airports data structure is highly optimised for a lookup by lat/long (i.e. stored by latlong 'boxes')
    // so for what would seem a simple 'lookup by ident' we actually have to search all the airports.
    lookup(ident) {
        if (!this.available) {
            console.log("ERROR: airports lookup request, but data not available", ident);
            return null;
        }
        //console.log("b21_airports lookup", ident);
        for (const [box_key, airports_list] of Object.entries(this.airports_data.boxes)) {
            //console.log(box_key);
            for (let i = 0; i < airports_list.length; i++) {
                // airports_list is a list of the airports in the current 'box'
                // so airports_list[i] is the current airport we're checking for the ident
                // Each airport info is stored as a list of values, as defined in airport_keys
                if (airports_list[i][this.KEY_IDENT] == ident) {
                    //console.log("airports lookup ident found", ident, airports_list[i]);
                    return this.airport_list_to_obj(airports_list[i]);
                }
            }
        }
        console.log("airports.js lookup failed for "+ident);
        return null;
    }

    // Convert the compact airports list data to a JS obj
    airport_list_to_obj(airport_list) {
        let airport_info = {};
        // Note we use 'airport_keys' to map from key name (e.g. ident) to array entry (e.g. 0)
        for (const [key, value] of Object.entries(this.airports_data.airport_keys)) {
            airport_info[key] = airport_list[value]
        }
        airport_info["id"] = airport_info["ident"];
        airport_info["source"] = airport_info["type"] == "msfs_airport" ? "msfs_airports" : "ourairports";
        return airport_info
    }

    // User has typed in search box
    search(search_value) {
        let parent = this;
        const RESULTS_MAX = 50;
        let results = [];
        for (let box_id in this.airports_data.box_coords) {
            let airports = this.airports_data.boxes[box_id];
            for (let i = 0; i < airports.length; i++) {
                let airport = airports[i];
                let type = airport[this.KEY_TYPE];
                if (type.includes("airport")) {
                    let ident = airport[this.KEY_IDENT];
                    let name = airport[this.KEY_NAME].replaceAll('"', ""); // Remove double quotes if original name includes those.
                    if ((ident + "!" + name).toLowerCase().includes(search_value)) {
                        results.push(this.airport_list_to_obj(airport));
                        if (results.length > RESULTS_MAX) {
                            break;
                        }
                    }
                }
            }
            if (results.length > RESULTS_MAX) {
                break;
            }
        }

        return results;
    }

} // end class B21_Airports
// ******************************************************************************
// ***********   File_GPX class            **************************************
// ******************************************************************************

/* Interface;
        constructor(tracklog)
        load(file_str, filename)
        file_type                   // "gpx"
*/

/* For B21_TrackLog, FileGPX uses
        .filename
        .name
        .logpoints
        .using_airspeed = "GND" | "IAS" | "TAS"
        .pilot_name e.g. "C-OPPR" from "DG808S RUSSIA (C-OPPR)" from SimFlightPath
*/

class B21_File_GPX {

    constructor(tracklog) {
        this.tracklog = tracklog;
        this.file_type = "gpx";
        this.creator = null; // "Little Navmap" | "SimFlightPath 1.8"
    }

    //DEBUG reloading same GPX file should reset any task_fixup
    load(file_str, filename) {

        this.tracklog.filename = filename;

        let parser = new DOMParser();
        let xmlDoc = parser.parseFromString(file_str, "text/xml");
        let gpxs = xmlDoc.getElementsByTagName("gpx");
        if (gpxs == null || gpxs.length == 0) {
            console.log("Bad GPX: failed to find 'gpx' element");
            return false;
        }
        let gpx = gpxs[0];
        this.creator = gpx.getAttribute("creator");
        console.log("Creator",this.creator);

        let metadatas = gpx.getElementsByTagName("metadata");
        if (metadatas != null && metadatas.length != 0) {
            let descs = metadatas[0].getElementsByTagName("desc");
            if (descs != null & descs.length != 0) {
                let desc = descs[0].textContent;
                console.log("GPX load desc="+desc);
                let desc_index = desc.indexOf("✈"); // e.g. "✈ DG808S RUSSIA (ANRI)"
                if (desc_index >= 0) {
                    let name_str = desc.slice(desc_index+2);
                    console.log("GPX load name_str="+name_str);
                    this.tracklog.competition_id = this.get_competition_id(name_str);

                    this.tracklog.pilot_name = this.tracklog.competition_id; // For a SimFlightPath GPX, name = comp id

                    this.tracklog.glider_type = this.get_glider_type(name_str);

                    this.tracklog.name = (this.tracklog.competition_id == null ? "(no tail number)" : this.tracklog.competition_id) + " - "+
                        (this.tracklog.glider_type == null ? "??" : this.tracklog.glider_type);
                    console.log("GPX set tracklog.name="+this.tracklog.name);
                }
            }
        }

        if (this.tracklog.name == null) {
            let names = gpx.getElementsByTagName("name");
            if (names != null && names.length > 0) {
                this.tracklog.name = names[0].childNodes[0].nodeValue;
                console.log("GPX set tracklog.name="+this.tracklog.name);
            }
        }

        return this.load_trks(gpx);

    }

    get_competition_id(in_str) {
        console.log("get_competitionid ["+in_str+"]");
        let i0 = in_str.lastIndexOf("(");
        if (i0 == -1) {
            return null;
        }
        let i1 = in_str.indexOf(")",i0+2);
        if (i1 == -1) {
            return null;
        }
        let competition_id = in_str.substring(i0+1,i1);
        console.log("get_competitionid  got ["+competition_id+"]");
        return competition_id;
    }

    get_glider_type(in_str) {
        let file_glider_type = in_str.split(" ")[0];
        // We'll try and map the glider_type found into the file onto a 'standard' glider type
        let ref_glider_type = B21_GLIDERS.find_glider_type(file_glider_type);
        return ref_glider_type == "" ? file_glider_type : ref_glider_type;
    }

    // GPX file could have multiple <trk> elements, we only load the first
    load_trks(gpx) {
        let trks = gpx.getElementsByTagName("trk");
        if (trks == null || trks.length == 0) {
            console.log("Bad GPX: does not contain any 'trk' entries.");
            return false;
        }

        //DEBUG only checking first "trk" element
        let trk = trks[0];

        return this.load_trk(trk);
    }

    // GPX <trk> element could have multiple <trkseg> elements, we load all and concatenate them
    load_trk(trk) {
        //let names = trk.getElementsByTagName("name");
        //if (names != null && names.length > 0) {
        //    this.tracklog.name = names[0].childNodes[0].nodeValue;
        //}
        let trksegs = trk.getElementsByTagName("trkseg");
        if (trksegs == null || trksegs.length == 0) {
            console.log("Bad GPX.trks[0].trksegs");
            return false;
        }
        console.log(`GPX Loaded ${trksegs.length} 'trkseg' elements from GPX file.`);
        let segment_index = 0;
        for (let i = 0; i < trksegs.length; i++) {
            let trkseg = trksegs[i];
            segment_index = this.load_trkseg(segment_index,trkseg);
        }
        console.log(`GPX load_gpx loaded ${this.tracklog.logpoints.length} logpoints`);
        return true;
    }

    // Each GPX <trkseg> element contains the actual <trkpt> tracklog points
    load_trkseg(segment_index_in,trkseg) {
        console.log(`GPX Loading 'trkseg[${segment_index_in}]' entry from GPX file.`);
        let segment_index = segment_index_in;
        let trkpts = trkseg.getElementsByTagName("trkpt");
        if (trkpts == null || trkpts.length == 0) {
            return;
        }

        let decoded_pt;
        let points_added = false;
        let prev_ts = 0;    // ts of previous tracklog point
        let prev_segment_index = segment_index_in;

        for (let i = 0; i < trkpts.length; i++) {
            let trkpt = trkpts[i];
            if (i==1) { console.log("trkpt[1]:",trkpt); }
            decoded_pt = {};
            // lat
            decoded_pt["lat"] = parseFloat(trkpt.getAttribute("lat"));
            // lng
            decoded_pt["lng"] = parseFloat(trkpt.getAttribute("lon"));
            // alt_m
            let alts = trkpt.getElementsByTagName("ele");
            if (alts != null && alts.length != 0) {
                decoded_pt["alt_m"] = parseFloat(alts[0].childNodes[0].nodeValue);
            }
            // time_iso, ts
            let times = trkpt.getElementsByTagName("time");
            if (times != null && times.length != 0) {
                let time_iso = times[0].childNodes[0].nodeValue;
                decoded_pt["time_iso"] = time_iso;
                decoded_pt["ts"] = (new Date(time_iso)).getTime() / 1000; // logpoint.ts is in seconds from some day 0.
                if (decoded_pt["ts"] < prev_ts && points_added) {
                    // Time reversal so create new segment
                    console.log(`GPX Loading 'trkseg[${segment_index}]' has time reversal at ${i}. ${time_iso}`);
                    this.add_segment(segment_index);
                    segment_index += 1;
                    points_added = false;
                }
            }

            let airspeed_ms = null;
            let airspeeds = trkpt.getElementsByTagName("airspeed");
            if (airspeeds != null && airspeeds.length != 0) {
                airspeed_ms = parseFloat(airspeeds[0].childNodes[0].nodeValue);
            }
            if ( airspeed_ms != null && ! isNaN(airspeed_ms) ) {
                // We have found an "airspeed" value in the GPX (e.g. Alex's Albatross logger)
                // So will use that rather than ground speed calculate from the lat/long/time
                this.tracklog.using_airspeed = "IAS"; // Indicated Airspeed
                decoded_pt["speed_ms"] = airspeed_ms;
            } else if (i>0 && prev_segment_index == segment_index) {
                // speed m/s
                if (this.tracklog.logpoints.length > 0) {
                    let prev_pt = this.tracklog.logpoints[this.tracklog.logpoints.length - 1];
                    //let prev_ts = prev_pt["ts"];
                    let time_delta_s = decoded_pt["ts"] - prev_ts;
                    let prev_speed_ms = prev_pt["speed_ms"];

                    let dist_m = Geo.get_distance_m(prev_pt, decoded_pt);
                    let speed_ms = time_delta_s > 0 ? dist_m / time_delta_s : 0;
                    // Smoothing
                    const SMOOTH_S = this.creator == "Little Navmap" ? 10 : 1; // smoothing time constant
                    let weight = Math.min(1,time_delta_s / SMOOTH_S);
                    if (prev_speed_ms != null) {
                        decoded_pt["speed_ms"] = speed_ms * weight + prev_speed_ms * (1 - weight);
                    } else {
                        decoded_pt["speed_ms"] = speed_ms;
                    }
                }
            } else {
                decoded_pt["speed_ms"] = 0;
            }

            decoded_pt["segment_index"] = segment_index;
            prev_segment_index = segment_index;
            prev_ts = decoded_pt["ts"];

            // Store completed logpoint
            this.tracklog.logpoints.push(decoded_pt);
            points_added = true;
        }
        if (points_added) {
            this.add_segment(segment_index);
        }

        return segment_index+1;
    }

    add_segment(segment_index) {
        this.tracklog.segments.push({ segment_index: segment_index, active: true});
    }

} // end class B21_File_GPX
"use strict"
// ******************************************************************************
// ***********   File_IGC class            **************************************
// ******************************************************************************

/* Interface;
        constructor(tracklog)
        load(file_str, filename)
        file_type                   // "igc"
        c_records                   // list of actual records
        isNB21(set_value)           // True if tracklog is NB21 Logger format (default false)
        isLocal(set_value)          // True if this tracklog is fed DIRECTLY from the NB21 Logger (default false)
*/

/* For B21_TrackLog, File_IGC uses
        .filename
        .name
        .logpoints  // { lat: lng: alt_m: ts: time_iso: speed_ms: }
        .file_events               // List of TracklogEvents derived from file
*/

class B21_File_IGC {

    constructor(tracklog) {
        this.tracklog = tracklog;
        this.file_type = "igc";
        this.creator = null;      // Logger type name string e.g. NB21 Logger 0.5.7
        this.glider_type = null;
        this.NB21_fcheck = {};    // checksums "ok" or "fail" for IGC & ACFG, FMCG aircraft files
        this.c_records = [];      // Will be a list of strings for 'C' records from IGC file
        this.c_records_hash = ""; // quick check used by c_records_changed()
        this.prev_c_records_hash = "";
        this.date = null;         // DateTime from HFDTE record
        this.is_nb21 = false;     // This is a NB21 Logger tracklog
        this.is_local = false;    // This data is coming DIRECTLY from the logger
        this.I_lookup = null;     // From I Record: mapping of extra values in B records e.g. { TAS: {start: 39, end: 42} ...}

        // class vars for tracking progress through B records
        this.segment_index = 0;
        this.prev_time_s = 0;   // integer time in seconds-of-day i.e. between 0 <= time_s < 86400
        this.prev_point = null;
        this.record_count = 0;
        this.s = "Q"; // partial IGC checksum
        this.home = Geo.get_distance_m(this.tracklog.planner.map.getCenter(), {lat: 51.7184, lng: 0.1527}) < 5000;

        // working vars during IGC records read loop
        this.info_glider_id = "";
        this.info_competitionid = "";
        this.info_pilot_name = "";
    }

    // isNB21 returns true if this task was loaded from the NB21 Logger, or can be SET by passing true/false
    isNB21(set_value) {
        if (set_value != null) {
            this.is_nb21 = set_value;
        }
        return this.is_nb21;
    }

    // isLocal is true if the data in this file_obj is coming DIRECTLY from the NB21 Logger
    isLocal(set_value) {
        if (set_value != null) {
            this.is_local = set_value;
        }
        return this.is_local;
    }

    // load(file_str, filename) reads records from the file_str, and adds
    //   tracklog records as they are read, updating the 'date' and 'name' fields
    //   as appropriate records are found.
    load(file_str_incl_chksum, filename) {

        console.log(`b21_file_igc load() loading ${filename}`);

        this.tracklog.filename = filename;
        this.glidertype = null; // Glider type e.g. "DG-800S (18m)"
        this.date = null; //new Date(0); // Will set from HFDTE

        let chksum = null; // Will hold IGC checksum from file (for debug)

        // See if we find these values in the file
        this.info_gliderid = ""; // Glider reg e.g. "D-KVMY"
        this.info_competitionid = ""; // Competition id e.g. "B21"
        this.info_pilot_name = ""; // Pilot name
        this.s += "41";
        this.tracklog.segments.push({ segment_index: this.segment_index, active: true});

        // Check header record if this is an NB21 Logger file
        if (file_str_incl_chksum.includes("AXXX NB21")) {
            console.log("b21_file_igc loading NB21 file "+filename);
            this.t = "93";
            this.isNB21(true);
        } else {
            console.log("b21_file_igc loading non-NB21 IGC file");
        }

        // Check IGC Checksum for NB21 Logger files
        let file_str = file_str_incl_chksum;
        if (this.isNB21()) {
            chksum = this.check_IGC_checksum(file_str_incl_chksum);
        }

        // Iterate through all the records in the IGC file
        this.load_records(file_str);

        if (this.record_count==0) {
            return false;
        }

        let name = "";
        if (this.info_gliderid != "" || this.info_competitionid != "" || this.glider_type != "" || this.info_pilot_name != "") {
            if (this.info_competitionid != "") {
                name = this.info_competitionid + " - " + this.glider_type;
            } else if (this.info_gliderid != "") {
                name = this.info_gliderid + " - " + this.glider_type;
            } else if (this.info_pilot_name != "") {
                name = this.info_pilot_name + " - " + this.glider_type;
            }
        }

        // if no info_gliderid or info_competitionid record then get name from filename
        if (name == "") {
            let i = filename.lastIndexOf("/");
            if (i==-1) i = filename.lastIndexOf("\\");
            let j = filename.lastIndexOf(".");
            if (j==-1) j = filename.length;
            name = filename.substring(i+1,j);
        }
        console.log("b21_file_igc Made name '"+name+"'");

        // Write tracklog.name
        this.tracklog.name = name;

        // Write tracklog.competition_id
        if (this.info_competitionid != "") {
            this.tracklog.competition_id = this.info_competitionid;
        }

        // Write tracklog.pilot_name
        if (this.info_pilot_name != "") {
            this.tracklog.pilot_name = this.info_pilot_name;
        }

        // Record the status of the checksum checking
        this.tracklog.NB21_fcheck = this.NB21_fcheck;

        //DEBUG temporatily disabling NB21 check if (this.isNB21() && this.c_records.length > 0) {
        if (this.c_records.length > 0) {
            console.log(`b21_file_igc IGC tracklog "${name}" hasTask = true`);
            this.tracklog.hasTask = true;
        }

        if (this.I_lookup != null && this.I_lookup["TAS"] != null) {
            this.tracklog.using_airspeed = "TAS";
        }

        console.log(`b21_file_igc IGC file "${name}" loaded ${this.tracklog.logpoints.length} logpoints, hasTask=${this.tracklog.hasTask}`);

        return true;
    }

    ignore_igc_record(rec) {
        if (rec == null) {
            return true;
        }
        if (typeof rec != "string") {
            return true;
        }
        // Ignore B records near latlng 0,0
        // B1226250000024N00000838EA00001...
        if (rec.charAt(0) == 'B' && rec.slice(7,12) == "00000" && rec.slice(15,20) == "00000") {
            //console.log(`b21_file_igc.ignore_igc_record(${rec}) is true`);
            return true;
        }
        //console.log(`b21_file_igc.ignore_igc_record(${rec}) is false`);
        return false;
    }

    // Heaader records IGC 2016
    //    H F DTE DATE: DD MM YY, NN CRLF
    //    H F PLT PILOT IN CHARGE: TEXT STRING CRLF
    //    H F CM2 CREW 2: TEXT STRING CRLF
    //    H F GTY GLIDER TYPE: TEXT STRING CRLF
    //    H F GID GLIDER ID: TEXT STRING CRLF
    //    H F DTM GPS DATUM: WGS84 CRLF
    //    H F RFW FIRMWARE VERSION: TEXT STRING CRLF
    //    H F RHW HARDWARE VERSION: TEXT STRING CRLF
    //    H F FTY FR TYPE: MANUFACTURERS NAME,FR MODEL NAME CRLF
    //    H F GPS RECEIVER: MANUFACTURERS NAME, MODEL NAME, CHANNELS, MAX ALT CRLF
    //    H F PRS PRESS ALT SENSOR: MANUFACTURERS NAME, MODEL NAME, MAXALT CR LF
    //    H F FRS SECURITY OK or SECURITY SUSPECT / SECURITY MS OPERATED (as relevant): TEXTSTRING CRLF

    load_records(msg) {

        // Iterate through all the records in the IGC file
        var lines = msg.split('\n');
        for (var line_num=0; line_num < lines.length; line_num++) {
            let rec = lines[line_num];

            let buf = rec.replace(/(\r\n|\n|\r)/gm, ""); // cleanup the LF/CR crapola

            if (this.ignore_igc_record(buf)) continue;

            if (buf.charAt(0) == 'B') {

                this.handle_B_record(buf);

            } else if (buf.charAt(0) == 'I') {

                this.handle_I_record(buf);

            } else if (buf.charAt(0) == 'C') {

                this.handle_C_record(buf);

            } else if (buf.toLowerCase().includes("gliderid")) {

                this.info_gliderid = this.handle_gliderid(buf);

            } else if (buf.toLowerCase().includes("competitionid")) {

                this.info_competitionid = this.handle_competitionid(buf);

            } else if (buf.toLowerCase().includes("glidertype")) {

                this.glider_type = this.handle_glidertype(buf);
                this.tracklog.glider_type = this.glider_type;

            } else if (buf.toLowerCase().includes("pilot")) {

                this.info_pilot_name = this.handle_pilot(buf);

            } else if (buf.startsWith("HFDTE")) {
                // HFDTE231024
                // HFDTEDATE:120924,01
                if (buf.startsWith("HFDTEDATE")) {
                    this.date = this.HFDTE_date(buf.substring(10));
                } else {
                    // E.g. HFDTE230622
                    this.date = this.HFDTE_date(buf.substring(5));
                }
                console.log("b21_file_igc Using HFDTE date",this.date);

            } else if (buf.startsWith("HFFTYFRTYPE")) {

                this.handle_HFFTYFRTYPE_record(buf);

            } else if (buf.startsWith("HFRFWFIRMWAREVERSION")) {

                this.handle_HFRFWFIRMWAREVERSION_record(buf);

            } else if (buf.startsWith("LNB21")) {

                this.handle_LNB21_record(buf);
            }
        } // End iteration loop for IGC file records
    }

    // Calculate and check the IGC checksum, returning the calculated value
    check_IGC_checksum(file_str_incl_chksum) {
        let chksum = null;
        let file_strs = file_str_incl_chksum.split("GB21DEADBEEF");

        if (file_strs.length > 1) {
            // Calculate the SHA1 of the file excluding the G records
            try {
                let file_str = file_strs[0];
                chksum = sha1(this.s+"7"+this.t+file_str).slice(12,36);
            } catch (e) {
                console.log("b21_file_igc Checksum calculation error ",e);
                chksum = null;
            }

            if (chksum != null) {
                console.log("b21_file_igc chksum "+chksum);
                let file_G_chksum = null;
                try {
                    file_G_chksum = file_strs[1].split("G")[1].replace(/(\r\n|\n|\r)/gm, "").toLowerCase();
                    //file_str = file_strs[0];
                } catch (e) {
                    console.log("b21_file_igc can't parse NB21 checksum G record from IGC file",e);
                }

                if (file_G_chksum == chksum) {
                    console.log("b21_file_igc NB21 chksum OK");
                    this.NB21_fcheck["IGC"] = "ok";
                } else {
                    this.NB21_fcheck["IGC"] = "fail";
                    if (this.home) {
                        console.log("b21_file_igc BAD NB21 chksum '"+file_G_chksum+"' '"+chksum+"'");
                    }
                }
            }
        }
        else
        {
            console.log("b21_file_igc NB21 checksum not found in IGC file.");
        }
        return chksum;
    }

    check_backwards_time_s(time_s) {
        let file_obj = this;
        if (time_s < file_obj.prev_time_s) {
            if (file_obj.isNB21() || time_s < 3600) {
                // if time seems to have gone backwards and it's just after midnight, add a day
                file_obj.date.setDate(file_obj.date.getDate()+1);
                console.log("b21_file_igc IGC date rolled over to next day",file_obj.date);
            } else {
                // here time's gone backwards apparently for no reason so move to a new segment
                console.log(`b21_file_igc IGC time reversal detected, index:${file_obj.record_count} ${file_obj.date}, creating another segment:${file_obj.segment_index+1}`);
                file_obj.segment_index++;
                file_obj.tracklog.segments.push({ segment_index: file_obj.segment_index, active: true});
            }
        }
        file_obj.prev_time_s = time_s; // update file_obj.prev_time_s for the next iteration
    }

    // process B record from IGC file
    handle_B_record(buf) {
                let file_obj = this;
                //       hhmmss<-lat--><-lng--->A<alt><alt><extensions...>
                //      0      7       15       24
                // E.g. B1056534512951N00550585EA002190021901812

                // ts
                // time_s is time-of-day as seconds since midnight
                let time_s_str = buf.substring(1,7);
                if (time_s_str.length != 6 || time_s_str == "000000") {
                    //console.log("IGC skipping file_obj.record_count ",file_obj.record_count);
                    return;
                }
                let time_s = B21_Utils.hhmmss_to_time_s(time_s_str);

                // Check this record 'time_s' (time-of-day in seconds) vs the time_s previously seen.

                if (time_s == file_obj.prev_time_s) {
                    //console.log("IGC skipping file_obj.record_count ",file_obj.record_count);
                    return; // If two consective B records with same time then skip
                }

                file_obj.check_backwards_time_s(time_s); // update file_obj.prev_time_s for the next iteration

                let ts = file_obj.make_ts(file_obj.date, time_s); // timestamp in seconds (since 1970-01-01 00:00)

                // time_iso
                let time_iso;
                try {
                    time_iso = (new Date(ts * 1000)).toISOString()
                } catch (e) {
                    console.log("handle_B_record() bad time", ts, buf);
                    return;
                }

                // lat
                let lat_str = buf.substring(7,15);
                if (lat_str.length != 8) {
                    console.log("b21_file_igc IGC skipping B (lat) file_obj.record_count= ",file_obj.record_count);
                    return;
                }
                let lat = file_obj.decimal_latlong(lat_str);
                if (buf.charAt(24) != 'V' && buf.charAt(24) != "A") {
                    console.log("b21_file_igc IGC skipping B without A or V file_obj.record_count: ",file_obj.record_count);
                    return;
                }

                // lng
                let lng_str = buf.substring(15,24);
                if (lng_str.length != 9) {
                    console.log("IGC skipping  B (lng) file_obj.record_count=",file_obj.record_count);
                    return;
                }
                let lng = file_obj.decimal_latlong(lng_str);

                if (Math.abs(lat) < 1 && Math.abs(lng) < 1) {
                    //console.log("IGC skipping  B (latlng at 0,0) file_obj.record_count=",file_obj.record_count);
                    return;
                }

                // alt_m
                let alt_m;
                if (buf.length >= 34) {
                    alt_m = parseFloat(buf.slice(30, 35)); // Use GPS altitude
                } else {
                    alt_m = parseFloat(buf.slice(25, 30)); // Use pressure altitude
                }

                // speed m/s
                let speed_ms = 0;
                if (file_obj.I_lookup != null && file_obj.I_lookup.TAS != null) {
                   speed_ms = parseInt(buf.slice(file_obj.I_lookup.TAS.start-1, file_obj.I_lookup.TAS.end)) / file_obj.tracklog.planner.MS_TO_KPH;
                } else if (file_obj.record_count > 1) {
                    let prev_ts = file_obj.prev_point["ts"];
                    let time_delta_s = ts - prev_ts;
                    let prev_speed_ms = file_obj.prev_point["speed_ms"];

                    let dist_m = Geo.get_distance_m(file_obj.prev_point, { lat: lat, lng: lng });
                    let speed_ms_now = dist_m / time_delta_s;
                    // Smoothing
                    const SMOOTH_S = file_obj.isNB21() ? 2 : 10; // smoothing time constant for XCSoar
                    let weight = Math.min(1,time_delta_s / SMOOTH_S);
                    if (prev_speed_ms != null) {
                        speed_ms = speed_ms_now * weight + prev_speed_ms * (1 - weight);
                    } else {
                        speed_ms = speed_ms_now;
                    }
                }

                // cache for next iteration
                file_obj.prev_point = {
                    lat: lat,
                    lng: lng,
                    alt_m: alt_m,
                    ts: ts,
                    time_iso: time_iso,
                    speed_ms: speed_ms,
                    segment_index: file_obj.segment_index //DEBUG assuming current IGC files are all 1 segment of a tracklog
                };

                // ADD I_record values to file_obj.prev_point, e.g. file_obj.prev_point.NET
                if (file_obj.I_lookup != null) {
                    for (const I_name in file_obj.I_lookup) {
                        let I_value = buf.slice(file_obj.I_lookup[I_name].start-1, file_obj.I_lookup[I_name].end);
                        switch (I_name) {
                            case "AGL":
                                file_obj.prev_point["AGL"] = parseInt(I_value);
                                break;
                            case "TAS":
                                // TAS in IGC file is kph, but logpoint will hold m/s
                                file_obj.prev_point["TAS"] = parseInt(I_value) / 3.6;
                                break;
                            case "FLP":
                                file_obj.prev_point["FLP"] = I_value;
                                break;
                            case "GND":
                                file_obj.prev_point["GND"] = I_value != "0";
                                break;
                            case "NET":
                                file_obj.prev_point["NET"] = parseInt(I_value) / 100;
                                break;
                            case "ENL":
                                file_obj.prev_point["ENL"] = I_value != "000";
                                break;
                            case "WSP":
                                file_obj.prev_point["WSP"] = parseInt(I_value);
                                break;
                            case "WDI":
                                file_obj.prev_point["WDI"] = parseInt(I_value);
                                break;
                            default:
                                break;
                        }
                    }
                }
                // Append this time/position data to tracklog.logpoints
                file_obj.tracklog.logpoints.push(file_obj.prev_point);

                file_obj.record_count++;
    }

    handle_C_record(buf) {
        console.log("b21_file_igc C record: "+buf);
        this.c_records.push(buf);
    }

    // E.g. I063638FXA3942TAS4346NET4749ENL5050FLP5151GND
    handle_I_record(buf) {
        console.log(`b21_file_igc I record: ${buf}`);
        this.I_lookup = {};
        // Step through values in I record
        let i = 3;
        try {
            while (i < buf.length - 6) {
                let start = parseInt(buf.slice(i,i+2));
                let end = parseInt(buf.slice(i+2,i+4));
                let name = buf.slice(i+4,i+7);

                this.I_lookup[name] = {start: start, end: end};
                i += 7;
            }
        } catch {
            return;
        }
        console.log("b21_file_igc I_lookup:", this.I_lookup);
    }

    // E.g. "HFFTYFRTYPE:XCSOAR,XCSOAR PC 7.38"
    handle_HFFTYFRTYPE_record(buf) {
        this.creator = buf.substring(12).trim() + (this.creator == null ? "" : " "+this.creator); // maybe already contains version
    }

    // E.g. "HFRFWFIRMWAREVERSION: 0.5.5"
    handle_HFRFWFIRMWAREVERSION_record(buf) {
        this.creator = (this.creator == null ? "" : this.creator + " ") + buf.substring(21).trim(); // maybe already contains type
    }

    // handle "L" comment records in tracklog from NB21 Logger
    handle_LNB21_record(buf) {
        let file_obj = this;
        let tracklog = this.tracklog;

        // ts
        let time_s_str = buf.substring(6,12);
        if (time_s_str.length != 6 || isNaN(time_s_str)) {
            console.warn(`B21_File_IGC Bad timestamp in ${buf}`);
            return;
        }
        let time_s = B21_Utils.hhmmss_to_time_s(time_s_str);

        file_obj.check_backwards_time_s(time_s); // increment date if time goes backwards in NB21 tracklog

        let ts = file_obj.make_ts(file_obj.date, time_s); // Create timestamp seconds in epoch

        if (buf.includes(" FCHK ")) {
            this.handle_L_FCHK(buf);
        } else {
            try {

                let file_events_index = tracklog.file_events.length;
                tracklog.file_events.push(new Tracklog_FileEvent(null,buf,ts,file_events_index)); // event_key in buf
            } catch (e) {
                console.error(e);
            }
        }
    }

    // handle gliderid
    handle_gliderid(buf) {
        let pos = buf.indexOf(":");
        if (pos > 4 && pos + 1 < buf.length) {
            let info_gliderid = buf.substring(pos + 1);
            // Remove leading/trailing spaces
            info_gliderid = info_gliderid.trim();
            console.log("b21_file_igc Found info_gliderid <" + info_gliderid + "> from IGC file");
            return info_gliderid;
        }
        return "";
    }

    handle_competitionid(buf) {
        let pos = buf.indexOf(":");
        if (pos > 4 && pos + 1 < buf.length) {
            let info_competitionid = buf.substring(pos + 1);
            // Remove leading/trailing spaces
            info_competitionid = info_competitionid.trim();
            console.log("b21_file_igc Found info_competitionid <" + info_competitionid + "> from IGC file");
            return info_competitionid.trim();
        }
        return "";
    }

    handle_glidertype(buf) {
        let pos = buf.indexOf(":");
        if (pos > 4 && pos + 1 < buf.length) {
            let glider_type = buf.substring(pos + 1);
            // Remove leading/trailing spaces and only take first word
            glider_type = glider_type.trim().split(" ")[0];
            let standard_type = B21_GLIDERS.find_glider_type(glider_type);
            if (standard_type !== "") {
                glider_type = standard_type;
            }
            console.log("b21_file_igc Found glider type <" + glider_type + "> from IGC file");
            return glider_type;
        }
        return "";
    }

    handle_pilot(buf) {
        let pos = buf.indexOf(":");
        if (pos > 4 && pos + 1 < buf.length) {
            let info_pilot_name = buf.substring(pos + 1);
            // Remove leading/trailing spaces
            info_pilot_name = info_pilot_name.trim();
            console.log("b21_file_igc Found pilot <" + info_pilot_name + "> from IGC file");
            return info_pilot_name;
        }
        return "";
    }

    // Aircraft file checksum
    handle_L_FCHK(buf) {
        console.log("b21_file_igc handle_L_FCHK: "+buf);
        let fields = buf.split(" ");
        let event_key = fields[3]; // ACFG = aircraft.cfg, FMCG = flight_model.cfg
        let chksum = fields[4].replace(/(\r\n|\n|\r)/gm, "");
        try {
            let key_index = B21_GLIDERS.check_key(this.glider_type, event_key, chksum)
            if (key_index != null) {
                console.log(`b21_file_igc checksum for '${this.glider_type}' '${event_key}' '${chksum}' OK V${key_index+1}`);
                this.NB21_fcheck[event_key] = "okV"+(key_index+1);
            } else {
                this.NB21_fcheck[event_key] = "'"+chksum+"'";
                console.log("b21_file_igc checksum for '"+this.glider_type+"' '"+event_key+"' '"+chksum+"' FAIL");
            }
        } catch (e) {
            console.log("b21_file_igc checksum error",e);
        }
    }

    // Convert string from B record to float decimal degrees lat/lng
    // E.g. 4512951N (45 deg, 12.951 min) or 00550585E (5 deg, 50.585 min)
    decimal_latlong(str)
    {
        let EWNS = str.slice(-1);
        let deg;
        let min;
        if (EWNS=="N" || EWNS=="S") {
            deg = parseInt(str.substring(0,2));
            min = parseInt(str.substring(2,7));
        } else {
            deg = parseInt(str.substring(0,3));
            min = parseInt(str.substring(3,8));
        }

        if ((EWNS == 'W') || (EWNS == 'S')) {
            return -(deg + (min / 60000));
        }
        return (deg + (min / 60000));
    }

    // Make a JS timestamp from this tracklog JS date + time-of-day in seconds
    make_ts(date, time_s) {
        return date.getTime() / 1000 + time_s; // timestamp in seconds (since 1970-01-01 00:00)
    }

    // Convert HFDTE string to JS UTC Date
    HFDTE_date(str) {
        //      ddmmyy
        // E.g. 230622
        return new Date( Date.UTC(parseInt("20"+str.substring(4,6)),parseInt(str.substring(2,4)-1),parseInt(str.substring(0,2))) );
    }

    // *************************************************************************
    // Load this.tracklog.planner.task if possible from the "C" records
    // *************************************************************************

    // Load task from c_records[] string array
    // E.g.
    //  C270923180009120050000106SSC_New_Caledonia_301_SW
    //  C2215500S16628367ENWWM;17;Magenta
    //  C2210176S16625954EStart 5000+10|5000x4000
    //  C2137040S16611213ETP1+1614x2000
    //  C2056269S16439503ETP2+16x2000
    //  C2032973S16415718EFinish+33x2000
    //  C2032783S16415333ENWWK;Koumac

    // or from a Naviter Oudie (??)
    // C 120924 10 57 33 000000000004
    // C0000000N00000000E
    // C5535335N00205377WMilfield
    // C5539236N00214492WColdstream
    // C5536207N00246803WGalashiels
    // C5532628N00254020WSelkirk W
    // C5546737N00220717WDuns
    // C5535335N00205377WMilfield
    // C0000000N00000000E

    load_task(task) {
        const file_obj = this;
        if (file_obj.c_records.length == 0) {
            console.log("b21_file_igc no task to load from IGC file");
            return;
        }

        // Set task.name
        let name = file_obj.c_records[0].slice(25);
        if (name == "") {
            name = "no name"; // Debug maybe we can improve task name
        }
        let wp_count = file_obj.c_records[0].slice(23,25);
        console.log(`b21_file_igc Loading B21_Task "${file_obj.c_records[0]}" "${name}" with ${wp_count} waypoints.`);

        task.name = name;

        // Set task.isNB21() and task.isLocal()
        task.isNB21(file_obj.isNB21());
        task.isLocal(file_obj.isLocal());

        // ***************************
        // Waypoints
        for (let i=1; i<this.c_records.length; i++) {
            this.task_add_wp(task, file_obj.c_records[i], i-1);
        }
    }

    task_add_wp(task, buf) {
        const file_obj = this;
        console.log(`b21_file_igc adding wp ${buf}`);

        // Set position
        let N_pos = buf.indexOf("N");
        let S_pos = buf.indexOf("S");
        let lat_end_pos = Math.min(N_pos, S_pos);
        if (lat_end_pos < 0) {
            lat_end_pos = Math.max(N_pos, S_pos);
        }
        let lat_str = buf.slice(1, lat_end_pos+1);

        let E_pos = buf.indexOf("E");
        let W_pos = buf.indexOf("W");
        let lng_end_pos = Math.min(E_pos, W_pos);
        if (lng_end_pos < 0) {
            lng_end_pos = Math.max(E_pos, W_pos);
        }
        let lng_str = buf.slice(lat_end_pos+1, lng_end_pos+1);

        console.log(`lat_str: "${lat_str}" lng_str: "${lng_str}"`);

        // NB21 temporary bugfix
        if (lat_str.length == 9 && lat_str.slice(4,8) == "1000") {
            console.log(`lat_str was "${lat_str}"`);
            lat_str = lat_str.slice(0,2) + ("0"+(parseInt(lat_str.slice(2,4))+1).toFixed(0)).slice(-2) + "000"+lat_str.slice(8,9);
            console.log(`lat_str bugfix now "${lat_str}"`);
        }
        if (lng_str.length == 10 && lng_str.slice(5,9) == "1000") {
            console.log(`lng_str was "${lng_str}"`);
            lng_str = lng_str.slice(0,3) + ("0"+(parseInt(lng_str.slice(3,5))+1).toFixed(0)).slice(-2) + "000"+lng_str.slice(9,10);
            console.log(`lat_str bugfix now "${lng_str}"`);
        }

        let lat = (lat_str.slice(7,8) == "N" ? 1 : -1) * (parseInt(lat_str.slice(0,2)) + parseInt(lat_str.slice(2,4))/60 + parseInt(lat_str.slice(4,7))/60000);

        let lng = (lng_str.slice(8,9) == "E" ? 1 : -1) * (parseInt(lng_str.slice(0,3)) + parseInt(lng_str.slice(3,5))/60 + parseInt(lng_str.slice(5,8))/60000);

        if (lat==0 && lng==0) {
            console.log(`task_add_wp skipping bad waypoint ${buf}`);
            return;
        }

        let wp = new B21_WP(file_obj.tracklog.planner);

        let index = task.waypoints.length;

        task.index = index;

        wp.new_point(index, new L.latLng(lat, lng));


        let name = buf.slice(lng_end_pos+1);
        console.log(`b21_file_igc looking for name in '${name}'`);

        // Separate any AAT part
        let aat_part = "";
        let aat_pos = name.indexOf(";AAT");
        if (aat_pos >= 0) {
            aat_part = name.slice(aat_pos);
            name = name.slice(0,aat_pos);
            console.log(`AAT wp, looking for icao,rw in ${name}`);
        }
        // Detect/remove AAT
        //if (name.includes(";AAT")) {
        //    name = name.replace(";AAT","");
        //    wp.isAAT(true);
        //}

        // Split out any airport ICAO / RW from "LFNH;31L;Carpentras"
        let icao_rw_name = name.split(";");
        if (icao_rw_name.length == 3) {
            console.log(`b21_file_igc name starts icao;rw;... '${name}'`);

            wp.icao = icao_rw_name[0];
            let runway_id = icao_rw_name[1];
            if ( runway_id.length == 1 ) {
                runway_id = "0"+runway_id;
            }
            wp.set_runway_str(runway_id);
            name = icao_rw_name[2];
        } else if (icao_rw_name.length == 2) {
            console.log(`b21_file_igc name starts icao;... '${name}'`);

            wp.icao = icao_rw_name[0];
            name = icao_rw_name[1];
        }

        wp.name = name+aat_part;

        console.log(`b21_file_igc.task_add_wp task.decode_wp_name(${wp.name})`);
        task.waypoints.push(wp);
        task.decode_wp_name(wp);
        console.log(`b21_file_igc task added WP ${index} '${wp.name}' icao:'${wp.icao}' rw:'${wp.runway_str}'`);
    }

    // Search through the LNB21 TOTW records for the weight at logpoints_index
    // Return null if ntot found
    get_weight_kg(logpoints_index) {
        let file_obj = this;
        let tracklog = this.tracklog;

        console.log("b21_file_igc get_weight_kg "+logpoints_index);
        if (logpoints_index < 0 || logpoints_index >= tracklog.logpoints_file.length) {
            return null;
        }

        let logpoint = tracklog.logpoints_file[logpoints_index];

        if (logpoint == null) {
            return null;
        }

        let weight_kg = 0;
        let events_index = 0;
        while (events_index<tracklog.file_events.length) {
            if (tracklog.file_events[events_index].event_key == "TOTW") {
                if (tracklog.file_events[events_index].ts >= logpoint.ts) {
                    console.log("b21_file_igc later LNB21 TOTW record at "+events_index);
                    break;
                }
                weight_kg = tracklog.file_events[events_index].values[0];
                console.log("b21_file_igc got TOTW at "+events_index+" "+weight_kg);
            }
            events_index++;
        }
        return weight_kg != 0 ? weight_kg : null;
    }

    // Search through the LNB21 LDAT records for the date at logpoints_index
    // Returns YYYYMMDD or null if not found
    get_sim_date(logpoints_index) {
        let file_obj = this;
        let tracklog = this.tracklog;

        console.log("b21_file_igc get_sim_date "+logpoints_index);
        if (logpoints_index < 0 || logpoints_index >= tracklog.logpoints_file.length) {
            return null;
        }

        let logpoint = tracklog.logpoints_file[logpoints_index];

        if (logpoint == null) {
            return null;
        }

        let sim_date_str = "";
        let events_index = 0;
        while (events_index<tracklog.file_events.length) {
            if (tracklog.file_events[events_index].event_key == "LDAT") {
                if (tracklog.file_events[events_index].ts >= logpoint.ts) {
                    console.log("b21_file_igc later LNB21 LDAT record at "+events_index);
                    break;
                }
                sim_date_str = tracklog.file_events[events_index].values[1];
                console.log("b21_file_igc got LDAT at "+events_index+" "+sim_date_str);
            }
            events_index++;
        }
        return sim_date_str != "" ? sim_date_str : null;
    }

    // Search through the LNB21 LTIM records for the in-sim time at logpoints_index
    // Returns HHMMSS or null if not found
    get_sim_time(logpoints_index) {
        let file_obj = this;
        let tracklog = this.tracklog;

        console.log("b21_file_igc get_sim_time "+logpoints_index);
        if (logpoints_index < 0 || logpoints_index >= tracklog.logpoints_file.length) {
            return null;
        }

        let logpoint = tracklog.logpoints_file[logpoints_index];

        if (logpoint == null) {
            return null;
        }

        let ltim_sim_time_str = "";
        let ltim_record_ts = null;
        let events_index = 0;
        while (events_index<tracklog.file_events.length) {
            if (tracklog.file_events[events_index].event_key == "LTIM") {
                if (tracklog.file_events[events_index].ts >= logpoint.ts) {
                    console.log("b21_file_igc later LNB21 LTIM record at "+events_index);
                    break;
                }
                ltim_sim_time_str = tracklog.file_events[events_index].values[1];
                ltim_record_ts = tracklog.file_events[events_index].ts
                console.log("b21_file_igc got LTIM at "+events_index+" "+ltim_sim_time_str, ltim_record_ts);

            }
            events_index++;
        }
        if (ltim_sim_time_str == "") {
            return null;
        }

        let ltim_sim_time_ts = file_obj.make_ts(file_obj.date, B21_Utils.hhmmss_to_time_s(ltim_sim_time_str));
        let logpoint_sim_time_s = logpoint.ts + ltim_sim_time_ts - ltim_record_ts;

        let logpoint_sim_time_datetime = new Date(logpoint_sim_time_s * 1000);
        let hh = ('0'+logpoint_sim_time_datetime.getUTCHours()).slice(-2);
        let mm = ('0'+logpoint_sim_time_datetime.getUTCMinutes()).slice(-2);
        let ss = ('0'+logpoint_sim_time_datetime.getUTCSeconds()).slice(-2);
        let logpoint_sim_time_str = hh+mm+ss;

        console.log("b21_file_igc get_sim_time "+logpoints_index+" is "+logpoint_sim_time_str);

        return logpoint_sim_time_str;
    }

    // *************************************************************************
    // ********** Local player, i.e. from NB21 Logger          *****************
    // *************************************************************************

    update_local_player_header(msg) {
        let file_obj = this;
        //console.log(`B21_IGC_File.update_local_player_header(${msg})`);
        if (file_obj.date == null) {
            file_obj.date = new Date();
        }
        file_obj.isNB21(true);
        file_obj.isLocal(true);
        file_obj.creator = null;
        file_obj.c_records = []; // Reset the task
        file_obj.tracklog.hasTask = false;
        file_obj.prev_c_records_hash = file_obj.c_records_hash;

        file_obj.load_records(msg);

        if (file_obj.c_records.length > 0) {
            file_obj.set_c_records_hash();
            console.log(`B21_IGC_File.update_local_player_header() prev_c_records_hash=${file_obj.prev_c_records_hash} c_records_hash=${file_obj.c_records_hash}`);
            file_obj.tracklog.hasTask = true;
        }

    }

    update_local_player(msg) {
        let file_obj = this;
        if (file_obj.date == null) {
            file_obj.date = new Date();
        }
        //console.log(`B21_IGC_File.update_local_player(${msg})`);
        file_obj.load_records(msg);

        if (!msg.startsWith("B") || file_obj.tracklog.logpoints.length == 0) {
            return null;
        }
        return file_obj.tracklog.logpoints[file_obj.tracklog.logpoints.length-1];
    }

    set_c_records_hash() {
        let file_obj = this;
        let chk = 0x12345678;
        let s = file_obj.c_records.slice(1).join("^");
        console.log(`B21_IGC_File.set.c_records_hash() for ${s}`);
        let len = s.length;
        for (var i = 0; i < len; i++) {
            chk += (s.charCodeAt(i) * (i + 1));
        }
        console.log(`B21_IGC_File.set.c_records_hash() chk=${chk}`);
        file_obj.c_records_hash = (chk & 0xffffffff).toString(16);
    }

    c_records_changed() {
        let file_obj = this;
        let changed = file_obj.prev_c_records_hash != file_obj.c_records_hash;
        console.log(`b21_file_igc.c_records_changed() ${file_obj.prev_c_records_hash} ${file_obj.c_records_hash} ${changed}`);
        return changed;
    }

} // end class B21_File_IGC

// ******************************************************************************
// ***********   B21_FILE_KML class          **************************************
// ******************************************************************************

// Constructs a .kml file for output

class B21_FILE_KML {

    constructor(task) {

        this.task = task;
        this.departure = null;
        this.departure_updated = false; // will set to true if/when the departure runway has been set in the first waypoint
        this.destination = null;
    }


    check() {
        if (this.task == null) {
            throw "Cannot create KML FlightPlan with no task";
        }

        if (this.task.waypoints.length < 2) {
            throw "Cannot create KML FlightPlan with less than 2 waypoints";
        }
    }

    clean(str) {
        return str.replaceAll('"', "");
    }

    // *********************************
    // Get complete text for KML file
    // *********************************
    get_text() {
        this.check();

        let header_text = this.get_header_text();
        let wp_text = "";
        for (let i = 0; i < this.task.waypoints.length; i++) {
            wp_text += this.get_wp_text(i);
            wp_text += this.get_track_line_text(i);
        }
        let footer_text = this.get_footer_text();

        let text = header_text + wp_text + footer_text;

        return text;
    }

    // *********************************
    // Some support functions
    // *********************************

    get_title() {
        if (this.task.name != null) {
            return this.task.name;
        }
        let first_wp = this.task.waypoints[0];
        let last_wp = this.task.waypoints[this.task.waypoints.length-1];
        let from = first_wp.icao != null ? first_wp.icao : first_wp.get_name();
        let to = last_wp.icao != null ? last_wp.icao : last_wp.get_name();

        return from + " to " + to;
    }

    get_descr() {
        if (this.task.description != null) {
            return this.task.description;
        }

        return this.get_title();
    }

    get_long_lat_alt(wp) {
        return `${wp.position.lng},${wp.position.lat},${wp.alt_m}`;
    }

    // *****************************************************
    // File to build KML text pieces:
    //      get_header_text()
    //      get_wp_text(index)
    //      get footer_text()
    // *****************************************************

    // Return the XML string for the 'header' part of the PLN file
    get_header_text() {
        let header_text = this.get_header_template();

        return header_text;
    }

    // Return the XML string for each waypoint (either "User" or "Airport" depending on wp.icao==null)
    get_wp_text(index) {
        let wp = this.task.waypoints[index];
        //let encoded_name = this.clean(this.task.get_encoded_name(wp));
        let wp_text = "";
        wp_text = this.get_wp_template();
        if (wp.is_task_start() || wp.is_task_finish()) {
            wp_text = wp_text.replace("#WP_TYPE#", "#wp_start_finish");
        }
        wp_text = wp_text.replace("#WP_NAME#", wp.get_name());
        wp_text = wp_text.replace("#WP_LONG_LAT_ALT#", this.get_long_lat_alt(wp));
        return wp_text;
    }

    // Return the XML string for each waypoint (either "User" or "Airport" depending on wp.icao==null)
    get_track_line_text(index) {
        if (this.task.waypoints.length < index+2) {
            return "";
        }
        let track_line_template = this.get_track_line_template();
        let wp1 = this.task.waypoints[index];
        let wp2 = this.task.waypoints[index+1];
        let track_line_text = "";
        track_line_text = track_line_template.replace("#WP1_LONG_LAT_ALT#", this.get_long_lat_alt(wp1));
        track_line_text = track_line_text.replace("#WP2_LONG_LAT_ALT#", this.get_long_lat_alt(wp2));
        return track_line_text;
    }

    // Return XML string for the end of the PLN file
    get_footer_text() {
        let footer_text = this.get_footer_template();
        return footer_text;
    }

    get_header_template() {
        return `<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://www.opengis.net/kml/2.2" xmlns:gx="http://www.google.com/kml/ext/2.2" xmlns:kml="http://www.opengis.net/kml/2.2" xmlns:atom="http://www.w3.org/2005/Atom">
<Document>
    <Style id="verticalLine">
      <LineStyle>
        <width>5.0</width>
        <color>ffffffff</color>
      </LineStyle>
    </Style>
	<Style id="trackLine"><LineStyle><color>7f00ff00</color><width>8</width></LineStyle></Style>

	<gx:CascadingStyle kml:id="wp_style_highlight">
		<styleUrl>https://earth.google.com/balloon_components/base/1.0.26.0/card_template.kml#main</styleUrl>
		<Style>
			<IconStyle>
				<scale>1.8</scale>
				<Icon><href>https://earth.google.com/earth/rpc/cc/icon?color=42a5f5&amp;id=2271&amp;scale=4</href></Icon>
				<hotSpot x="64" y="128" xunits="pixels" yunits="insetPixels"/>
			</IconStyle>
			<LabelStyle><scale>1.5</scale></LabelStyle>
			<LineStyle><width>1.5</width></LineStyle>
			<PolyStyle></PolyStyle>
			<BalloonStyle></BalloonStyle>
		</Style>
	</gx:CascadingStyle>
	<gx:CascadingStyle kml:id="wp_style_normal">
		<styleUrl>https://earth.google.com/balloon_components/base/1.0.26.0/card_template.kml#main</styleUrl>
		<Style>
			<IconStyle>
				<scale>1.5</scale>
				<Icon><href>https://earth.google.com/earth/rpc/cc/icon?color=42a5f5&amp;id=2271&amp;scale=4</href></Icon>
				<hotSpot x="64" y="128" xunits="pixels" yunits="insetPixels"/>
			</IconStyle>
			<LabelStyle><scale>1.5</scale></LabelStyle>
			<LineStyle></LineStyle>
			<PolyStyle></PolyStyle>
			<BalloonStyle></BalloonStyle>
		</Style>
	</gx:CascadingStyle>

	<StyleMap id="wp_start_finish">
		<Pair><key>normal</key><styleUrl>#wp_style_normal</styleUrl></Pair>
		<Pair><key>highlight</key><styleUrl>#wp_style_highlight</styleUrl></Pair>
	</StyleMap>
`;
    }

    get_wp_template() {
        return `
        	<Placemark>
        <styleUrl>#WP_TYPE#</styleUrl>

		<name>#WP_NAME#</name>
		<description><![CDATA[<div>
<p>Hmm I'm still thinking about putting WP details in here... Best regards, B21.</p>
</div>]]></description>
        <Point><coordinates>#WP_LONG_LAT_ALT#</coordinates></Point>
	</Placemark>
`;
    }

    get_track_line_template() {
    return `
	<Placemark>
        <styleUrl>#trackLine</styleUrl>
		<LineString><coordinates>#WP1_LONG_LAT_ALT# #WP2_LONG_LAT_ALT#</coordinates></LineString>
	</Placemark>

`;
    }

    get_footer_template() {
        return `
    </Document>
</kml>
`;
    }
} // end B21_FILE_KML class
// ******************************************************************************
// ***********   B21FilePLN class          **************************************
// ******************************************************************************

// Constructs a .PLN file for output

class B21FilePLN {

    constructor(task) {
        const pln = this;
        pln.task = task;
        pln.departure = null;
        pln.departure_updated = false; // will set to true if/when the departure runway has been set in the first waypoint
        pln.destination = null;
    }

    load_pln_str(pln_str) {
        const pln = this;
        console.log("load_pln_str");
        const parser = new DOMParser();
        const dom = parser.parseFromString(pln_str, "application/xml");
        let flight_plan_el = dom.getElementsByTagName("FlightPlan.FlightPlan")[0];
        // ***************
        // Title
        try {
            let title = flight_plan_el.getElementsByTagName("Title")[0].childNodes[0].nodeValue;
            if (title != null) {
                pln.task.title = title;
            }
        } catch (e) {
            console.log("No title in PLN");
        }
        // ***************
        // Descr
        try {
            let description = flight_plan_el.getElementsByTagName("Descr")[0].childNodes[0].nodeValue;
            if (description != null) {
                pln.task.description = description;
            }
        } catch (e) {
            console.log("No description in PLN");
        }
        // ***************************
        // Departure
        pln.departure = {};
        pln.departure.id = dom.getElementsByTagName("DepartureID")[0].childNodes[0].nodeValue;
        try {
            pln.departure.runway_id = dom.getElementsByTagName("DeparturePosition")[0].childNodes[0].nodeValue;
            //console.log("load_pln_str got departure", pln.departure);
        } catch (e) {
            pln.departure.runway_id = null;
            console.log("load_pln_str no DeparturePosition in .PLN file");
        }
        // ***************************
        // Destination
        pln.destination = {};
        pln.destination.id = dom.getElementsByTagName("DestinationID")[0].childNodes[0].nodeValue;
        // ***************************
        // Waypoints
        let dom_waypoints = dom.getElementsByTagName("ATCWaypoint"); //XMLNodeList
        for (let i = 0; i < dom_waypoints.length; i++) {
            pln.add_pln_wp(dom_waypoints[i], i==0 || i==dom_waypoints.length-1);
        }
    }

    // Add a WP from a PLN waypoint entry
    add_pln_wp(dom_wp,airport) {
        const pln = this;
        //pln.index = pln.waypoints.length;
        let wp_index = pln.task.index == null ? 0 : pln.task.index + 1;
        console.log("B21FilePLN.add_pln_wp adding pln wp with index", wp_index);
        let wp;
        try {
            // An exception will be generated if this WP should be ignored, e.g. TIMECRUIS
            wp = new B21_WP(pln.task.planner);
            // Update this WP with the additional PLN info
            pln.update_wp_pln(wp, wp_index, dom_wp, airport);
        } catch (e) {
            console.warn("add_pln_wp skipping:", e);
            return;
        }
        // Update task current index
        pln.task.index = wp_index;
        //pln.waypoints.push(wp);
        //INSERT this wp into waypoints at index
        pln.task.waypoints.splice(wp_index, 0, wp);
        if (wp_index > 0) {
            pln.task.add_line(pln.task.waypoints[wp_index - 1], wp);
        }
        pln.task.decode_wp_name(wp);
    }

    world_position_to_latlngaltm(world_position) {
        const pln = this;
        // <WorldPosition>N40° 40' 38.62",W77° 37' 36.71",+000813.00</WorldPosition>
        console.log(`B21FilePLN.world_position_to_latlngaltm("${world_position}")`);

        let world_pos_elements = world_position.split(","); // lat, lng, alt feet

        let lat_elements = world_pos_elements[0].split(" ");

        let lat = parseInt(lat_elements[0].slice(1)) + parseFloat(lat_elements[1]) / 60 + parseFloat(lat_elements[2]) / 3600;
        lat = lat_elements[0][0] == "N" ? lat : -1 * lat;

        let lng_elements = world_pos_elements[1].split(" ");
        let lng = parseInt(lng_elements[0].slice(1)) + parseFloat(lng_elements[1]) / 60 + parseFloat(lng_elements[2]) / 3600;
        lng = lng_elements[0][0] == "E" ? lng : -1 * lng;

        let alt_m = parseFloat(world_pos_elements[2]) / pln.task.planner.M_TO_FEET;

        return { lat: lat, lng: lng, alt_m: alt_m };
    }

    // Update an existing task WP with data contained in a PLN ATCWaypoint
    update_wp_pln(wp, index, dom_wp, airport) {
        const pln = this;
        let dom_wp_type = dom_wp.getElementsByTagName("ATCWaypointType")[0];
        let isAirport = dom_wp_type.childNodes[0].nodeValue == "Airport";
        let name = dom_wp.getAttribute("id");
        console.log(`B21FilePLN wp[${index}] ${name} isAirport=${isAirport}`);
        let nameEncoded = name.includes("+") || name.includes("|") || name.includes(";");
        //console.log("New WP from dom:", name);
        if (pln.task.planner.settings.soaring_task == 1 &&
            (name == "TIMECRUIS" || name == "TIMECLIMB" || name == "TIMEVERT")) {
            // Skip this waypoint, & tell the caller (Task) via an exception
            throw "SKIP_WAYPOINT";
        }
        //console.log("New WP from dom OK:", name);
        // <WorldPosition>N40° 40' 38.62",W77° 37' 36.71",+000813.00</WorldPosition>
        let world_position = dom_wp.getElementsByTagName("WorldPosition")[0].childNodes[0].nodeValue;
        console.log(`B21FilePLN.update_wp_pln ${name} with WorldPosition "${world_position}"`);

        let latlngaltm = pln.world_position_to_latlngaltm(world_position);

        // Set position
        wp.new_point(index, new L.latLng(latlngaltm.lat, latlngaltm.lng));

        // Set WP alt_m
        wp.alt_m = latlngaltm.alt_m;

        // Set WP name
        wp.name = name;

        let icao_codes = dom_wp.getElementsByTagName("ICAOIdent");
        let dom_wp_runways = dom_wp.getElementsByTagName("RunwayNumberFP");
        let dom_wp_rw_designators = dom_wp.getElementsByTagName("RunwayDesignatorFP");

        // Set WP data_icao, icao
        if (icao_codes.length > 0) {
            if (airport || isAirport) {
                wp.data_icao = icao_codes[0].childNodes[0].nodeValue;
                wp.icao = wp.data_icao;
                console.log("Set icao to " + wp.icao);
                // Get our MSFS airports data for this icao:
                let airport_info = pln.task.planner.airports.lookup(wp.icao);
                console.log("PLN load lookup ICAO", wp.icao, airport_info);
                // Add the 'runways' data to the WP, if available
                if (airport_info != null) {
                    // Add list of available runways
                    if (airport_info['runways'] != null && airport_info["runways"] != "") {
                        let runways_list = airport_info["runways"].split(" ");
                        wp.runways = runways_list;
                    }
                    console.log(`FilePLN.update_wp_pln for ${name} with runways`,wp.runways);
                    // Add actual departure runway if this is the departure airfield, and it's set
                    if (!pln.departure_updated && pln.departure != null && pln.departure.id != null && pln.departure.id == wp.icao) {
                        console.log(`FilePLN.update_wp_pln for ${name} wp.set_runway_str(${pln.departure.runway_id})`);
                        wp.set_runway_str(pln.departure.runway_id);
                        pln.departure_updated = true;
                    }
                }
            } else {
                wp.encoded_icao = icao_codes[0].childNodes[0].nodeValue;
                console.log("This PLN includes encoded ICAO codes for User waypoints");
                if (!nameEncoded) {
                    //pln.task.decode_icao(wp);
                }
            }
        }

        // Set WP runway
        let dom_runway_id = null;
        if (dom_wp_runways.length > 0) {
            let runway_nodes = dom_wp_runways[0].childNodes;
            if (runway_nodes.length > 0) {
                dom_runway_id = dom_wp_runways[0].childNodes[0].nodeValue;
                if (dom_runway_id.length == 1 && dom_runway_id >= "0" && dom_runway_id <= "9") {
                    dom_runway_id = "0"+dom_runway_id;
                }
                // Add L / R / C designator
                if (dom_wp_rw_designators.length > 0) {
                    let des_nodes = dom_wp_rw_designators[0].childNodes;
                    if (des_nodes.length > 0) {
                        let des_str = dom_wp_rw_designators[0].childNodes[0].nodeValue;
                        console.log("Read PLN got des str "+des_str);
                        if (des_str == "LEFT") {
                            dom_runway_id += "L";
                        } else if (des_str = "RIGHT") {
                            dom_runway_id += "R";
                        } else if (des_str = "CENTER") {
                            dom_runway_id += "C";
                        }
                    }
                }
                wp.set_runway_str(dom_runway_id);
            }
        }

    }

    check() {
        const pln = this;
        if (pln.task == null) {
            throw new Error("Cannot create FlightPlan with no task");
        }

        if (pln.task.waypoints.length < 2) {
            throw new Error("Cannot create FlightPlan with less than 2 waypoints");
        }

        if (pln.task.waypoints[0].icao == null || pln.task.waypoints[pln.task.waypoints.length - 1].icao == null) {
            throw new Error("Cannot create Flightplan unless first and last waypoints have ICAO");
        }

        if (pln.task.start_index == 0) {
            throw new Error("Cannot set the departure airport as the task START waypoint. See Help - General Hint (1).");
        }

        if (pln.task.finish_index == pln.task.waypoints.length - 1) {
            throw new Error("Cannot set the destination airport as the task FINISH waypoint. See Help - General Hint (1).");
        }

        if (pln.task.waypoints[0].runway_str == null) {
            alert("Warning - no runway set on departure airport.");
        }

        for (let i=0;i < pln.task.waypoints.length; i++) {
            let wp = pln.task.waypoints[i];
            if (wp.icao != null && wp.icao != "") {
                let wp_name = pln.task.get_encoded_name(wp);
                if (wp_name.indexOf("|") != -1 || wp_name.indexOf("+") != -1) {
                    throw new Error("Your waypoint "+(i+1).toFixed(0)+" has an ICAO code "+wp.icao+". You need to remove that for MSFS to allow soaring details (start, radius, max_alt etc).");
                }
            }
        }
    }

    clean(str) {
        const pln = this;
        return str.replaceAll('"', "");
    }

    get_text() {
        const pln = this;
        pln.check();

        let header_text = pln.get_header_text();
        let wp_text = "";
        for (let i = 0; i < pln.task.waypoints.length; i++) {
            wp_text += pln.get_wp_text(i);
        }
        let footer_text = pln.get_footer_text();

        let text = header_text + wp_text + footer_text;

        return text;
    }

    get_title() {
        const pln = this;
        if (pln.task.title != null) {
            return pln.task.title;
        }

        if (pln.task.name != null) {
            return pln.task.name;
        }
        let first_wp = pln.task.waypoints[0];
        let last_wp = pln.task.waypoints[pln.task.waypoints.length - 1];
        let from = first_wp.icao != null ? first_wp.icao : first_wp.get_name();
        let to = last_wp.icao != null ? last_wp.icao : last_wp.get_name();

        return from + " to " + to;
    }

    get_descr() {
        const pln = this;
        if (pln.task.description != null) {
            return pln.task.description;
        }

        return pln.get_title();
    }

    // Return the XML string for the 'header' part of the PLN file
    get_header_text() {
        const pln = this;
        let header_text = pln.get_header_template();
        //console.log('pln download called get_header_template, header_text=', header_text);
        let first_wp = pln.task.waypoints[0];
        let last_wp = pln.task.waypoints[pln.task.waypoints.length - 1];
        let title = pln.clean(pln.get_title());
        header_text = header_text.replace("#TITLE#", title);
        header_text = header_text.replace("#VERSION_NUMBER#", pln.task.planner.VERSION);
        let descr = pln.clean(pln.get_descr());
        header_text = header_text.replace("#DESCR#", descr);

        header_text = header_text.replace("#DEPARTURE_ID#", pln.clean(first_wp.icao));
        header_text = header_text.replace("#DEPARTURE_LLA#", pln.get_world_position(first_wp));
        if (first_wp.runway_str == null) {
            header_text = header_text.replace("<DeparturePosition>#DEPARTURE_POSITION#</DeparturePosition>", "");
        } else {
            // For runway e.g. "01" MSFS needs departure position "1" (bugfix)
            let dep_pos = first_wp.get_runway_id();
            while (dep_pos.startsWith("0")) {
                dep_pos = dep_pos.substr(1);
            }
            header_text = header_text.replace("#DEPARTURE_POSITION#", dep_pos);
        }
        header_text = header_text.replace("#DEPARTURE_NAME#", pln.clean(first_wp.get_name()));

        header_text = header_text.replace("#DESTINATION_ID#", pln.clean(last_wp.icao));
        header_text = header_text.replace("#DESTINATION_LLA#", pln.get_world_position(last_wp));
        header_text = header_text.replace("#DESTINATION_NAME#", pln.clean(last_wp.get_name()));

        return header_text;
    }

    // Return the XML string for each waypoint (either "User" or "Airport" depending on wp.icao==null)
    get_wp_text(index) {
        const pln = this;
        let wp = pln.task.waypoints[index];
        let encoded_name = pln.clean(pln.task.get_encoded_name(wp));
        let wp_text = "";
        if (wp.icao == null || wp.icao == "") {
            let wp_template = pln.get_wp_user_template();
            wp_text = wp_template.replace("#ATCWAYPOINT_ID#", encoded_name);
            wp_text = wp_text.replace("#WORLD_POSITION#", pln.get_world_position(wp));
            wp_text = wp_text.replace("#ICAO_IDENT#", pln.task.get_encoded_icao(wp));
        } else {
            let wp_template = pln.get_wp_airport_template();
            //console.log("got wp airport template "+wp_template);
            wp_text = wp_template.replace("#ATCWAYPOINT_ID#", encoded_name);

            wp_text = wp_text.replace("#ICAO_IDENT#", pln.clean(wp.icao));

            wp_text = wp_text.replace("#WORLD_POSITION#", pln.get_world_position(wp));

            if (wp.runway_str == null || index > 0) {
                wp_text = wp_text.replace("#RUNWAY_NUMBER_FP#", "");
                // #RUNWAY_DESIGNATOR_FP#
                console.log("removing #RUNWAY_DESIGNATOR_FP# from WP +"+index);
                wp_text = wp_text.replace("#RUNWAY_DESIGNATOR_FP#", "");
            } else {
                let rw_no_zero = wp.get_runway_id();
                let rw_des_str = ""; // will be runway designator L, R, C

                // Strip any zeroes off front of runway number
                while (rw_no_zero.startsWith("0")) {
                    rw_no_zero = rw_no_zero.substr(1);
                }
                if (rw_no_zero.length > 1) {
                    let rw_des = rw_no_zero.slice(-1); // e.g. the "L" of "09L"
                    console.log("Got rw_des="+rw_des);
                    if (rw_des == "L") {
                        rw_des_str = "<RunwayDesignatorFP>LEFT</RunwayDesignatorFP>";
                    } else if (rw_des == "R") {
                        rw_des_str = "<RunwayDesignatorFP>RIGHT</RunwayDesignatorFP>";
                    } else if (rw_des == "C") {
                        rw_des_str = "<RunwayDesignatorFP>CENTER</RunwayDesignatorFP>";
                    }
                }
                console.log("Writing first WP to PLN, rw_des_str="+rw_des_str);
                if (rw_des_str != "") {
                    rw_no_zero = rw_no_zero.slice(0,-1); // strip off the "L" "R" or "C"
                }
                let runway_number_fp_str = "<RunwayNumberFP>"+rw_no_zero+"</RunwayNumberFP>";
                //console.log("replacing #RUNWAY_NUMBER_FP# ", runway_number_fp_str, wp_text);
                wp_text = wp_text.replace("#RUNWAY_NUMBER_FP#", runway_number_fp_str);
                // #RUNWAY_DESIGNATOR_FP#
                //console.log("replacing #RUNWAY_DESIGNATOR_FP# ",rw_des_str, wp_text);
                wp_text = wp_text.replace("#RUNWAY_DESIGNATOR_FP#", rw_des_str);
            }

        }
        //console.log("get_wp_text() returning",wp_text);
        return wp_text;
    }

    // Return XML string for the end of the PLN file
    get_footer_text() {
        const pln = this;
        let footer_text = pln.get_footer_template();
        return footer_text;
    }

    deg_to_dms(coordinate) {
        const pln = this;
        let absolute = Math.abs(coordinate);
        let degrees = Math.floor(absolute);
        let minutesNotTruncated = (absolute - degrees) * 60;
        let minutes = Math.floor(minutesNotTruncated);
        let seconds = Math.floor((minutesNotTruncated - minutes) * 60000) / 1000;
        if (seconds >= 59.995) {
            seconds = 0;
            minutes += 1;
            if (minutes >= 60) {
                minutes = 0;
                degrees += 1
            }
        }
        let degrees_str = degrees.toFixed(0);
        let minutes_str = minutes.toFixed(0);
        let seconds_str = seconds.toFixed(2);
        return { deg: degrees_str, min: minutes_str, sec: seconds_str };
    }

    get_world_position(wp) {
        const pln = this;
        let position = wp.position;
        let alt_m = wp.alt_m;

        // e.g. `N51° 33' 50.34",E0° 21' 17.76",+000019.18`;

        let NS = position.lat >= 0 ? "N" : "S";
        let lat_dms = this.deg_to_dms(position.lat);
        let world_pos_lat = `${NS}${lat_dms.deg}° ${lat_dms.min}' ${lat_dms.sec}"`;

        let EW = position.lng >= 0 ? "E" : "W";
        let lng_dms = this.deg_to_dms(position.lng);
        let world_pos_lng = `${EW}${lng_dms.deg}° ${lng_dms.min}' ${lng_dms.sec}"`;

        let alt_feet = alt_m * this.task.planner.M_TO_FEET;
        let alt_str = (alt_feet > 0 ? "+" : "-") + ("000000" + Math.abs(alt_feet).toFixed(2)).slice(-9);

        let world_position = `${world_pos_lat},${world_pos_lng},${alt_str}`;

        return world_position;
    }

    get_header_template() {
        return `<?xml version="1.0" encoding="UTF-8"?>

<SimBase.Document Type="AceXML" version="1,0">
    <Descr>AceXML Document</Descr>
    <!-- Created in B21 Task Planner #VERSION_NUMBER# -->
    <FlightPlan.FlightPlan>
        <Title>#TITLE#</Title>
        <FPType>VFR</FPType>
        <CruisingAlt>1500.000</CruisingAlt>
        <DepartureID>#DEPARTURE_ID#</DepartureID>
        <DepartureLLA>#DEPARTURE_LLA#</DepartureLLA>
        <DestinationID>#DESTINATION_ID#</DestinationID>
        <DestinationLLA>#DESTINATION_LLA#</DestinationLLA>
        <Descr>#DESCR#</Descr>
        <DeparturePosition>#DEPARTURE_POSITION#</DeparturePosition>
        <DepartureName>#DEPARTURE_NAME#</DepartureName>
        <DestinationName>#DESTINATION_NAME#</DestinationName>
        <AppVersion>
            <AppVersionMajor>11</AppVersionMajor>
            <AppVersionBuild>282174</AppVersionBuild>
        </AppVersion>
`;
    }

    get_wp_airport_template() {
        return `
        <ATCWaypoint id="#ATCWAYPOINT_ID#">
            <ATCWaypointType>User</ATCWaypointType>
            <WorldPosition>#WORLD_POSITION#</WorldPosition>
            <SpeedMaxFP>-1</SpeedMaxFP>
            #RUNWAY_NUMBER_FP#
            #RUNWAY_DESIGNATOR_FP#
            <ICAO>
                <ICAOIdent>#ICAO_IDENT#</ICAOIdent>
            </ICAO>
        </ATCWaypoint>
`;
    }

    get_wp_user_template() {
        return `
        <ATCWaypoint id="#ATCWAYPOINT_ID#">
            <ATCWaypointType>User</ATCWaypointType>
            <WorldPosition>#WORLD_POSITION#</WorldPosition>
            <SpeedMaxFP>-1</SpeedMaxFP>
            <ICAO>
                <ICAOIdent>#ICAO_IDENT#</ICAOIdent>
            </ICAO>
        </ATCWaypoint>
`;
    }

    get_wp_intersection_template() {
        return `
        <ATCWaypoint id="#ATCWAYPOINT_ID#">
            <ATCWaypointType>Intersection</ATCWaypointType>
            <WorldPosition>#WORLD_POSITION#</WorldPosition>
            <ICAO>
                <ICAOIdent>#ICAO_IDENT#</ICAOIdent>
            </ICAO>
        </ATCWaypoint>
`;
    }

    get_footer_template() {
        return `
    </FlightPlan.FlightPlan>
</SimBase.Document>
`;
    }
} // end FlightPlan class

"use strict"

// B21 geo utility functions e.g. distance between two points

// A point is {lat: lng:} assumed WGS84
// Distances are in meters

class Geo {

    static EARTH_RADIUS = 6366710.0; // Earth mean radius in meters (accurate at mid-latitudes)

    static debug() { return 123; }

    // Earth radius estimate for given latitude https://rechneronline.de/earth-radius/
    // R =  sqrt([ (r1² * cos(B))² + (r2² * sin(B))² ] / [ (r1 * cos(B))² + (r2 * sin(B))² ])
    static get_earth_radius_m(lat) {
        let R1 = 6378.137; // radius at equator KM
        let R2 = 6356.752; // radus at poles KM
        let B = Geo.deg2rad(lat);
        let sin_b = Math.sin(B);
        let cos_b = Math.cos(B);
        let term1 =  Math.pow(Math.pow(R1,2) * cos_b,2)+Math.pow(Math.pow(R2,2)*sin_b,2);
        let term2 = Math.pow(R1*cos_b,2)+Math.pow(R2*sin_b,2);
        return Math.sqrt(term1/term2) * 1000;
    }

    // convert distance meters on earths surface to radians subtended at the centre
    static m2rad(distance) {
        return distance / Geo.EARTH_RADIUS;
    }

    /* *
    * https://stackoverflow.com/questions/12800045/distance-using-wgs84-ellipsoid
    *
    * Calculates geodetic distance between two points specified by latitude/longitude using
    * Vincenty inverse formula for ellipsoids
    *
    * @param   {Number} lat1, lon1: first point in decimal degrees
    * @param   {Number} lat2, lon2: second point in decimal degrees
    * @returns (Number} distance in metres between points
    * */
    static get_distance_m(p1, p2) {
        let lat1 = p1.lat;
        let lon1 = p1.lng;
        let lat2 = p2.lat;
        let lon2 = p2.lng;
        let a = 6378000, //6378137,           // radius (m) at equator
            b = 6356800, //6356752.314245,    // radius (m) at poles
            f = 1 / 298.257223563; // WGS-84 ellipsoid params
        let L = Geo.deg2rad(lon2 - lon1);
        let U1 = Math.atan((1 - f) * Math.tan(Geo.deg2rad(lat1)));
        let U2 = Math.atan((1 - f) * Math.tan(Geo.deg2rad(lat2)));
        let sinU1 = Math.sin(U1),
            cosU1 = Math.cos(U1);
        let sinU2 = Math.sin(U2),
            cosU2 = Math.cos(U2);

        let lambda = L,
            lambdaP,
            iterLimit = 100,
            cosSqAlpha,
            sinSigma,
            cos2SigmaM,
            cosSigma,
            sigma;
        do {
            let sinLambda = Math.sin(lambda),
                cosLambda = Math.cos(lambda);
            sinSigma = Math.sqrt((cosU2 * sinLambda) * (cosU2 * sinLambda) + (cosU1 * sinU2 - sinU1 * cosU2 * cosLambda) * (cosU1 * sinU2 - sinU1 * cosU2 * cosLambda));
            if (sinSigma == 0) return 0; // co-incident points
            cosSigma = sinU1 * sinU2 + cosU1 * cosU2 * cosLambda;
            sigma = Math.atan2(sinSigma, cosSigma);
            let sinAlpha = cosU1 * cosU2 * sinLambda / sinSigma;
            cosSqAlpha = 1 - sinAlpha * sinAlpha;
            cos2SigmaM = cosSigma - 2 * sinU1 * sinU2 / cosSqAlpha;
            if (isNaN(cos2SigmaM)) cos2SigmaM = 0; // equatorial line: cosSqAlpha=0 (§6)
            let C = f / 16 * cosSqAlpha * (4 + f * (4 - 3 * cosSqAlpha));
            lambdaP = lambda;
            lambda = L + (1 - C) * f * sinAlpha * (sigma + C * sinSigma * (cos2SigmaM + C * cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM)));
        } while (Math.abs(lambda - lambdaP) > 1e-12 && --iterLimit > 0);

        if (iterLimit == 0) return NaN // formula failed to converge
        let uSq = cosSqAlpha * (a * a - b * b) / (b * b);
        let A = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq)));
        let B = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq)));
        let deltaSigma = B * sinSigma * (cos2SigmaM + B / 4 * (cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM) - B / 6 * cos2SigmaM * (-3 + 4 * sinSigma * sinSigma) * (-3 + 4 * cos2SigmaM * cos2SigmaM)));
        let s = b * A * (sigma - deltaSigma);

        return s;
    }

    // Return distance in m between positions p1 and p2.
    // lat/lngs in e.g. p1.lat etc
    static get_distance_m2(p1, p2) {
        var dLat = Geo.deg2rad(p2.lat - p1.lat);
        var dLong = Geo.deg2rad(p2.lng - p1.lng);
        var a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                        Math.cos(Geo.deg2rad(p1.lat)) * Math.cos(Geo.deg2rad(p2.lat)) *
                            Math.sin(dLong / 2) * Math.sin(dLong / 2);
        var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        var d = Geo.get_earth_radius_m((p1.lat+p2.lat)/2) * c;
        return d; // returns the distance in meter
    }

    // Bearing in degrees from point p1 -> p2 (each as {lat: , lng: })
    static get_bearing_deg(p1, p2)
    {
        // Convert p1,p2 degrees -> radians
        var a = { lat: Geo.deg2rad(p1.lat), lng: Geo.deg2rad(p1.lng) };
        var b = { lat: Geo.deg2rad(p2.lat), lng: Geo.deg2rad(p2.lng) };
        var y = Math.sin(b.lng-a.lng) * Math.cos(b.lat);
        var x = Math.cos(a.lat)*Math.sin(b.lat) -
                    Math.sin(a.lat)*Math.cos(b.lat)*Math.cos(b.lng-a.lng);
        return (Math.atan2(y, x) * 180 / Math.PI + 360) % 360; // Converts back to degrees
    }

    // distance_and_bearing(...) returns a new lat/lng a distance and bearing from lat1,lon1.
    // lat, lngs and bearings in degrees, distance in meters
    static get_distance_and_bearing(p, distance, bearing) {
    	const rlat1 = Geo.deg2rad(p.lat);
    	const rlong1 = Geo.deg2rad(p.lng);
    	const rdistance = Geo.m2rad(distance);
    	const rbearing = Geo.deg2rad(bearing);
    	const rlat2 = Math.asin(Math.sin(rlat1)*Math.cos(rdistance)+Math.cos(rlat1)*Math.sin(rdistance)*Math.cos(rbearing));
        let rlong2;
    	if (Math.cos(rlat2)==0) {
            rlong2 = rlong1;      // endpoint a pole
    	}
    	else {
    		rlong2 = ((rlong1+Math.asin(Math.sin(rbearing)*Math.sin(rdistance)/Math.cos(rlat2))+Math.PI) % (2*Math.PI))-Math.PI;
    	}
    	return { "lat": Geo.rad2deg(rlat2), "lng": Geo.rad2deg(rlong2) };
    }

    // Return TRUE if wp_bearing is within +/- sector_size/2 degrees of leg_bearing
    // I.e. if aircraft has waypoint at wp_bearing_deg
    // and next leg from waypoint is in direction leg_bearing
    // and the sector opposite the leg to next waypoint is sector_size degrees wide.
    // E.g. sector_size could be 180 for a start line, or 90 for a turnpoint.
    static in_sector(leg_bearing, wp_bearing, sector_size) {
        let sector_deg = leg_bearing - sector_size / 2;
        if (sector_deg < 0) {
            sector_deg += 360;
        }
        // Delta is the angle +/- 180
        let delta = sector_deg - wp_bearing;
        if (delta < -180) {
            delta += 360;
        } else if (delta > 180) {
            delta -= 360;
        }

        return (delta < 0 && delta > -sector_size);
    }

    // Given an inbound bearing, and an outbound bearing, returns the bisector pointing AWAY from the WP
    static get_bisector_deg(track_in, track_out) {
         let bisector = (track_in + track_out) / 2 + 90;
         let bisector_offset = (bisector > track_in) ? bisector - track_in : track_in - bisector;
         if (bisector_offset > 90 && bisector_offset < 270) {
              bisector += 180;
          }
         if (bisector >= 360) {
             bisector -= 360;
         }
         return bisector;
    }

    // Given two boxes defined by min/max lat/lng values, return true if they overlap
    static box_overlap(box, map_box) {
        if (map_box.min_lat > box.max_lat) {
            return false;
        }
        if (map_box.max_lat < box.min_lat) {
            return false;
        }
        if (map_box.min_lng > box.max_lng) {
            return false;
        }
        if (map_box.max_lng < box.min_lng) {
            return false;
        }
        return true;
    }

    // Return point which is on line p1 -> p2,
    // e.g. if progress = 0.5 the p will be half way between p1 & p2
    static interp_p1_p2(progress, p1, p2) {
        return { lat: p1.lat + (p2.lat-p1.lat)*progress, lng: p1.lng + (p2.lng - p1.lng)*progress };
    }

    // Perpendicular distance of point P {lat:, lng:} to a line [A,B]
    // where A,B are points
    static get_distance_to_line_m(P, line)
    {

        // Prepare some values for the calculation
        let R = Geo.get_earth_radius_m(P.lat);

        let A = line[0];

        let B = line[1];

        let bearing_AP = Geo.get_bearing_deg(A, P);

        let bearing_AB = Geo.get_bearing_deg(A, B);

        let bearing_BP = Geo.get_bearing_deg(B, P);

        // if point P is 'behind' A wrt to B, then return distance from A
        let angle_BAP = (bearing_AP - bearing_AB + 360) % 360;

        //console.log('angle_BAP',angle_BAP);

        if (angle_BAP > 90 && angle_BAP < 270)
        {
            //console.log(`Geo.get_distance_to_line_m ${JSON.stringify(P)} nearest to ${JSON.stringify(A)}`);
            return Geo.get_distance_m(A,P);
        }

        // if point P is 'behind' B wrt to A, then return distance from B
        let angle_ABP = (180 - bearing_BP + bearing_AB + 360) % 360;

        //console.log('angle_ABP',angle_ABP);

        if (angle_ABP > 90 && angle_ABP < 270)
        {
            //console.log(`Geo.get_distance_to_line_m ${JSON.stringify(P)} nearest to ${JSON.stringify(B)}`);
            return Geo.get_distance_m(B,P);
        }

        // ok, so the point P is somewhere between A and B, so return perpendicular distance

        let distance_AB = Geo.get_distance_m(A, P);

        let d = Math.abs(Math.asin(Math.sin(distance_AB/R)*Math.sin(Geo.deg2rad(bearing_AP - bearing_AB))) * R);

        //console.log(`Geo.get_distance_to_line_m ${JSON.stringify(P)} ${d.toFixed(1)}m`);

        return d;
    }


//*********************************************************************************************
//*************** CONVERSION FUNCTIONS, E.G. meters to nautical miles *************************
//*********************************************************************************************

    // degrees to radians
    static deg2rad(x) {
        return x * Math.PI / 180;
    }

    // radians to degrees
    static rad2deg(x) {
        return x * (180.0 / Math.PI);
    }

    // meters to nautical miles
    static nm(x) {
            return x * 0.000539956803;
    }

    // meters to statute miles
    static miles(x) {
            return x * 0.000621371;
    }

}

// This global var will contain an instance of B21TaskPlanner class
var b21_task_planner;

function b21_task_planner_loaded() {
    console.log("b21_task_planner_loaded() building index.html content.");
    // This HTML for main page loaded from JS so it can be loaded from xp-soaring for NB21 Logger
    let page_content = `
    <div class="header">
        <div class="title">
            <!-- NOTE VERSION NUMBER HERE -->
            <div class="title_text">B21 Task Planner <span id="b21_task_planner_version">X.X.X</span></div>
            <div class="title_task_option">Soaring task: <input id="soaring_task_checkbox" type="checkbox" onclick="b21_task_planner.click_soaring_task(this)" checked/></div>
        </div>
    </div>

    <div id="buttons">
        <!--onclick="b21_task_planner.download_pln()"-->
        <button id="task_download_button"
            title="Download Task file to your Downloads folder">Download FlightPlan</button>
        <div id="task_download_menu"></div>
        <button onclick="b21_task_planner.reset_all_button()"
            title="Clear the current task and tracklogs">Reset All</button>
        <button onclick="b21_task_planner.update_elevations()"
            title="Insert the correct elevation for each user waypoint, airports will be unchanged">Update elevations</button>
        <button onclick="b21_task_planner.zoom_to_task()"
            title="Reset the map to show the whole task">Zoom to task</button>
        <a  id="skyvector_button"
            href="https://skyvector.com/?ll=54.65188861732224,-2.073669422461872&chart=301&zoom=1"
            target="_skyvector">
            <button
                title="Will open SkyVector aligned to current map here"
                type="submit">SkyVector
            </button>
        </a>
        <button id="multiplayer_button">
            <input id="multiplayer_enable_checkbox" type="checkbox" title="Show multiplayer aircraft on map."></input>
            <input id="multiplayer_center_checkbox" type="checkbox" title="Center your aircraft."></input>
            <input type="checkbox" title="Show names" id="icon_data_name_checkbox" onclick="b21_task_planner.icon_data_name_click()" />
            <input type="checkbox" title="Show altitude" id="icon_data_altitude_checkbox" onclick="b21_task_planner.icon_data_altitude_click()" />
            <input type="checkbox" title="Show speed" id="icon_data_speed_checkbox" onclick="b21_task_planner.icon_data_speed_click()" />
            <div id="multiplayer_local">|
                <input id="multiplayer_local_checkbox" type="checkbox" title="Connect to NB21 Logger and show your aircraft on map." checked></input>
            </div>
            Players
        </button>
        <button onclick="b21_task_planner.toggle_settings()"
            title="Choose units for distance, elevation etc.">Settings</button>
        <div id="search">
            <input id="search_input"
                title="Search airport names and identifiers, click any result to show on map"
                type="text" width="10" placeholder="Search Airports/Waypoints" onkeyup="b21_task_planner.search()"/>
            <div id="search_results">
            </div>
        </div>
        <form id="help_button" style="display: inline;" action="https://xp-soaring.github.io/tasks/b21_task_planner/help/help.html" target="_blank">
            <button type="submit"
                title="Opens the help page in another tab in your browser">Help</button>
        </form>
    </div>
    <div id="panes">
        <div id="left_pane">
            <div id="left_top_area">
                <div id="drop_zone">
                    <button id="click_to_edit" onclick="b21_task_planner.click_to_edit()">Click to edit this flightplan</button>
                    DROP FILES HERE<br/>
                    Task: (.PLN .TSK)<br/>
                    Tracklogs: (.GPX .IGC)<br/>
                    Weather: (.WPR) WPs: (.CUP)<br/>
                    Or: <input type="file" id="drop_zone_choose_input" multiple="multiple"/> <button id="drop_zone_choose_button">Choose file(s)</button>
                </div>
                <div id="left_pane_hide">
                    <button id="left_pane_hide_button" href="#" onclick="b21_task_planner.left_pane_hide_click()"
                        title="Hide this display pane.">h<br/>i<br/>d<br/>e</button>
                    <div id="wind_rose_hide">
                        <input id="wind_rose_hide_check" type="checkbox" checked onclick="b21_task_planner.wind_hide_clicked()">Wind</input>
                        <img id="wind_rose_position" src="https://xp-soaring.github.io/tasks/b21_task_planner/images/compass_rose_position.png" onclick="b21_task_planner.wind_position_clicked()"/>
                    </div>
                </div>
            </div>
            <!-- TABS content -->
            <div id="left_pane_tabs">
                <div id="tab_task" class="tab_active"><a href="#" onclick="b21_task_planner.tab_task_click()">Task</a></div>
                <div id="tab_weather" class="tab_inactive"><a href="#" onclick="b21_task_planner.tab_weather_click()">Weather</a></div>
                <div id="tab_tracklogs" class="tab_inactive">
                    <input id="tracklogs_select_all" type="checkbox" checked="checked" onclick="b21_task_planner.tracklogs_select_all_clicked()"/>
                    <a href="#" onclick="b21_task_planner.tab_tracklogs_click()">Tracklogs</a>
                </div>
                <div id="rescore_button">
                    <button onclick="b21_task_planner.rescore_click()" title="Recalc/Show score table">Scores</button>
                </div>
            </div>
            <div id="task_info">
                <div id="task_info_header" style="display: block;"></div>
                <div id="task_info_content"></div>
            </div>
            <div id="weather_info">
            </div>
            <div id="tracklogs">TRACKLOGS ENTRIES GO HERE</div>
        </div> <!-- end left_pane -->
        <div id="left_pane_show">
            <button id="left_pane_show_button" href="#" onclick="b21_task_planner.left_pane_show_click()"
                title="Show this display pane.">s<br/>h<br/>o<br/>w</button>
        </div>
        <div id="right_pane">
            <div id="wind_rose">
                <div id="compass_rose"></div>
                <div id="wind_arrow_1">
                    <div id="wind_arrow_1_text"></div>
                </div>
                <div id="wind_speed_1">
                    <div id="wind_speed_1_value"></div>
                    <div id="wind_speed_units"></div>
                </div>
            </div>
            <div id="map"></div>
            <div id="msfs_wind_div" width="64" height="64">
                <svg width="64" height="64" xmlns="http://www.w3.org/2000/svg">
                    <g id="msfs_wind_arrow" style="transform-origin: center; transform: rotate(20deg)">
                        <g>
                            <path d="M12 12 l 10 40 l 10 -40  l -10 8 z" stroke="#000" fill="#ff709c"/>
                        </g>
                    </g>
                </svg>
            </div>
            <div id="tracklog_fixup">
                <div id="tracklog_fixup_text">Click a tracklog point to accept for waypoint</div>
                <button id="tracklog_fixup_button">CANCEL</button>
            </div>
            <div id="replay">
                <div id="skip_pause" title="Ignore 'pauses' in tracklogs (note this may take a little while).">
                    <div id="skip_pause_check_text">
                        <input type="checkbox" id="skip_pause_checkbox" onclick="b21_task_planner.skip_pause_click()" checked/>
                        <div>Skip pause</div>
                    </div>
                    <div id="skip_pause_progress"></div>
                </div>
                <div id="replay_sync" title="Offset tracklog times to a common start time. Tracklogs must have successful task start.">
                    <input type="checkbox" id="replay_sync_checkbox" onclick="b21_task_planner.replay_sync_click()"/>
                    Sync&nbsp;starts
                </div>
                <button id="replay_back" class="replay_button"  onclick="b21_task_planner.replay_back(300)"
                    title="Skip back 5 min">||&#9668;5</button>
                <button id="replay_reset" class="replay_button"  onclick="b21_task_planner.replay_restart()"
                    title="Reset replay to start of tracklog">&#9632</button>
                <button id="replay_pause" class="replay_button" onclick="b21_task_planner.replay_pause()"
                    title="Pause replay">||</button>
                <button id="replay_play" class="replay_button" onclick="b21_task_planner.replay_play()"
                    title="Play all selected tracklogs">&#9654;</button>
                <div id="replay_speed">
                    <button id="replay_slower" class="replay_button" onclick="b21_task_planner.replay_slower()"
                        title="Slow down replay speed">-</button>
                    <div id="replay_speed_value">x1</div>
                    <button id="replay_faster" class="replay_button" onclick="b21_task_planner.replay_faster()"
                        title="Speed up replay speed">+</button>
                </div>
                <div id="replay_time">1 Jan 1970 00:00</div>
                <button id="replay_hide_tracks" class="replay_button" href="#" onclick="b21_task_planner.replay_hide_tracks()"
                    title="Hide the tracks display on map">hide map tracks</button>
                <button id="replay_hide_chart" class="replay_button" href="#" onclick="b21_task_planner.replay_hide_chart()"
                    title="Hide the chart display">hide chart</button>
            </div>
            <div id="charts"></div>
            <div id="tracklog_info">
                <div id="tracklog_info_header">
                    <div id="tracklog_info_name"></div>
                    <div id="tracklog_info_select">
                        <button id="tracklog_info_draw_aat_task" onclick="b21_task_planner.draw_aat_for_current_tracklog()" style="display: none;">draw&nbsp;AAT&nbsp;route</button>
                        <button id="tracklog_info_load_task" onclick="b21_task_planner.load_task_from_current_tracklog()" style="display: none;">load&nbsp;task</button>
                        <button onclick="b21_task_planner.close_tracklog_info()">close</button>
                    </div>
                </div>
                <div id="tracklog_info_alerts"></div>
                <div id="tracklog_info_body">
                    <div id="tracklog_info_details"></div>
                    <div id="tracklog_info_timeline"></div>
                </div>
                <div id="tracklog_info_footer"></div>
                <div id="tracklog_info_chart_area">
                    <div id="tracklog_info_chart_header"></div>
                    <div id="tracklog_info_chart"></div>
                    <div id="tracklog_info_chart_footer"></div>
                </div>
            </div>
        </div>
        <div id="settings">
        </div>
    </div> <!-- end panes -->
    `;
    document.body.innerHTML = page_content;
    b21_task_planner = new B21_TaskPlanner();
    b21_task_planner.init();
    document.getElementById("b21_task_planner_version").innerText = b21_task_planner.VERSION;
}
"use strict"

// ******************************************************************************
// ***********   B21_Local_Waypoints class           ****************************
// ******************************************************************************

/* Interface;
        constructor(tracklog)
        load_cup(file_str, filename)
        lookup(id)
        search(str)
        file_type                   // "cup"
        waypoints                   // dictionary id -> {id, name, lat, lng, alt_m, desc, type = "user_waypoint", source = "local_waypoints"}
*/

// CUP format Holds custom waypoints
// name,code,country,lat,lon,elev,style,rwdir,rwlen,rwwidth,freq,desc
/* E.g. {
            code: "SCHLDMNG"
            country: "A"
            desc: ""
            elev: "749M"
            freq: ""
            lat: "4724.100N"
            lon: "01342.000E"
            name: "Schladming"
            rwdir: ""
            rwlen: ""
            style: "3"
        }
*/


class B21_Local_Waypoints {

    constructor(planner, local_waypoints_key) {
        this.planner = planner;
        this.local_waypoints_key = local_waypoints_key; // the dict key in b21_task_planner.local_waypoints for these waypoints
        this.file_type = null;
        this.filename = null;
        this.active = true;     // As in user settings, controls whether these waypoints should be displayed
        this.waypoints = {};    // { id: { id, name, lat, lng, alt_m, desc}, ...}
        this.box = null;        // { min_lat, min_lng, max_lat, max_lng }
        this.markers = null;    // holds map waypoint markers
        this.search_location_id = null; // waypoint selected from search
        this.map_layer_group = L.layerGroup();
    }

    waypoints_loaded() {
        console.log(this.local_waypoints_key,"waypoints_loaded()");
        this.add_to_map(this.planner.map);
        if (this.active) {
            this.draw();
        }
    }

    lookup(id) {
        return this.waypoints[id];
    }

    // Search all the waypoints, returning a list that contain the given string in the id or name
    search(str) {
        const RESULTS_MAX = 10;
        let search_str = str.toLowerCase();
        let results_id = [];
        let results_name = [];
        let search_names = true;
        for (var key in this.waypoints) {
            let wp = this.waypoints[key];

            if (wp.id != null && wp.id.toLowerCase().includes(search_str)) {
                wp.local_waypoints_key = this.local_waypoints_key;
                results_id.push(wp);
                if (results_id.length >= RESULTS_MAX) {
                    break;
                }
            } else if (search_names && wp.name != null && wp.name.toLowerCase().includes(search_str)) {
                wp.local_waypoints_key = this.local_waypoints_key;
                results_name.push(wp);
                if (results_name.length >= RESULTS_MAX) {
                    search_names = false;
                }
            }
        }
        // We will return the 'id' matches FIRST, followed by the 'name' matches, limited to RESULTS_MAX
        return results_id.concat(results_name).slice(0,RESULTS_MAX);
    }

    set_current_searched(id) {
        this.search_location_id = id;
    }

    draw() {
        let zoom = this.planner.map.getZoom();
        if (zoom < 10) {
            console.log(this.local_waypoints_key, "draw() Too zoomed out to display user waypoints");
            this.planner.map.removeLayer(this.map_layer_group);
            return;
        }
        let map_bounds = this.planner.map.getBounds();
        let map_box = {
            "min_lat": map_bounds.getSouth(),
            "min_lng": map_bounds.getWest(),
            "max_lat": map_bounds.getNorth(),
            "max_lng": map_bounds.getEast()
        }
        console.log(this.local_waypoints_key, "draw() waypoints", map_box);
        //drawing box of local_waypoints
        //L.rectangle([
        //    [this.box.min_lat, this.box.min_lng],
        //    [this.box.max_lat, this.box.max_lng]
        //]).addTo(map);

        if (Geo.box_overlap(this.box, map_box)) {
            if (! this.planner.map.hasLayer(this.map_layer_group)) {
                console.log(this.local_waypoints_key, "draw() local_waypoints adding layer to map");
                this.planner.map.addLayer(this.map_layer_group);
            } else {
                console.log(this.local_waypoints_key, "draw() no need for addLayer as the layer already exists");
            }
        } else {
            console.log(this.local_waypoints_key, "no box overlap so draw() local_waypoints removeLayer");
            this.hide();
        }
        // If a waypoint search result is selected, open popup for that waypoint
        if (this.search_location_id != null) {
            let marker = this.markers[this.search_location_id];
            marker.openPopup();
            this.search_location_id = null;
        }
    }

    hide() {
        this.planner.map.removeLayer(this.map_layer_group);
    }

    add_to_map() {
        this.map_layer_group.clearLayers();

        this.markers = {};

        console.log("add_to_map",this.local_waypoints_key);

        for (var key in this.waypoints) {
            let wp = this.waypoints[key];
            //console.log("waypoints draw",wp);

            let position = new L.latLng(wp["lat"], wp["lng"]);
            let id = wp["id"];
            let type = wp["type"];
            let name = wp["name"].replaceAll('"', ""); // Remove double quotes if original name includes those.
            let desc = wp["desc"].replaceAll('"', ""); // Remove double quotes if original name includes those.
            let alt_m = wp["alt_m"];
            let circle_radius = 4; //3 * (zoom - 7);
            let marker = L.circleMarker(position, {
                renderer: this.planner.canvas_renderer,
                color: "#ff4d4d",
                radius: circle_radius
            });
            marker.addTo(this.map_layer_group);

            // add popup
            let popup_content = name + "<br/>" + type + "<br/>" + id + (desc != "" ? "<br/>" + desc : "");
            let popup = L.popup({
                autoPan: false
            }).setContent(popup_content);
            marker.bindPopup(popup);

            marker.on('mouseover', function(event) {
                marker.openPopup();
            });
            marker.on('mouseout', function(event) {
                marker.closePopup();
            });

            // on click : add this waypoint to task
            marker.on('click', (e) => {
                console.log("User click:", id, name);
                this.planner.task.add_new_poi(position, type, {
                    //"ident": id,
                    "name": name,
                    "alt_m": alt_m
                });
            });
            this.markers[id] = marker;
        }
    }

    dumps() {
        // Set/Store the local_waypoints object
        let store_obj = {
            local_waypoints_key: this.local_waypoints_key,
            box: this.box,
            file_type: this.file_type,
            filename: this.filename,
            waypoints: this.waypoints
        };

        return JSON.stringify(store_obj);
    }

    loads(obj_str) {
        let store_obj = JSON.parse(obj_str);
        this.box = store_obj.box;
        this.file_type = store_obj.file_type;
        this.filename = store_obj.filename;
        this.waypoints = store_obj.waypoints;
        //this.waypoints_loaded();
    }

    // ******************************************************************************
    // ************ CUP file handling        ****************************************
    // ******************************************************************************

    // load_cup(file_str, filename) reads CUP waypoint records from the file_str
    load_cup(file_str, filename) {
        try {
            this.file_str = file_str;
            this.filename = filename;

            // Read the first line of the file, and split into column keys
            let line_term_r = file_str.indexOf('\r');
            let line_term_n = file_str.indexOf('\n');
            let line_term = line_term_r == -1 ? line_term_n : line_term_r;

            let keys = file_str.substring(0, line_term).split(',');
            this.keys = keys;

            if (this.bad_header(keys)) {
                // CUP csv column names were not as expected, so replacing:
                const header = "name,code,country,lat,lon,elev,style,rwdir,rwlen,freq,desc\n";
                file_str = header + file_str.substring(file_str.indexOf("\n") + 1);
            }

            // Find where the "---Related Tasks---" section is in the CUP file and remove it.
            let tasks_index = file_str.indexOf("---Related");
            if (tasks_index > 0) {
                file_str = file_str.slice(0,tasks_index);
            }

            this.cup_waypoints = d3.csvParse(file_str);

            this.parse_cup(this.cup_waypoints);

            this.file_type = "cup";

            this.waypoints_loaded();

            return true;
        } catch (e) {
            console.log("CUP file load failed with exception", e);
        }
        return false;
    }

    // Convert CUP format waypoints to our common standard.
    parse_cup(cup_waypoints) {
        this.waypoints = {};
        // bounds for map_box
        this.box = {};
        this.box["min_lat"] = 90;
        this.box["min_lng"] = 180;
        this.box["max_lat"] = -90;
        this.box["max_lng"] = -180;

        for (let i=0; i<cup_waypoints.length; i++) {
            let cup_wp = cup_waypoints[i];

            // Basic validity check:
            if (cup_wp["lon"] == '') {
                console.log("parse_cup skipping", cup_wp.name);
                continue;
            }
            let wp = {};

            // id
            wp.id = cup_wp.code != "" ? cup_wp.code : cup_wp.name;

            // name
            wp.name = cup_wp.name;

            // lat
            wp.lat = this.cup_latlng(cup_wp.lat);

            // lng
            wp.lng = this.cup_latlng(cup_wp.lon);

            // Update box lat/lng bounds
            if (wp.lat < this.box.min_lat) {
                this.box.min_lat = wp.lat;
            } else if (wp.lat > this.box.max_lat) {
                this.box.max_lat = wp.lat;
            }
            if (wp.lng < this.box.min_lng) {
                this.box.min_lng = wp.lng;
            } else if (wp.lng > this.box.max_lng) {
                this.box.max_lng = wp.lng;
            }

            // alt_m
            wp.alt_m = this.cup_alt_m(cup_wp.elev);

            // desc
            wp.desc = this.cup_style(cup_wp.style) + ". "+cup_wp.desc;

            wp.type = "user_waypoint";

            wp.source = "local_waypoints";

            this.waypoints[wp.id] = wp;
        }
    }

    bad_header(header_keys) {
        let correct_keys = ["name", "code", "country", "lat", "lon", "elev", "style"]
        let header_bad = false;
        for (let i = 0; i < correct_keys.length; i++) {
            let key = correct_keys[i];
            if (!header_keys.includes(correct_keys[i])) {
                console.log(`CUP file bad header (missing ${correct_keys[i]})`);
                header_bad = true;
                break;
            }
        }
        return header_bad;
    }

    // Convert string from CUP record to float decimal degrees lat/lng
    // E.g. 5107.830N -> 51.1305, 05107.830W -> -51.1305
    cup_latlng(str) {
        let EWNS = str.slice(-1);
        let deg;
        let min;
        if (EWNS == "N" || EWNS == "S") {
            deg = parseInt(str.substring(0, 2));
            min = parseFloat(str.substring(2, 8));
        } else {
            deg = parseInt(str.substring(0, 3));
            min = parseFloat(str.substring(3, 9));
        }

        if ((EWNS == 'W') || (EWNS == 'S')) {
            return -(deg + (min / 60));
        }
        return (deg + (min / 60));
    }

    // Convert CUP elev values (e.g. "123.4ft") into numerical meters values
    cup_alt_m(elev_str) {
        let alt = parseFloat(elev_str);
        if (elev_str.toLowerCase().endsWith('ft')) {
            return alt / this.planner.M_TO_FEET;
        }
        return alt;
    }

    // Convert CUP style numbers into string descriptions
    cup_style(style_str) {
        const styles = [
            "Unknown wp type",
            "Waypoint",
            "Airfield with grass surface runway",
            "Outlanding",
            "Gliding airfield",
            "Airfield with solid surface runway",
            "Mountain Pass",
            "Mountain Top",
            "Transmitter Mast",
            "VOR",
            "NDB",
            "Cooling Tower",
            "Dam",
            "Tunnel",
            "Bridge",
            "Power Plant",
            "Castle",
            "Intersection",
            "Marker",
            "Control/Reporting Point",
            "PG Take Off",
            "PG Landing Zone" ];
        let style_num = parseInt(style_str);
        if (isNaN(style_num)) {
            return "";
        }
        return styles[style_num];
    }

    // Convert B record string into a time-of-day in seconds
    time_s(str) {
        return parseInt(str.substring(0, 2)) * 3600 + parseInt(str.substring(2, 4)) * 60 + parseInt(str.substring(4, 6));
    }

    // Convert HFDTE string to JS UTC Date
    date(str) {
        //      ddmmyy
        // E.g. 230622
        return new Date("20" + str.substring(4, 6) + "-" + str.substring(2, 4) + "-" + str.substring(0, 2));
    }

} // end class B21_File_CUP
"use strict"
// ******************************************************************************
// ***********   B21_Players & B21_Player classes         ***********************
// ******************************************************************************

class B21_Players {

    //DEBUG if task is loaded, track gliders around task
    constructor(planner) {
        let mp = this;
        mp.planner = planner; // reference to B21TaskPlanner instance
        mp.multiplayer_connected = false;

        // isPilot enum
        mp.IS_OTHER_PILOT = 0;
        mp.IS_LOCAL_PILOT = 1 // will highlight plane icon
        mp.IS_MULTIPLAYER_PILOT = 2; // will highlight plane icon
    }

    // reset_all() will be called on B21_TaskPlanner.reset_all(), which is also called at startup.
    reset_all() {
        let mp = this;

        mp.icon_names_display = false;
        mp.center_on_user = false;

        // control what to display in each player popup
        mp.icon_altitude_display = false;   //DEBUG from settings
        mp.icon_speed_display = false; //DEBUG from settings
        mp.icon_plane_ref_display = false; //DEBUG from settings

        // mp.alt_scalar
        // mp.alt_units-str
        // mp.speed_scalar
        // mp.speed_units_string

        if (mp.planner.settings.altitude_units == "m") {
            mp.alt_scalar = 1;
            mp.alt_units_str = "m";
        } else {
            mp.alt_scalar = mp.planner.M_TO_FEET;
            mp.alt_units_str = "feet";
        }

        if (mp.planner.settings.speed_units == "kph") {
            mp.speed_scalar = mp.planner.MS_TO_KPH;
            mp.speed_units_str = "kph";
        } else {
            mp.speed_scalar = mp.planner.MS_TO_KNOTS;
            mp.speed_units_str = "knots";
        }

        mp.current_players = {}; // dictionary of current players

        mp.local_player = null; // local player data from NB21_Logger

        mp.init_local_player(mp);

        mp.multiplayer_continue = false;
        mp.multiplayer_prev_poll = new Date();
        clearTimeout(mp.timer);
        mp.timer = setInterval(() => { mp.timer_tick(mp); }, 1000); // periodic timer
    }

    // called when user checks 'show aircraft' MP checkbox
    start_multiplayer() {
        let mp = this;
        mp.MP_MULTIPLAYER_URL = mp.planner.settings.multiplayer_url;
        console.log(`players.start_multiplayer ${mp.MP_MULTIPLAYER_URL}`);
        if (mp.MP_MULTIPLAYER_URL == null || !mp.MP_MULTIPLAYER_URL.toLowerCase().startsWith("http")) {
            alert("Click 'Settings' to add the url for your multiplayer info.");
            return false;
        }
        mp.multiplayer_continue = true;

        return true;
    }

    // called when used unchecks 'show aircraft' MP checkbox
    stop_multiplayer() {
        let mp = this;

        mp.multiplayer_continue = false;
        mp.update_multiplayer_connected(false);

        mp.scrub_players(mp,true);
    }

    update_multiplayer_connected(connected) {
        const mp = this;
        if (connected && !mp.multiplayer_connected) {
            mp.multiplayer_connected = true;
            mp.planner.multiplayer_connected();
        } else if (!connected & mp.multiplayer_connected) {
            mp.multiplayer_connected = false;
            mp.planner.multiplayer_disconnected();
        }
    }

    // called when user checks MP 'show names' checkbox
    set_names_display(display) {
        let mp = this;
        mp.icon_names_display = display;
        mp.refresh_markers();
    }

    // called when user checks MP 'show altitudes' checkbox
    set_altitude_display(display) {
        let mp = this;
        mp.icon_altitude_display = display;
        mp.refresh_markers();
    }

    // called when user checks MP 'show speeds' checkbox
    set_speed_display(display) {
        let mp = this;
        mp.icon_speed_display = display;
        mp.refresh_markers();
    }

    // Update the markers using the latest names/alt/speed checkbox values
    refresh_markers() {
        let mp = this;
        for (const player_id in mp.current_players) {
            let player = mp.current_players[player_id];
            if (!mp.icon_names_display && !mp.icon_altitude_display && !mp.icon_speed_display) {
                player.aircraft_marker.closePopup();
            } else {
                console.log(`opening MP popup for ${player_id}`);
                player.aircraft_marker.openPopup();
                player.aircraft_marker_update(mp, player);
            }
        }
    }

    set_center_on_user(center) {
        let mp = this;
        mp.center_on_user = center;
    }

    async timer_tick(mp) {
        //console.log("B21_players.timer_tick()");

        if (mp.multiplayer_continue && (new Date() - mp.multiplayer_prev_poll > Math.max(3, mp.planner.settings.multiplayer_update_seconds * 1000))) {

            await mp.get_multiplayer(mp);
        }
        mp.scrub_players(mp, false);
    }

    is_ssc_tracker_json(mp) {
        return mp.MP_MULTIPLAYER_URL != null && mp.MP_MULTIPLAYER_URL.endsWith("55055/json");
    }

    async get_multiplayer(mp) {
        let response;
        mp.multiplayer_prev_poll = new Date();
        try {
            //console.log(`B21_Players.get_multiplayer() ${mp.MP_MULTIPLAYER_URL}`);
            response = await fetch(mp.MP_MULTIPLAYER_URL);
        } catch (e) {
            console.log("B21_Players fetch error");
            mp.update_multiplayer_connected(false);
            return;
        }
        if (response.ok) {
            if (mp.is_ssc_tracker_json(mp)) {
                let mp_json = await response.json();
                mp.handle_ssc_tracker_json(mp, mp_json);
            } else {
                // whazzup
                let mp_str = await response.text();
                //console.log(mp_str);
                mp.handle_whazzup_str(mp, mp_str);
            }
            mp.update_multiplayer_connected(true);
        } else {
            mp.update_multiplayer_connected(false);
            console.log("MP fetch error");
        }
    }

    // ****************************************************************
    // Handler code for WHAZZUP data
    // ****************************************************************

    handle_whazzup_str(mp, mp_str) {
        //console.log("handle_whazzup_str", mp_str);
        let mp_str_parts = mp_str.split("!CLIENTS");
        if (mp_str_parts.length > 1) {
            let mp_players = mp_str_parts[1].split("\n");
            //console.log(`B21_Players got ${mp.MP_MULTIPLAYER_URL} ${mp_players.length-1} players`);
            for (let i=1; i<mp_players.length - 1; i++) {
                let mp_player_str = mp_players[i];
                mp.update_whazzup_player(mp, mp_player_str);
            }
        }
    }

    update_whazzup_player(mp, player_str) {
        let player_parts = player_str.split(":");

        let player_id;
        let player_lat = null;
        let player_lng = null;
        let player_alt_m;
        let player_bearing_deg;
        let player_tas_ms = 0;
        let player_plane_title = "";
        let plane_ref = "";
        let plane_is_glider = false;

        try {
            player_id = player_parts[0];
            player_lat = parseFloat(player_parts[5]);
            player_lng = parseFloat(player_parts[6]);
            player_alt_m = parseFloat(player_parts[7]) / mp.planner.M_TO_FEET;
            player_bearing_deg = player_parts[45];
        } catch (e) {
            return;
        }

        console.log(`whazzup update '${player_id}`);

        // Ignore players at latlng 0,0
        if (player_lat == null || player_lng == null || (Math.abs(player_lat) < 0.1 && Math.abs(player_lng) < 0.1)) {
            //console.log(`B21_Players.handle_player_str: Warning player ${player_id} at LatLng(0,0)`);
            return;
        }

        try {
            player_tas_ms = player_parts[8] / mp.planner.MS_TO_KNOTS;
            player_plane_title = player_parts[9];
            plane_ref = B21_GLIDERS.find_glider_type(player_plane_title);
            plane_is_glider = plane_ref != "";
            if (!plane_is_glider) {
                plane_ref = player_plane_title;
            }
        } catch (e) {

        }

        // is_pilot = other=0 | local=1 | multiplayer=2
        let is_pilot = player_id == mp.planner.settings.multiplayer_pilot_id ? mp.IS_MULTIPLAYER_PILOT : mp.IS_OTHER_PILOT;
        let plane_class = plane_is_glider ? 1 : 2;

        // If player not known, create new entry
        if (!mp.current_players.hasOwnProperty(player_id)) {
            console.log(`B21_Players creating new ${player_id} is_pilot=${is_pilot} plane_class=${plane_class}`); //DEBUG suppress this debug msg
            mp.current_players[player_id] = new B21_Player(mp, is_pilot, plane_class);
            mp.current_players[player_id].player_id = player_id;
            if (mp.icon_names_display) {
                console.log(`MP handle_player_str opening popup for ${player_id}`);
                mp.current_players[player_id].aircraft_marker.openPopup();
            }
        }

        //DEBUG we need to detect two players with same ID
        let current_player = mp.current_players[player_id];
        current_player.plane_ref = plane_ref; //DEBUG detect plane change?
        current_player.lat = player_lat;
        current_player.lng = player_lng;
        current_player.alt_m = player_alt_m;
        current_player.tas_ms = player_tas_ms;
        current_player.bearing_deg = player_bearing_deg;
        current_player.is_glider = plane_is_glider;
        current_player.is_pilot = is_pilot;
        current_player.plane_class = plane_class;

        // Update the marker if it should change
        if (current_player.is_pilot != current_player.prev_is_pilot || current_player.plane_class != current_player.prev_plane_class) {
            current_player.replace_marker(mp);
        }

        current_player.update();

        if ( mp.center_on_user && current_player.is_pilot) {
            console.log(`panning for ${current_player.player_id}`);
            mp.planner.map.panTo(L.latLng(current_player.lat, current_player.lng));
        }
    }

    // ****************************************************************
    // Handler code for SSC TRACKER JSON data
    // ****************************************************************

    handle_ssc_tracker_json(mp, mp_json) {
        let mp_players = mp_json["ITEMS"];
        if (mp_players != null && mp_players.length != null && mp_players.length > 0) {
            //console.log(`B21_Players got ${mp.MP_MULTIPLAYER_URL} ${mp_players.length} players`);
            for (let i=0; i<mp_players.length; i++) {
                //console.log(`parsing ${i}/${mp_players.length} '${mp_players[i]}'`);
                let mp_player = mp_players[i];
                mp.update_ssc_tracker_json_player(mp, mp_player);
            }
        }
    }

    // {  "GN": "SSC", "TASK": "", "WEATHER": "", "ID": "B21", "CONFIG": 0,
    //    "ITEMS": [
    //        { "CMD": "", "SECRET": "", "GN": "SSC", "ID": "B21", "NAME": "Ian FL", "AC": "JS3-18 GMA", "MODEL": "JS3-18",
    //          "TH": 259.3,
    //          "LON": 12.792048, "LAT": 47.290115,
    //          "IAS": 75.6,              // knots
    //          "TAS": 81.5,              // knots
    //          "GS": 66.6,               // knots
    //          "LV": 0,
    //          "VS": 0,
    //          "WD": 269, "WV": 15.1,    // wind direction, speed (knots)
    //          "MSL": 3017, "AGL": 544,  // altitude MSL, AGL (feet)
    //          "TSK_TIME": 6363, "TSK_AVG": 106.3, "TSK_AVG_PATH": 117.1, "TSK_NEXT": "Finished", "TSK_DIS": 0, "TSK_DIS_PATH": 207,
    //          "TSK_DIS_ALL": 187.9, "TSK_DIS_WP": 0, "TSK_ONGROUND": 0, "TSK_SLEWT": 0, "TSK_ENG": 0, "DIS": 0,
    //          "FLAPS": "3", "MC": 0, "TW": 1266.7, "VER": "0.5.3.0|MSFS2020", "ONLINE": 0
    //        }
    //    ]
    // }

    update_ssc_tracker_json_player(mp, player) {

        let player_id;
        let player_lat = null;
        let player_lng = null;
        let player_alt_m;
        let player_bearing_deg;
        let player_tas_ms = 0;
        let player_plane_title = "";
        let plane_ref = "";
        let plane_is_glider = false;

        try {
            player_id = player.ID;
            player_lat = player.LAT;
            player_lng = player.LON;
            player_alt_m = player.MSL / mp.planner.M_TO_FEET;
            player_bearing_deg = player.TH;
        } catch (e) {
            return;
        }

        //console.log(`ssc-tracker json update '${player_id}'`);

        // Ignore players at latlng 0,0
        if (player_lat == null || player_lng == null || (Math.abs(player_lat) < 0.1 && Math.abs(player_lng) < 0.1)) {
            //console.log(`B21_Players.handle_player_str: Warning player ${player_id} at LatLng(0,0)`);
            return;
        }

        try {
            player_tas_ms = player.TAS / mp.planner.MS_TO_KNOTS;
            player_plane_title = player.MODEL;
            plane_ref = B21_GLIDERS.find_glider_type(player_plane_title);
            plane_is_glider = plane_ref != "";
            if (!plane_is_glider) {
                plane_ref = player_plane_title;
            }
        } catch (e) {

        }

        // is_pilot = other=0 | local=1 | multiplayer=2
        let is_pilot = player_id == mp.planner.settings.multiplayer_pilot_id ? mp.IS_MULTIPLAYER_PILOT : mp.IS_OTHER_PILOT;
        let plane_class = plane_is_glider ? 1 : 2;

        // If player not known, create new entry
        if (!mp.current_players.hasOwnProperty(player_id)) {
            console.log(`B21_Players creating new ${player_id} is_pilot=${is_pilot} plane_class=${plane_class}`); //DEBUG suppress this debug msg
            mp.current_players[player_id] = new B21_Player(mp, is_pilot, plane_class);
            mp.current_players[player_id].player_id = player_id;
            if (mp.icon_names_display) {
                console.log(`MP handle_player_str opening popup for ${player_id}`);
                mp.current_players[player_id].aircraft_marker.openPopup();
            }
        }

        //DEBUG we need to detect two players with same ID
        let current_player = mp.current_players[player_id];
        current_player.plane_ref = plane_ref; //DEBUG detect plane change?
        current_player.lat = player_lat;
        current_player.lng = player_lng;
        current_player.alt_m = player_alt_m;
        current_player.tas_ms = player_tas_ms;
        current_player.bearing_deg = player_bearing_deg;
        current_player.is_glider = plane_is_glider;
        current_player.is_pilot = is_pilot;
        current_player.plane_class = plane_class;

        // Update the marker if it should change
        if (current_player.is_pilot != current_player.prev_is_pilot || current_player.plane_class != current_player.prev_plane_class) {
            current_player.replace_marker(mp);
        }

        current_player.update();

        if ( mp.center_on_user && current_player.is_pilot) {
            console.log(`panning for ${current_player.player_id}`);
            mp.planner.map.panTo(L.latLng(current_player.lat, current_player.lng));
        }
    }

    // Remove players that have not been seen for a while.
    scrub_players(mp, all) {
        //console.log("B21_Players Scrubbing players");

        // Whazzup players
        for (const player_id in mp.current_players) {
            let player = mp.current_players[player_id];

            if (all || !player.is_active()) {
                mp.scrub_multiplayer_player(mp,player);
            }
        }

        // local_player
        if (all || !mp.local_player.is_active()) {
            //console.log("B21_Players scrubbing local_player");
            mp.local_player.mark_inactive(mp);
        }
    }

    scrub_multiplayer_player(mp, player) {
        console.log(`B21_Players Scrubbing ${player.player_id}`);
        mp.planner.map.removeLayer(player.aircraft_marker);
        delete mp.current_players[player.player_id];
    }

    // ************************************************************************************
    // ** LOCAL PLAYER functionality for data from NB21 Logger
    // ************************************************************************************

    init_local_player(mp) {
        console.log(`B21_Players.init_local_player()`);
        //DEBUG maybe we can handle the plane type
        let plane_class = 1; // 1= glider, 2=other
        mp.local_player = new B21_Player(mp, mp.IS_LOCAL_PILOT, plane_class);
    }

    // Call from NB21Connect -> B21TaskPlanner -> B21_Players
    handle_nb21_header(mp, msg) {
        mp.local_player.handle_nb21_header(msg);
    }

    // Call from NB21Connect -> B21TaskPlanner -> B21_Players
    handle_nb21_msg(mp,msg) {
        mp.local_player.handle_nb21_msg(msg);
    }

    handle_nb21_msg_json(mp, msg_json) {
        mp.local_player.handle_nb21_msg_json(msg_json);
    }

    local_player_disconnected() {
        let mp = this;
        console.log("B21_Players.local_player_disconnected()");
        mp.planner.update_msfs_wind_arrow(0, false); // Hide MSFS wind arrow
        //if (mp.local_player != null)  {
        //  HIDE PLAYER GLIDER ICON
        // }
    }
} // end class B21_Players

// **********************************************************************************
// **********************************************************************************
// ********              Class B21_Player             *******************************
// **********************************************************************************
// **********************************************************************************

/* Following simvars are provided by NB21_logger V1.00 onwards
    {
        "ver": "v2",
        "msg": "repeat",
        "utc": "103654",
        "local_time": "130130",
        "local_date": "20241014",
        "lat": -43.32304722,
        "lon": 171.93627323,
        "alt_m": 1177.7,
        "agl_m": 834.6,
        "tas_kph": 168.6,
        "eng": 0,
        "flap": 2,
        "on_gnd": 0,
        "wind_y_ms": 1.06,
        "wind_kph": 8.3,
        "wind_deg": 223.4,
        "abs_time_s": 63864460890.892,
        "sim_time_s": 191.59,
        "hdg_true_deg": 47.3,
        "gps_ground_track_deg": 47.1,
        "master_bat": 1,
        "gps_ground_speed_ms": 49.18,
        "airspeed_ind_ms": 43.46,
        "ground_alt_m": 343.2,
        "ambient_temp_k": 291.6,
        "ambient_pressure_mb": 879.6,
        "velocity_world_z_ms": 33.5,
        "velocity_world_x_ms": 36.01,
        "sim_rate": 1,
        "weather_hash": 4356317
    }
*/

class B21_Player {
    constructor (mp, is_pilot, plane_class) {
        this.mp = mp;

        let player = this;

        player.player_id = null;
        player.updated_time = null;
        player.plane_ref = null;
        player.move_distance_m = 0.0; // move distance in latest update;
        player.lat = 0.0;
        player.lng = 0.0;
        player.alt_m = null;
        player.tas_ms = null;
        player.bearing_deg = null;
        player.wind_deg = null;

        player.nb21_vars = {};

        player.is_pilot = is_pilot; // pilot is local or id matches the task planner setting
        player.prev_is_pilot = is_pilot;
        player.plane_class = plane_class; // 1 = glider, 2 = other
        player.prev_plane_class = plane_class;
        player.marked_inactive = false;
        player.marker_icon = null;

        player.aircraft_marker = player.create_marker(mp);

        // Create tracklog for this player
        player.tracklog = new B21_TrackLog(0, player.mp.planner, player.mp.planner.map);
        player.tracklog.init_local_player();
    }

    is_active() {
        let player = this;
        if (player.updated_time == null) {
            return false;
        }
        let updated_age_s = (new Date() - player.updated_time) / 1000;
        const MAX_UPDATED_AGE_S = 30; // Players with older update than this will be scrubbed
        return updated_age_s < MAX_UPDATED_AGE_S;
    }

    handle_nb21_header(msg) {
        let player = this;
        //console.log(`B21_Player.handle_nb21_header(${msg})`);
        player.tracklog.update_local_player_header(msg);
    }

    handle_nb21_msg(msg_str) {
        let player = this;
        //console.log(`B21_Player.handle_nb21_msg(${msg_str})`);
        let updated = false;
        let logpoint = player.tracklog.update_local_player(msg_str);
        if (logpoint) {
            updated = player.update_from_logpoint(logpoint); // update the local player on map using data now in local_tracklog
        }

        if (updated) {
            player.handle_update(player);
        }
    }

    handle_nb21_msg_json(msg_json) {
        let player = this;
        try {
            let updated = player.update_from_json(msg_json);
            if (updated) {
                player.handle_update(player);
            }
        } catch(e) {
            console.warn(e);
        }
    }

    // Handle the update from either IGC or JSON
    handle_update(player) {
        player.update();

        // Update the planner MSFS realtime wind arrow with the current wind direction
        if (player.wind_deg != null) {
            player.mp.planner.update_msfs_wind_arrow(player.wind_deg, true);
        } else {
            player.mp.planner.update_msfs_wind_arrow(0, false);
        }

        //console.log(`B21_Players.update_local_player() moved ${move_distance_m.toFixed(1)} meters`);
        if ( player.mp.center_on_user || player.move_distance_m > 1000 ) {
            console.log(`B21_Player.update_from_logpoint() panning for local_player`);
            player.mp.planner.map.panTo(L.latLng(player.lat, player.lng));
        }
    }

    update_from_json(msg_json) {
        let player = this;

        if (msg_json.msg != "repeat") {
            return;
        }
        // Calculate move distance before updating player
        player.move_distance_m = Geo.get_distance_m({lat: msg_json.lat, lng: msg_json.lon}, player);
        console.log("Move distance m",player.move_distance_m);

        player.lat = msg_json.lat;
        player.lng = msg_json.lon;
        player.alt_m = msg_json.alt_m;
        player.bearing_deg = msg_json.gps_ground_track_deg;
        player.wind_deg = msg_json.wind_deg;

        Object.keys(msg_json).forEach(function(key) {
            player.nb21_vars[key] = msg_json[key];
        });

        return true;
    }

    update_from_logpoint(logpoint) {
        let player = this;

        // Calculate move distance before updating player
        player.move_distance_m = Geo.get_distance_m(logpoint, player);
        //console.log("Move distance m",player.move_distance_m);

        player.lat = logpoint.lat;
        player.lng = logpoint.lng;
        player.alt_m = logpoint.alt_m;
        if (player.tracklog.logpoints.length > 1) {
            let prev_logpoint = player.tracklog.logpoints[player.tracklog.logpoints.length-2]
            player.bearing_deg = Geo.get_bearing_deg(prev_logpoint, player);
        }
        player.wind_deg = logpoint.WDI;

        return true;
    }

    mark_inactive(mp) {
        let player = this;
        player.marked_inactive = true;
        // change icon to gray
        let svgIcon = player.create_icon(mp);

        player.aircraft_marker.setIcon(svgIcon);
    }

    update() {
        let player = this;
        player.updated_time = new Date();

        if (player.marked_inactive) {
            player.marked_inactive = false;
            let svgIcon = player.create_icon(player.mp);
            player.aircraft_marker.setIcon(svgIcon);
        }

        player.aircraft_marker.setLatLng(new L.LatLng(player.lat, player.lng));

        player.aircraft_marker.setRotationAngle(player.bearing_deg);

        player.aircraft_marker_update(player.mp, player);
    }

    // **************************************************************************************
    // ************ Create the SVG glider aircraft_marker to show position on map   *********
    // **************************************************************************************

    create_icon(mp) {
        let player = this;
        // choose color based on local pilot (yellow), multiplayer pilot (green) or glider (red) or other (blue)
        let color_wings = "#00a"; // blue
        let color_fuselage = "#00a";
        let scale = 0.6;
        if (player.is_pilot == mp.IS_LOCAL_PILOT) {
            color_wings = "#ff8"; // yellow
            color_fuselage = "#ff8";
            scale = 1.2;
        } else if (player.is_pilot == mp.IS_MULTIPLAYER_PILOT) {
            color_wings = "#8f8"; // green
            color_fuselage = "#8f8";
            scale = 1.2;
        } else if (player.plane_class == 1) { // other gliders
            color_wings = "#a00"; // red
            color_fuselage = "#a00";
            scale = 1;
        }

        // If inactive, override the color to gray
        if (player.marked_inactive) {
            color_wings = "#999";
            color_fuselage = "#999";
        }

        // Glider icon with separate wings & fuselage for coloring
        let svgIcon;
        // Choose icon SVG for glider vs other
        if (player.plane_class == 1) {
            // Glider
            svgIcon = L.divIcon({
                html: `
                <svg width="64" height="64" xmlns="http://www.w3.org/2000/svg" style="transform-origin: center; transform: scale(${scale});">
                <g id="Layer_1">
                <title>Layer 1</title>
                <path id="wings" d="M33 37 h 14 l 12 2 v 2 h -56 v -2 l 12 -2 z" stroke="#000" fill="${color_wings}"/>
                <path id="fuselage" d="M30 31 h 2 l 1 6 v4 l -1 20  h 5 v 2 h -12 v -2  h 5 l -1 -20 v -4 z" stroke="#000" fill="${color_fuselage}"/>
                </g>
                </svg>
                `,
                className: "",
                iconSize: [64,64],
                iconAnchor: [32,32]
            });
        } else {
            // Other aircraft
            svgIcon = L.divIcon({
                html: `
                <svg width="64" height="64" xmlns="http://www.w3.org/2000/svg" style="transform-origin: center; transform: scale(${scale});">
                <g id="Layer_1">
                <title>Layer 1</title>
                <path id="wings" d="M33 37 h 14 l 4 5 v 3 h -38 v -3 l 4 -5 z" stroke="#000" fill="${color_wings}"/>
                <path id="fuselage" d="M30 31 h 4 l 1 6 v4 l -1 17  h 5 v 5 h -14 v -5  h 5 l -1 -17 v -4 z" stroke="#000" fill="${color_fuselage}"/>
                </g>
                </svg>
                `,
                className: "",
                iconSize: [64,64],
                iconAnchor: [32,32],
            });
        }

        return svgIcon;
    }

    // plane_class 1 = Glider, 2 = Other planes, pilot = true/false for current
    create_marker(mp) {
        let player = this;

        let svgIcon = player.create_icon(mp, false);

        let zIndexOffset = 0;
        if (this.is_pilot == mp.IS_LOCAL_PILOT) {
            zIndexOffset = 200;
        } else if (this.is_pilot == mp.IS_MULTIPLAYER_PILOT) {
            zIndexOffset = 100;
        }

        let aircraft_marker = L.marker([0,0], {
            icon: svgIcon,
            rotationOrigin: 'center',
            zIndexOffset: zIndexOffset
        }); // extended using leaflet.rotationMarker

        let popup = L.popup({
            closeButton: false,
            className: "tracklog_popup",
            autoPan: false,
            autoClose: false
        }).setContent("no name set");

        aircraft_marker.bindPopup(popup);

        aircraft_marker.addTo(mp.planner.map);

        return aircraft_marker;
    }

    replace_marker(mp) {
        console.log(`B21_Player.replace_marker ${this.player_id}`);
        mp.planner.map.removeLayer(this.aircraft_marker);
        this.aircraft_marker = this.create_marker(mp.planner);
        this.prev_is_pilot = this.is_pilot;
        this.prev_plane_class = this.plane_class;
    }

    aircraft_marker_update(mp, player) {
        try {
            let alt_str = "";
            let speed_str = "";
            let plane_ref_str = "";
            let seperator = "";

            if (mp.icon_altitude_display) {
                alt_str = (player.alt_m * mp.alt_scalar).toFixed(0) + mp.alt_units_str;
                seperator = "<br/>";
            }

            if (mp.icon_speed_display) {
                speed_str = seperator + ((player.tas_ms == null ? 0 : player.tas_ms) * mp.speed_scalar).toFixed(0) + mp.speed_units_str ;
            }

            if (mp.icon_plane_ref_display) {
                plane_ref_str = seperator + player.plane_ref.slice(0,12); ;
            }

            let competition_id_str = player.player_id;

            let tail_str = "";
            if (mp.icon_names_display && competition_id_str != "") {
                tail_str = '<div><div class="tracklog_icon_competition_id">'+competition_id_str+"</div></div>";
            }

            let popup_str = '<div class="tracklog_icon_popup">'+alt_str + speed_str + plane_ref_str +tail_str + "</div>";

            player.aircraft_marker.setPopupContent(popup_str);
        } catch (e) {
            console.log("aircraft_marker_update exception",e);
        }
    }

} // end class B21_Player

"use strict"
// Loads settings from localstorage

// Note we are treating the Local Waypoints files (like CUP) as 'settings' as they are persisted to localStorage.

class B21_Settings {

    // ********************************************************************************************
    // *********  Settings                                 ****************************************
    // ********************************************************************************************

    constructor(planner) {

        this.planner = planner;

        this.settings_el = document.getElementById("settings");

        this.SETTINGS_VAR_PREFIX = 'b21_task_planner_';
        this.SETTINGS_LOCAL_WAYPOINTS_INFO = this.SETTINGS_VAR_PREFIX+'local_waypoints_info';

        this.init();
    }

    init() {
        this.settings = {};

        // Storage for settings values and options
        this.settings_values = {
            soaring_task: 1, // 1 or 0 = true/false whether to embed the B21/ALBATROSS soaring params
            altitude_units: ["feet", "m"],
            speed_units: ["kph", "knots"],
            distance_units: ["km", "miles"],
            wp_radius_units: ["m", "feet"],
            wp_radius_m: 500,
            wp_min_alt_m: 330,
            wp_max_alt_m: 2000,
            show_speed_line_on_chart: ["yes","no"],
            task_line_color_1: ["red","green","yellow"],
            task_line_color_2: ["none", "brown", "black"],
            base_layer_name: "Streetmap",
            // Local player (from NB21 Logger)
            nb21_connect: true,
            // User Aircraft
            //user_aircraft: ["ignore", "display on map", "center on map"],
            // Multiplayer
            multiplayer_url: "",
            multiplayer_update_seconds: 4,
            multiplayer_pilot_id: "",
            // scoring
            scoring_penalties: ["yes","no"]
        };

        // List of settings to display in settings menu
        this.settings_to_display = [
            "altitude_units",
            "speed_units",
            "distance_units",
            "wp_radius_units",
            "show_speed_line_on_chart",
            "task_line_color_1",
            "task_line_color_2",
            //"user_aircraft",
            "multiplayer_pilot_id",
            "multiplayer_url",
            "multiplayer_update_seconds",
            "scoring_penalties"
        ];

        this.local_waypoints_info = []; // ARRAY of [ { local_waypoints_key, active }, ... ]

        this.settings_el.style.display = "none";
        this.settings_displayed = false;

        this.load_settings();

        this.build_settings_html();
    }

    toggle() {
        console.log("toggle settings from", this.settings_displayed);
        if (this.settings_displayed) {
            this.close_settings();
        } else {
            this.build_settings_html();
            this.settings_el.style.display = "block";
            this.settings_displayed = true;
        }
    }

    close_settings() {
        this.settings_el.style.display = "none";
        this.settings_displayed = false;
        this.planner.show_task_info();
        this.planner.task.draw();
    }

    reset_settings() {
        if (confirm("Do you really want to reset all local settings values, including your custom waypoints?")) {

            // clear localStroage, but see if we can persist the id
            let id = localStorage.getItem("b21_task_planner_id");
            localStorage.clear();
            if (id != null) {
                localStorage.setItem("b21_task_planner_id", id);
            }

            this.init();

            this.settings_el.style.display = "block";
            this.planner.show_task_info();
            this.planner.task.draw();
            this.settings_displayed = true;
        }
    }

    build_settings_html() {
        console.log("build_settings_html()");

        B21_Utils.clear_div(this.settings_el);

        let heading_el = document.createElement("div");
        heading_el.id = "settings_heading";

        let heading_text_el = document.createElement("div");
        heading_text_el.id = "settings_heading_text";
        heading_text_el.innerHTML = "Settings";
        heading_el.appendChild(heading_text_el);

        let close_el = document.createElement("button");
        close_el.addEventListener("click", (e) => this.close_settings());
        close_el.innerHTML = "Close Settings";
        heading_el.appendChild(close_el);

        let reset_el = document.createElement("button");
        reset_el.addEventListener("click", (e) => this.reset_settings());
        reset_el.innerHTML = "Reset ALL Settings";
        heading_el.appendChild(reset_el);

        this.settings_el.appendChild(heading_el);

        for (const i in this.settings_to_display) {
            let var_name = this.settings_to_display[i];
            if (typeof this.settings_values[var_name] == "object") {
                this.build_options_setting_html(var_name);
            } else if (typeof this.settings_values[var_name] == "string") {
                this.build_string_setting_html(var_name);
            } else if (typeof this.settings_values[var_name] == "number") {
                this.build_number_setting_html(var_name);
            } else if (typeof this.settings_values[var_name] == "boolean") {
                this.build_boolean_setting_html(var_name);
            }
        }

        this.build_all_local_waypoints_html();
    }

    build_options_setting_html(var_name) {
        let parent = this;
        let setting_el = document.createElement("div");
        setting_el.className = "setting";
        let setting_name_el = document.createElement("div");
        setting_name_el.className = "setting_name";
        setting_name_el.innerHTML = this.var_name_to_title(var_name);
        setting_el.appendChild(setting_name_el);
        if (typeof this.settings_values[var_name] == "object") {
            let setting_options_el = document.createElement("div");
            setting_options_el.className = "setting_options";
            for (let i = 0; i < this.settings_values[var_name].length; i++) {
                let option_name = this.settings_values[var_name][i];

                let setting_option_el = document.createElement("div");
                setting_option_el.className = "setting_option";

                let setting_option_entry_el = document.createElement("div");
                setting_option_entry_el.id = "setting_" + var_name + "_" + option_name;
                setting_option_entry_el.className = "setting_option_entry";
                setting_option_entry_el.addEventListener("click", (e) => {
                    parent.unset(var_name);
                    parent.select(e.target);
                    parent.set(var_name, option_name);
                    parent.planner.task.display_task_info();
                });
                setting_option_entry_el.innerHTML = "Option: " + option_name;
                setting_option_el.appendChild(setting_option_entry_el);

                if (this[var_name] == option_name) {
                    this.select(setting_option_entry_el);
                }
                setting_options_el.appendChild(setting_option_el);
            }
            setting_el.appendChild(setting_options_el);
        }
        this.settings_el.appendChild(setting_el);
    }

    build_string_setting_html(var_name) {
        let parent = this;
        let setting_el = document.createElement("div");
        setting_el.className = "setting";
        let setting_name_el = document.createElement("div");
        setting_name_el.className = "setting_compact_name";
        setting_name_el.innerHTML = this.var_name_to_title(var_name);
        setting_el.appendChild(setting_name_el);

        let setting_options_el = document.createElement("div");
        setting_options_el.className = "setting_options";
        let setting_string_el = document.createElement("div");
        setting_string_el.className = "setting_string";
        let setting_option_entry_el = document.createElement("input");
        setting_option_entry_el.setAttribute("type","text");
        setting_option_entry_el.id = "setting_" + var_name;
        setting_option_entry_el.className = "setting_string_entry";
        setting_option_entry_el.value = parent[var_name];
        setting_option_entry_el.addEventListener("blur", (e) => {
            parent.set(var_name, e.target.value);
            console.log(`Setting set ${var_name} to ${e.target.value}`);
        });
        setting_string_el.appendChild(setting_option_entry_el);
        setting_el.appendChild(setting_string_el);
        this.settings_el.appendChild(setting_el);
    }

    build_number_setting_html(var_name) {
        let parent = this;
        let setting_el = document.createElement("div");
        setting_el.className = "setting";
        let setting_name_el = document.createElement("div");
        setting_name_el.className = "setting_compact_name";
        setting_name_el.innerHTML = this.var_name_to_title(var_name);
        setting_el.appendChild(setting_name_el);

        let setting_options_el = document.createElement("div");
        setting_options_el.className = "setting_options";
        let setting_number_el = document.createElement("div");
        setting_number_el.className = "setting_number";
        let setting_option_entry_el = document.createElement("input");
        setting_option_entry_el.setAttribute("type","text");
        setting_option_entry_el.id = "setting_" + var_name;
        setting_option_entry_el.className = "setting_number_entry";
        setting_option_entry_el.value = parent[var_name];
        setting_option_entry_el.addEventListener("blur", (e) => {
            let value;
            value = parseFloat(e.target.value);
            if (isNaN(value)) {
                alert("Input must be numeric.");
                setting_option_entry_el.value = parent.settings_values[var_name];
                return;
            }
            console.log(`Setting set ${var_name} to ${value}`);
            parent.set(var_name, value);
        });
        setting_number_el.appendChild(setting_option_entry_el);
        setting_el.appendChild(setting_number_el);
        this.settings_el.appendChild(setting_el);
    }

    build_boolean_setting_html(var_name) {
        let parent = this;
        let setting_el = document.createElement("div");
        setting_el.className = "setting";
        let setting_name_el = document.createElement("div");
        setting_name_el.className = "setting_compact_name";
        setting_name_el.innerHTML = this.var_name_to_title(var_name);
        setting_el.appendChild(setting_name_el);

        let setting_options_el = document.createElement("div");
        setting_options_el.className = "setting_options";
        let setting_boolean_el = document.createElement("div");
        setting_boolean_el.className = "setting_boolean";
        let setting_option_entry_el = document.createElement("input");
        setting_option_entry_el.setAttribute("type","checkbox");
        setting_option_entry_el.id = "setting_" + var_name;
        setting_option_entry_el.className = "setting_boolean_entry";
        setting_option_entry_el.checked = parent[var_name];
        setting_option_entry_el.addEventListener("click", (e) => {
            parent.set(var_name, e.target.checked);
            console.log(`Setting set ${var_name} to ${e.target.checked}`);
        });
        setting_boolean_el.appendChild(setting_option_entry_el);
        setting_el.appendChild(setting_boolean_el);
        parent.settings_el.appendChild(setting_el);
    }

    var_name_to_title(var_name) {
        let parts = var_name.split("_");
        let title = "";
        for (let i = 0; i < parts.length; i++) {
            title += (i > 0 ? " " : "") + parts[i][0].toUpperCase() + parts[i].slice(1);
        }
        return title;
    }

    select(el) {
        el.style.backgroundColor = "lightgreen";
    }

    unselect(el) {
        el.style.backgroundColor = "white";
    }

    unset(var_name) {
        for (let i = 0; i < this.settings_values[var_name].length; i++) {
            let option_name = this.settings_values[var_name][i];
            let id = "setting_" + var_name + "_" + option_name;
            this.unselect(document.getElementById(id));
        }
    }

    set(var_name, value) {
        console.log(`Settings seting ${var_name} to ${value}`);
        this[var_name] = value;
        window.localStorage.setItem(this.SETTINGS_VAR_PREFIX + var_name, "" + value);
    }

    load_setting(var_name) {
        //console.log(`Settings load_setting ${var_name}`);
        let value = window.localStorage.getItem(this.SETTINGS_VAR_PREFIX + var_name);
        let error = true;
        if (typeof this.settings_values[var_name] == "string") {
            if (value == null || value == "") {
                this[var_name] = this.settings_values[var_name];
                console.log(`Settings string load empty so setting ${var_name} ${this[var_name]}`);
            } else {
                this[var_name] = value;
                console.log(`Settings loaded string ${var_name} ${this[var_name]}`);
            }
        } else if (typeof this.settings_values[var_name] == "object") {
            for (let i = 0; i < this.settings_values[var_name].length; i++) {
                if (value == this.settings_values[var_name][i]) {
                    this[var_name] = value;
                    //console.log(`Settings loaded option ${var_name} ${this[var_name]}`);
                    error = false;
                    break;
                }
            }
            if (error) {
                this[var_name] = this.settings_values[var_name][0];
                //console.log(`Settings loaded option error fallback to ${var_name} ${this[var_name]}`);

            }
        } else if (typeof this.settings_values[var_name] == "number") {
            if (value == null || value == "") {
                this[var_name] = this.settings_values[var_name];
                console.log(`Settings number load empty so setting ${var_name} ${this[var_name]}`);
            } else {
                this[var_name] = parseFloat(value);
                if (isNaN(this[var_name])) {
                    this[var_name] = this.settings_values[var_name];
                    //console.log(`Settings loaded number ${var_name} ${this[var_name]}`);
                }
            }
        } else if (typeof this.settings_values[var_name] == "boolean") {
            if (value == null || value == "") {
                this[var_name] = this.settings_values[var_name];
                console.log(`Settings boolean load empty so setting ${var_name} ${this[var_name]}`);
            } else {
                this[var_name] = value.toLowerCase() == "true";
            }
            //console.log(`Settings loaded boolean ${var_name} ${this[var_name]}`);
        } else {
            console.log(`Settings type error loading Setting ${var_name}`);
        }
        //console.log("Setting load_setting completed with", var_name, this[var_name]);
    }

    // Load all the persisted settings valuse from localStorage
    load_settings() {
        // Load the settings 'vars' such as altitude_units
        for (const var_name in this.settings_values) {
            this.load_setting(var_name);
        }

        // This soaring_task flag is a placeholder (always true)
        if (this.soaring_task == 0) {
            document.getElementById("soaring_task_checkbox").checked = false;
        }
        console.log("load_settings", this.altitude_units, this.distance_units, this.speed_units);

        // Load .local_waypoints_info and then the active waypoints into b21_task_planner
        this.load_settings_active_waypoints();
    }

    // ***********************************************************************
    // ************** Local Waypoints           ******************************
    // ***********************************************************************

    // Read local_waypoints_info from localStorage, and
    // load all waypoints data flagged as 'active'
    load_settings_active_waypoints() {
        console.log("load_settings_local_waypoints()");
        // '[ { "local_waypoints_key":  "BGA 2022 Revision a SeeYou.cup", "load": true } .. ]'
        let local_waypoints_info_str = window.localStorage.getItem(this.SETTINGS_LOCAL_WAYPOINTS_INFO);
        if (local_waypoints_info_str == null) {
            console.log("load_settings_local_waypoints got null from localStorage");
            return;
        }
        try {

            this.local_waypoints_info = JSON.parse(local_waypoints_info_str);
            console.log("loaded local_waypoints_info from settings", this.local_waypoints_info);
            for (let i=0; i<this.local_waypoints_info.length; i++) {
                if (this.local_waypoints_info[i].active) {
                    console.log("load_settings_local_waypoints loading active",this.local_waypoints_info[i]);
                    let key = this.local_waypoints_info[i].local_waypoints_key;
                    this.load_waypoints(key);
                } else {
                    console.log("load_settings_local_waypoints skipping inactive",this.local_waypoints_info[i]);
                }
            }

        } catch (e) {
            console.log("load error for local waypoints settings", e);
            alert("An error occurred while loading your saved Local Waypoints");
            window.localStorage.removeItem(this.SETTINGS_LOCAL_WAYPOINTS_INFO);
            return;
        }
    }

    // Load waypoints from localStorage
    load_waypoints(key) {
        let waypoints_obj = new B21_Local_Waypoints(this.planner, key);
        let waypoints_str = window.localStorage.getItem(this.SETTINGS_VAR_PREFIX+'waypoints_'+key);
        waypoints_obj.loads(waypoints_str);
        this.planner.add_local_waypoints(key, waypoints_obj);
    }

    build_all_local_waypoints_html() {
        console.log("build_all_local_waypoints_html()", this.local_waypoints_info);
        for (let i=0; i<this.local_waypoints_info.length; i++) {
            this.build_local_waypoints_html(this.local_waypoints_info[i]);
        }
    }

    build_local_waypoints_html(waypoints_info) {
        console.log("build_local_waypoints_html",waypoints_info);
        let parent = this;

        let local_waypoints_key = waypoints_info.local_waypoints_key;

        let setting_el = document.createElement("div");
        setting_el.className = "setting";
        let setting_name_el = document.createElement("div");
        setting_name_el.className = "setting_name";
        setting_name_el.innerHTML = "Local waypoints: "+local_waypoints_key;
        setting_el.appendChild(setting_name_el);

        let setting_options_el = document.createElement("div");
        setting_options_el.className = "setting_options";

        let setting_option_enabled_el = document.createElement("div");
        setting_option_enabled_el.className = "setting_option";
        let setting_option_enabled_entry_el = document.createElement("div");
        setting_option_enabled_entry_el.id = "setting_waypoints_" + local_waypoints_key + "_enabled";
        setting_option_enabled_entry_el.className = "setting_option_entry";
        setting_option_enabled_entry_el.innerHTML = "Option: load on startup";
        setting_option_enabled_entry_el.addEventListener("click", (e) => {
            console.log("local_waypoints setting CLICKED: enabled", local_waypoints_key, e);
            if (waypoints_info.active) {
                return; // waypoints are already enabled, so ignore
            }
            this.wp_unselect(local_waypoints_key);
            e.target.className = "setting_option_entry_selected";
            waypoints_info.active = true;
            this.store_local_waypoints_info();
            // If these waypoints are not already loaded, we should load them
            if (this.planner.local_waypoints_loaded_status(local_waypoints_key)) {
                this.planner.local_waypoints_set_active(local_waypoints_key);
            } else {
                this.load_waypoints(local_waypoints_key);
            }
            // Tell the planner new local waypoints have been loaded
            this.planner.local_waypoints_load_completed(local_waypoints_key);
        });
        setting_option_enabled_el.appendChild(setting_option_enabled_entry_el);
        setting_options_el.appendChild(setting_option_enabled_el);

        let setting_option_disabled_el = document.createElement("div");
        setting_option_disabled_el.className = "setting_option";
        let setting_option_disabled_entry_el = document.createElement("div");
        setting_option_disabled_entry_el.id = "setting_waypoints_" + local_waypoints_key + "_disabled";
        setting_option_disabled_entry_el.className = "setting_option_entry";
        setting_option_disabled_entry_el.innerHTML = "Option: disabled";
        setting_option_disabled_entry_el.addEventListener("click", (e) => {
            console.log("local_waypoints setting CLICKED: disabled", local_waypoints_key, e);
            if (!waypoints_info.active) {
                return; // waypoints are already disabled, so ignore
            }
            this.wp_unselect(local_waypoints_key);
            e.target.className = "setting_option_entry_selected";
            waypoints_info.active = false;
            this.store_local_waypoints_info();
            this.planner.local_waypoints_set_inactive(local_waypoints_key);
            this.planner.local_waypoints_hide(local_waypoints_key);
        });
        setting_option_disabled_el.appendChild(setting_option_disabled_entry_el);
        setting_options_el.appendChild(setting_option_disabled_el);

        let setting_option_delete_el = document.createElement("div");
        setting_option_delete_el.className = "setting_option";
        let setting_option_delete_entry_el = document.createElement("div");
        setting_option_delete_entry_el.id = "setting_waypoints_" + local_waypoints_key + "_delete";
        setting_option_delete_entry_el.className = "setting_option_entry";
        setting_option_delete_entry_el.innerHTML = "Option: DELETE";
        setting_option_delete_entry_el.addEventListener("click", (e) => {
            this.wp_unselect(local_waypoints_key);
            e.target.className = "setting_option_entry_selected";
            if (confirm("Are you sure you want to remove "+waypoints_info.local_waypoints_key)) {
                console.log("DELETE "+waypoints_info.local_waypoints_key);
                // hide current entry in settings
                setting_el.style.display = "none";
                // If waypoints are currently displayed, remove the marker layer
                if (this.planner.local_waypoints_loaded_status(local_waypoints_key)) {
                    this.planner.local_waypoints_hide(local_waypoints_key);
                }
                // delete the local_waypoints object
                this.planner.local_waypoints_delete(local_waypoints_key);
                // remove the waypoints from localStorage
                window.localStorage.removeItem(local_waypoints_key);
                // remove the entry from local_waypoints_info
                let index = null;
                for (let i=0; i<this.local_waypoints_info.length; i++) {
                    if (this.local_waypoints_info[i].local_waypoints_key == local_waypoints_key) {
                        index = i;
                        break;
                    }
                }
                if (index != null) {
                    this.local_waypoints_info.splice(index,1);
                }
                // save waypoints_info change to localStorage
                this.store_local_waypoints_info();
            } else {
                e.target.style.backgroundColor = "white";
                if (waypoints_info.active) {
                    this.select(setting_option_enabled_entry_el);
                } else {
                    this.select(setting_option_disabled_entry_el);
                }
            }
        });
        setting_option_delete_el.appendChild(setting_option_delete_entry_el);
        setting_options_el.appendChild(setting_option_delete_el);

        if (waypoints_info.active) {
            setting_option_enabled_entry_el.className = "setting_option_entry_selected";
        } else {
            setting_option_disabled_entry_el.className = "setting_option_entry_selected";
        }

        setting_el.appendChild(setting_options_el);
        this.settings_el.appendChild(setting_el);
    }

    // remove highlighting from all the current local waypoint options
    wp_unselect(key) {
        for (let option_name of ["enabled", "disabled", "delete"]) {
            let el = document.getElementById("setting_waypoints_" + key + "_" + option_name);
            el.className = "setting_option_entry";
        }
    }

    set_settings_local_waypoints(key, waypoints_obj) {
        try {

            // Persist the waypoints in localStorage
            let local_waypoints_str = waypoints_obj.dumps();
            window.localStorage.setItem(this.SETTINGS_VAR_PREFIX+'waypoints_'+key, local_waypoints_str);

            // Set/Store an updated local_waypoints_info
            let new_local_waypoints_info = [];
            for (let i=0; i<this.local_waypoints_info.length; i++) {
                let entry = this.local_waypoints_info[i];
                if (entry.local_waypoints_key != key) {
                    new_local_waypoints_info.push(entry);
                }
            }
            new_local_waypoints_info.push({ local_waypoints_key: key, active: true });
            this.local_waypoints_info = new_local_waypoints_info;
            this.store_local_waypoints_info();

        } catch (e) {
            console.log("Bad data given for local_waypoints setting", key, waypoints_obj, e);
            alert("A problem occurred with the Local Waypoints data");
        }
    }

    store_local_waypoints_info() {
        try {

            let local_waypoints_info_str = JSON.stringify(this.local_waypoints_info);
            window.localStorage.setItem(this.SETTINGS_VAR_PREFIX+'local_waypoints_info', local_waypoints_info_str);
        } catch(e) {
            console.log("Bad data given for local_waypoints_info setting", this.local_waypoints_info, e);
            alert("A problem occurred with the Local Waypoints info");
        }
    }
}
"use strict"

// ******************************************************************************
// ***********   Task class                **************************************
// ******************************************************************************

class B21_Task {
    constructor(planner) {
        const task = this;
        task.planner = planner; // Reference to B21TaskPlanner instance
        task.task_info_header_el = document.getElementById("task_info_header");
        task.task_info_content_el = document.getElementById("task_info_content");
        task.init();
    }

    init() {
        const task = this;
        task.name = null;           // From filename
        task.title = null;          // From MSFS PLN
        task.description = null;    // From MSFS PLN
        task.waypoints = [];        // Ordered list of waypoints
        task.index = null;          // Index of current waypoint
        task.start_index = null;    // Index of start waypoint
        task.finish_index = null;   // Index of finish waypoint
        task.start_index_set = null;    // Will be set to TRUE if user has assigned start wp
        task.finish_index_set = null;   // Will be set to TRUE if user has assigned finish wp
        task.is_nb21 = false;        // Task loaded from NB21 Logger
        task.is_local = false;        // Task loaded DIRECTLY from NB21 Logger
        task.task_distance_m = 123456;
        task.aat_min_time_s = null; // minimum time for an AAT task in seconds

        // task bounds
        task.min_lat = 90;
        task.min_lng = 180;
        task.max_lat = -90;
        task.max_lng = -180;

        task.task_info_header_el.style.display = "none";
    }

    // Return true if a task is actually available
    available() {
        const task = this;
        return task.waypoints.length > 0;
    }

    // isNB21 returns true if this task was loaded from the NB21 Logger, or can be SET by passing true/false
    isNB21(set_value) {
        const task = this;
        if (set_value != null) {
            task.is_nb21 = set_value;
        }
        return task.is_nb21;
    }

    // isLocal returns true if this task was loaded DIRECTLY from the NB21 Logger, or can be SET by passing true/false
    isLocal(set_value) {
        const task = this;
        if (set_value != null) {
            task.is_local = set_value;
        }
        return task.is_local;
    }

    // isAAT returns true if this task has an AAT waypoint
    isAAT() {
        const task = this;

        for (let wp_index = 1; wp_index < task.waypoints.length; wp_index++) {
            if (task.waypoints[wp_index].isAAT()) {
                return true;
            }
        }
        return false;
    }

    // Initialize this task using a MSFS Flight Plan
    load_pln_str(pln_str, name) {
        const task = this;
        console.log(">>>>>>task.load_pln_str", name);
        task.name = name.slice(0, name.lastIndexOf('.'));
        let msfs_pln = new B21FilePLN(task);
        // Have msfs_pln update this task
        msfs_pln.load_pln_str(pln_str);
        // Fix up the start and finish waypoints if the PLN didn't mark those.
        console.log(">>>>>>>loaded PLN, start_index=", task.start_index);
        task.fix_start_finish();
        task.update_display();
    }

    fix_start_finish() {
        const task = this;
        if (task.start_index == null && task.waypoints.length > 0) {
            task.start_index = 0;
        }
        if (task.finish_index == null && task.waypoints.length > 1) {
            task.finish_index = task.waypoints.length - 1;
        }
    }

// Initialize this task using an XCsoar TSK Flight Plan
    load_tsk_str(tsk_str, name) {
        const task = this;
        console.log("task.load_tsk_str", name);
        task.name = name.slice(0, name.lastIndexOf('.'));
        let xcsoar_tsk = new B21_XCsoar_TSK(this);
        // Hav xcsoar_tsk update this task
        xcsoar_tsk.load_tsk_str(tsk_str);
        task.update_display();
    }

    load_task_from_tracklog(tracklog) {
        const task = this;

        console.log(`B21_Task.load_task_from_tracklog ${tracklog.filename}`);
        if (!tracklog.hasTask) {
            console.warn(`B21_Task error loading task from ${tracklog.filename}`);
            return;
         }

        task.reset();

        tracklog.load_task(task);
        task.fix_start_finish();
        console.log(`B21_Task.load_task_from_tracklog ${tracklog.filename} calling tracklog.score_task()`);
        //tracklog.score_task();
        task.update_display();
    }

    // Save a MSFS FlightPlan
    save_file_pln() {
        const task = this;
        let msfs_pln = new B21FilePLN(task);
        let filename;
        if (task.name != null) {
            filename = task.name + ".pln";
         } else {
            filename = msfs_pln.get_title() + ".pln";
         }
        let text = msfs_pln.get_text();

        let element = document.createElement('a');
        element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
        element.setAttribute('download', filename);

        element.style.display = 'none';
        document.body.appendChild(element);

        element.click();

        document.body.removeChild(element);
    }

    // Save a XCsoar Task
    save_file_tsk() {
        const task = this;
        let xcsoar_tsk = new B21_XCsoar_TSK(this);
        let filename = xcsoar_tsk.get_title() + ".tsk";
        let text = xcsoar_tsk.get_text();

        let element = document.createElement('a');
        element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
        element.setAttribute('download', filename);

        element.style.display = 'none';
        document.body.appendChild(element);

        element.click();

        document.body.removeChild(element);
    }

    // Save a KML Task
    save_file_kml() {
        const task = this;
        console.log("Task saving KML file");
        let file_kml = new B21_FILE_KML(this);
        let filename = file_kml.get_title() + ".kml";
        let text = file_kml.get_text();

        let element = document.createElement('a');
        element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
        element.setAttribute('download', filename);

        element.style.display = 'none';
        document.body.appendChild(element);

        element.click();

        document.body.removeChild(element);
    }

    current_wp() {
        const task = this;
        return task.waypoints[task.index];
    }

    // *****************************************************
    //   edit mode
    // *****************************************************

    set_edit_mode() {
        const task = this;
        for (let i=0; i<task.waypoints.length; i++) {
            let wp = task.waypoints[i];
            wp.set_edit_mode(wp);
        }
    }

    reset_edit_mode() {
        const task = this;
        for (let i=0; i<task.waypoints.length; i++) {
            let wp = task.waypoints[i];
            wp.reset_edit_mode(wp);
        }
    }

    get_task_distance_m() {
        const task = this;
        let start_index = (task.start_index != null) ? task.start_index : 0;
        let finish_index = (task.finish_index != null && task.finish_index < task.waypoints.length) ? task.finish_index : task.waypoints
            .length - 1;
        let distance_m = 0;
        for (let i = start_index + 1; i <= finish_index; i++) {
            distance_m += task.waypoints[i].leg_distance_m;
        }
        return distance_m;
    }

    get_aat_min_distance_m() {
        const task = this;
        let start_index = (task.start_index != null) ? task.start_index : 0;
        let finish_index = (task.finish_index != null && task.finish_index < task.waypoints.length) ? task.finish_index : task.waypoints
            .length - 1;
        let distance_m = 0;
        let p0 = task.waypoints[start_index].aat_position_min;
        for (let i = start_index + 1; i <= finish_index; i++) {
            let p1 = task.waypoints[i].aat_position_min;
            distance_m += Geo.get_distance_m(p0,p1);
            p0 = p1;
        }
        return distance_m;
    }

    get_aat_max_distance_m() {
        const task = this;
        let start_index = (task.start_index != null) ? task.start_index : 0;
        let finish_index = (task.finish_index != null && task.finish_index < task.waypoints.length) ? task.finish_index : task.waypoints
            .length - 1;
        let distance_m = 0;
        let p0 = task.waypoints[start_index].aat_position_max;
        for (let i = start_index + 1; i <= finish_index; i++) {
            let p1 = task.waypoints[i].aat_position_max;
            distance_m += Geo.get_distance_m(p0,p1);
            p0 = p1;
        }
        return distance_m;
    }

    // Add a WP from a point clicked on the map
    add_point_wp(position) {
        const task = this;
        //task.index = task.waypoints.length;
        let wp_index = task.index == null ? 0 : task.index + 1;
        console.log(">>>>>>>task adding point with index", wp_index);
        let wp = new B21_WP(task.planner);
        wp.new_point(wp_index, position);
        task.index = wp_index;
        //task.waypoints.push(wp);
        //INSERT this wp into waypoints at index
        task.waypoints.splice(task.index, 0, wp);
        if (wp.index > 0) {
            task.add_line(task.waypoints[wp.index - 1], wp);
        }

        // Fixup start_index
        if (task.start_index != null && wp_index <= task.start_index) {
            task.start_index++;
        }

        // Fixup finish_index
        if (task.finish_index != null && wp_index <= task.finish_index) {
            task.finish_index++;
        }

        return wp;
    }

    is_msfs_airport(type) {
        const task = this;
        return type != null && type.includes("msfs") && type.includes("airport")
    }

    // User has clicked an airport symbol on the map
    add_new_poi(position, type, poi_info) {
        const task = this;
        // poi_info = {ident,name,alt_m,runways}
        console.log(">>>>>>>task.add_new_poi ", position, type, poi_info);
        let wp = task.add_point_wp(position);

        if (wp.index == 0 && !task.is_msfs_airport(type)) {
            alert("Hint: your first (and last) WP should be a MSFS airport (blue circle on map)");
        }

        wp.alt_m = poi_info["alt_m"];
        if (wp.alt_m == 0) {
            task.planner.request_alt_m(wp, position, wp.request_alt_m_ok, wp.request_alt_m_fail);
        }
        if (task.is_msfs_airport(type) && (task.planner.settings.soaring_task == 0 || wp.index == 0 || wp.index == task.waypoints
                .length - 1)) {
            wp.name = poi_info["name"];
            wp.data_icao = poi_info["ident"];
            wp.icao = wp.data_icao;
            console.log("task.add_new_poi added with icao " + wp.icao);
        } else {
            if (task.is_msfs_airport(type)) {
                wp.name = poi_info["ident"] + " " + poi_info["name"];
            } else {
                wp.name = poi_info["name"];
            }
            wp.icao = null;
            wp.alt_m_updated = true;
        }
        if (poi_info["runways"] != null && poi_info["runways"] != "") {
            let runways_list = poi_info["runways"].split(" ");
            wp.runways = runways_list;
        }
        console.log("airport added, scrubbing earlier airports WP name/icao")
            // for SOARING tasks, scrub the icao code from earlier airports in task except departure airport
        if (task.planner.settings.soaring_task == 1) {
            task.scrub_intermediate_icao();
        }

        console.log(`Task.add_new_poi() with task.name=${task.name}`);
        if (task.name == null) {
            task.name = wp.name;
            console.log(`Task.add_new_poi() task.name updated=${task.name}`);
        }

        task.update_display();

        task.planner.map.closePopup();

        wp.display_menu(wp);
    }

    scrub_intermediate_icao() {
        const task = this;
        console.log("Scrubbing intermediate icao codes");
        for (let i = 1; i < task.waypoints.length - 1; i++) {
            let task_wp = task.waypoints[i];
            console.log("checking WP", i, task_wp.name);
            if (task_wp.icao != null) {
                console.log("Fixing airport WP", task_wp.name);
                task_wp.name = task_wp.icao + " " + task_wp.name;
                task_wp.icao = null;
                task_wp.alt_m_updated = true; // So planner will append +(alt_m) to encoded wp name
            }
        }
    }

    update_display() {
        const task = this;
        console.log("B21_Task.update_display()");
        task.update_bounds();
        //console.log(`B21_Task.update_display bounds min_lat:${task.min_lat}`);
        task.update_waypoints();
        task.update_waypoint_icons();
        task.draw();
        //task.display_task_info();
        task.planner.show_task_info();
    }

    append_current_wp() {
        const task = this;
        console.log("append_current_wp() icao=", task.current_wp().icao);
        let next_index = task.waypoints.length;
        console.log("task append existing wp", next_index);
        let wp = task.current_wp().copy(next_index);
        task.waypoints.push(wp);
        console.log("append_current_wp() pushed new wp", wp);
        if (task.planner.settings.soaring_task == 1 && wp.icao != null) {
            task.scrub_intermediate_icao();
        }
        task.index = next_index;
        let non_task = task.waypoints[wp.index - 1].is_task_finish();
        task.add_line(task.waypoints[wp.index - 1], wp, non_task);
        task.update_waypoints();
        task.update_waypoint_icons();
        task.display_task_info();
        return wp;
    }

    // Parse soaring-encoded WP name, e.g.
    // *Mifflin+813|6000/1000x500 => Mifflin elevation=813ft, max_alt=6000ft, min_alt=1000ft, radius=500m
    // The "x" (radius) must come after either "+" or "|", so +813x500 is ok.
    decode_wp_name(wp) {
        const task = this;
        //console.log("decoding", wp.index, wp.name);
        if (wp.name == null) {
            return;
        }
        // Handle START/FINISH
        if (wp.name.toLowerCase().startsWith("start")) {
            task.start_index = wp.index;
        } else if (wp.name.toLowerCase().startsWith("finish")) {
            task.finish_index = wp.index;
        } else if (wp.name.startsWith("*")) {
            if (task.start_index == null) {
                //console.log("Setting " + wp.name + " as START");
                task.start_index_set = true; // Confirm USER has explicitly set start WP
                task.start_index = wp.index;
            } else {
                //console.log("Setting " + wp.name + " as FINISH");
                task.finish_index_set = true; // Confirm USER has explicitly set finish WP
                task.finish_index = wp.index;
            }
            wp.name = wp.name.slice(1);
        }

        // Handle WP ELEVATION
        let wp_extra = "";
        let wp_plus = wp.name.split('+');
        if (wp_plus.length > 1) {
            wp_extra = wp_plus[wp_plus.length - 1];
            let alt_feet = parseFloat(wp_extra);
            if (!isNaN(alt_feet)) {
                wp.alt_m = alt_feet / task.planner.M_TO_FEET;
                wp.alt_m_updated = true;
            }
        }
        let wp_bar = wp.name.split("|");
        if (wp_bar.length > 1) {
            wp_extra = wp_bar[wp_bar.length - 1];
            let max_alt_feet = parseFloat(wp_extra);
            console.log("parsed max_alt_feet from", wp_extra);
            if (!isNaN(max_alt_feet)) {
                console.log("parse max_alt_feet", max_alt_feet);
                wp.max_alt_m = max_alt_feet / task.planner.M_TO_FEET;
            }
        }
        let wp_slash = wp_extra.split("/");
        if (wp_slash.length > 1) {
            let min_alt_feet = parseFloat(wp_slash[wp_slash.length - 1]);
            if (!isNaN(min_alt_feet)) {
                console.log("parse min_alt_feet", min_alt_feet);
                wp.min_alt_m = min_alt_feet / task.planner.M_TO_FEET;
            }
        }
        // Only look for an "x" in the
        //console.log("wp_extra is", wp_extra);
        let wp_x = wp_extra.split("x");
        if (wp_x.length > 1) {
            let wp_width_m = parseFloat(wp_x[wp_x.length - 1]);
            if (!isNaN(wp_width_m)) {
                let wp_radius_m = wp_width_m / 2;
                //console.log("parse wp_radius_m", wp_radius_m);
                wp.radius_m = wp_radius_m;
            }
        }

        // Set isAAT value for the WP if this wp is an AREA
        wp.isAAT(wp_extra.includes(";AAT;") || wp_extra.includes(";AAT") && wp.index != task.start_index);

        // Set AAT task.aat_min_time_s if it's encoded onto the start WP
        if (wp.index == task.start_index && wp_extra.includes(";AAT")) {
            console.log("Task.decode_wp_name() AAT info on Start");
            let pos = wp_extra.indexOf(";AAT");
            let aat_info = wp_extra.slice(pos,pos+10);
            if (aat_info.slice(6,7) == ":" && aat_info.slice(9,10) == ";") {
                task.aat_min_time_s = B21_Utils.hh_mm_to_time_s(aat_info.slice(4,9));
            }
        }

        // Trim wp.name to shortest before "+" or "|"
        wp.name = wp.name.split("+")[0].split("|")[0];
    }

    // Return WP name with appended soaring parameters e.g. *Mifflin+813|5000-1000x1000
    // *=start/finish, +=elevation(feet), |=max_alt(feet), -=min_alt(feet), x=radius(meters)
    get_encoded_name(wp) {
        const task = this;
        let start = "";
        if (wp.index == task.start_index || wp.index == task.finish_index) {
            start = "*";
        }
        let encoded_name = start + wp.get_name();
        let extra = false; // 'extra' flags that a "|" has already been added to mark the extended info
        if (wp.alt_m_updated && wp.icao == null) {
            extra = true;
            encoded_name += "+" + (wp.alt_m * task.planner.M_TO_FEET).toFixed(0);
        }
        if (wp.max_alt_m != null) {
            extra = true;
            encoded_name += "|" + (wp.max_alt_m * task.planner.M_TO_FEET).toFixed(0);
        }
        if (wp.min_alt_m != null) {
            if (!extra) {
                encoded_name += "|";
                extra = true;
            }
            encoded_name += "/" + (wp.min_alt_m * task.planner.M_TO_FEET).toFixed(0);
        }
        if (wp.radius_m != null) {
            if (!extra) {
                encoded_name += "|";
                extra = true;
            }
            encoded_name += "x" + (wp.radius_m * 2).toFixed(0);
        }
        if (wp.isAAT()) {
            if (!extra) {
                encoded_name += "|";
                extra = true;
            }
            encoded_name += ";AAT;";
        }
        if (wp.index == task.start_index && task.isAAT() && task.aat_min_time_s != null) {
            let min_time_hh_mm = B21_Utils.hh_mm_from_ts_delta(task.aat_min_time_s);
            if (min_time_hh_mm != null) {
                encoded_name += ";AAT"+min_time_hh_mm+";";
            }
        }
        return encoded_name;
    }

    // Return 8-char ICAO encoded soaring parameters e.g. *Mifflin+813|5000-1000x1000
    // char   0: A-Z, S=start, F=finish
    // char 1-3: base 36 elevation in feet 0.. 46656
    // char 4,5: base 36 radius in meters x 100
    // char   6: min alt feet (see alt lookup) Z=AAT
    // char   7: max alt feet (see alt lookup)
    get_encoded_icao(wp) {
        const task = this;

        // First char unique letter for WP, S=start, F=finish
        let first_char = "0";
        const FIRST_CHARS = "ABCDEGHIJKLMNOPQRTUVWXYZ"; // excludes S,F for start/finish
        if (wp.index == task.start_index) {
            first_char = "S";
        } else if (wp.index == task.finish_index) {
            first_char = "F";
        } else {
            first_char = FIRST_CHARS[wp.index % FIRST_CHARS.length];
        }

        // Elevation feet chars XXX in base 36
        let elev_chars = "000";
        if (wp.alt_m != null) {
            elev_chars = ("000"+task.encode_base36(wp.alt_m * task.planner.M_TO_FEET)).slice(-3);
        }

        // Radius meters / 100 XX in base 36
        let rad_chars = "00"
        if (wp.radius_m != null) {
            rad_chars = ("00"+task.encode_base36(wp.radius_m / 100)).slice(-2);
        }

        // Min alt feet using lookup table
        let min_chars = "0";
        if (wp.min_alt_m != null) {
            min_chars = ("0"+task.encode_alt_lookup(wp.min_alt_m * task.planner.M_TO_FEET)).slice(-1);
        }

        // Max alt feet using lookup table
        let max_chars = "0";
        if (wp.max_alt_m != null) {
            max_chars = ("0"+task.encode_alt_lookup(wp.max_alt_m * task.planner.M_TO_FEET)).slice(-1);
        }

        // Set min_alt to "Z" if this WP is AAT
        if (wp.isAAT()) {
            min_chars = "Z";
        }

        return first_char + elev_chars + rad_chars + min_chars + max_chars;
    }

    encode_base36(n) {
        const task = this;
        const LETTERS = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
        let remainder = Math.round(n);
        if (remainder < 0) {
            return "0";
        }
        let encoded_str = "";
        while (remainder > 0) {
            let index = remainder % LETTERS.length;
            encoded_str = LETTERS[index] + encoded_str;
            remainder = Math.floor(remainder / LETTERS.length);
        }
        return encoded_str;
    }

    // base36 -> decimal e.g. 40G -> 5200
    decode_base36(str) {
        const task = this;

        if (str == null || str == "") {
            return 0;
        }

        const LETTERS = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
        let result = 0;
        let multiplier = 1;
        for (let i=str.length-1; i >= 0; i--) {
            let decimal = LETTERS.indexOf(str[i]);
            if (decimal < 0) {
                return 0;
            }
            result = result + decimal * multiplier;
            multiplier = multiplier * LETTERS.length;
        }
        return result;
    }

    encode_alt_lookup(alt_feet) {
        const task = this;
        const LETTERS = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
        const alt_rounded = Math.round(alt_feet);
        if ( alt_rounded <= 5000) {
            return LETTERS[Math.round(alt_rounded / 500)];
        }
        if ( alt_rounded > 30000) {
            return "Z";
        }
        return LETTERS[10 + Math.round((alt_rounded - 5000)/1000)];
    }

    decode_alt_lookup(str) {
        const task = this;
        const LETTERS = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
        let index = LETTERS.indexOf(str);
        if (index < 0) {
            return 0;
        }
        if (index <= 10) {
            return index * 500;
        } else {
            return index * 1000 - 5000;
        }
    }

    // Decode the start/finish, elevation (feet), radius(m), min_alt(ft), max_alt(ft), aat(min_alt=Z)
    // from encoded ICAO.
    decode_icao(wp) {
        const task = this;
        let icao = wp.encoded_icao;
        if (icao == null || icao.length != 8) {
            return;
        }

        // Start/finish
        if (icao[0] == "S") {
            task.start_index_set = true; // Confirm USER has explicitly set start WP
            task.start_index = wp.index;
        } else if (icao[0] == "F") {
            task.finish_index_set = true; // Confirm USER has explicitly set finish WP
            task.finish_index = wp.index;
        }

        // Handle WP ELEVATION "XXX" feet base 36
        let elev_str = icao.slice(1,4);
        let alt_feet = task.decode_base36(elev_str);
        wp.alt_m = alt_feet / task.planner.M_TO_FEET;
        wp.alt_m_updated = true;

        // Handle RADIUS "XX" meters x100 base 36
        let rad_str = icao.slice(4,6)
        let rad_m = task.decode_base36(rad_str) * 100;
        if (rad_m == 0) {
            wp.radius_m = null;
        } else {
            wp.radius_m = rad_m;
        }

        // Handle MIN ALT via letter '0'..'A' in 500', after that 1000' steps. Z = AAT
        let min_alt_str = icao.slice(6,7);
        let min_alt_feet = task.decode_alt_lookup(min_alt_str);
        if (min_alt_feet == 0) {
            wp.min_alt_m = null;
        } else {
            wp.min_alt_m = min_alt_feet / task.planner.M_TO_FEET;
        }

        // Handle MAX ALT via letter '0'..'A' in 500', after that 1000' steps
        let max_alt_str = icao.slice(7,8);
        let max_alt_feet = task.decode_alt_lookup(max_alt_str);
        if (max_alt_feet == 0) {
            wp.max_alt_m = null;
        } else {
            wp.max_alt_m = max_alt_feet / task.planner.M_TO_FEET;
        }

        // Handle AAT
        if (min_alt_str=="Z" && wp.index != task.start_index && wp.index != task.finish_index) {
            wp.min_alt_m = null;
            wp.isAAT(true);
        }
    }

    // Update the .leg_distance_m for each waypoint around task
    update_waypoints() {
        const task = this;
        //console.log("update_waypoints()");
        for (let i = 0; i < task.waypoints.length; i++) {
            const wp = task.waypoints[i];
            wp.index = i;
            if (i > 0) {
                const prev_wp = task.waypoints[i - 1];
                wp.update(prev_wp);
            }
        }
    }

    update_waypoint_icons() {
        const task = this;
        //console.log("Task.update_waypoint_icons");
        for (let i = 0; i < task.waypoints.length; i++) {
            let wp = task.waypoints[i];
            wp.update_icon(wp);
        }
    }

    update_elevations() {
        const task = this;
        for (let i = 0; i < task.waypoints.length; i++) {
            let wp = task.waypoints[i];
            if (wp.data_icao == null) { // Only request elevations for non-airports
                task.planner.request_alt_m(wp, wp.position, wp.request_alt_m_ok, wp.request_alt_m_fail);
            }
        }
    }

    // Calculate the SW & NE corners of the task, so map can be zoomed to fit.
    update_bounds() {
        const task = this;
        // task bounds
        task.min_lat = 90;
        task.min_lng = 180;
        task.max_lat = -90;
        task.max_lng = -180;
        for (let i = 0; i < task.waypoints.length; i++) {
            let position = task.waypoints[i].position;
            //console.log("update_bounds",i,position.lat, position.lng);
            if (position.lat < task.min_lat) {
                task.min_lat = position.lat;
            }
            if (position.lat > task.max_lat) {
                task.max_lat = position.lat;
            }
            if (position.lng < task.min_lng) {
                task.min_lng = position.lng;
            }
            if (position.lng > task.max_lng) {
                task.max_lng = position.lng;
            }
        }
        console.log("new map bounds ", task.min_lat, task.min_lng, task.max_lat, task.max_lng);
    }

    // Add a straight line between wp1 and wp2
    // This line is multiple polylines that all should be drawn (allowing an alternate color dash if needed).
    add_line(wp1, wp2 , non_task) {
        const task = this;
        //console.log(`add_line ${wp1.name}..${wp2.name} non_task=${non_task} `);
        wp2.remove_line(wp2);
        let latlngs = [wp1.position, wp2.position];
        let color1 = task.planner.settings.task_line_color_1;
        if (color1 == null || color1 == "") {
            color1 = 'red';
        }
        let line1_options = {
            color: color1
        };
        let color2 = non_task ? "white" : task.planner.settings.task_line_color_2;
        if (color2 != null && color2 != "" && color2 != "none") {
            line1_options["dashArray"] = '12 12';
            line1_options["lineCap"] = 'butt';
        }
        wp2.task_line = [L.polyline(latlngs, line1_options)];

        if (color2 != null && color2 != "" && color2 != "none") {
            wp2.task_line.push(L.polyline(latlngs, {
                color: color2,
                dashArray: '12 12',
                dashOffset: '12',
                lineCap: 'butt'
            }));
        }
        for (let i = 0; i < wp2.task_line.length; i++) {
            wp2.task_line[i].addTo(task.planner.map);
        }
    }

    remove_marker(wp) {
        const task = this;
        if (wp.marker != null) {
            wp.marker.remove(task.planner.map);
            wp.marker = null;
        }
    }

    add_sector(wp) {
        const task = this;
        task.remove_sector(wp);
        if (wp.index == task.start_index) {
            // Sector = START LINE
            //console.log("add_sector START", wp.radius_m);
            let radius_m = wp.radius_m == null ? wp.DEFAULT_START_RADIUS_M : wp.radius_m;
            let direction_deg = 0;
            if (wp.index < task.waypoints.length - 1) {
                direction_deg = (task.waypoints[wp.index + 1].leg_bearing_deg + 180) % 360;
            }
            wp.sector = L.semiCircle(wp.position, {
                    radius: radius_m,
                    color: 'red',
                    interactive: false
                })
                .setDirection(direction_deg, 180);
        } else if (wp.index == task.finish_index) {
            // Sector = FINISH LINE
            //console.log("add_sector FINISH", wp.radius_m);
            let radius_m = wp.radius_m == null ? wp.DEFAULT_FINISH_RADIUS_M : wp.radius_m;
            let direction_deg = 0;
            if (wp.index > 0) {
                direction_deg = wp.leg_bearing_deg;
            }
            wp.sector = L.semiCircle(wp.position, {
                    radius: radius_m,
                    color: 'red',
                    interactive: false
                })
                .setDirection(direction_deg, 180);
        } else {
            let sector_color = wp.isAAT() ? "green" : "red";
            let radius_m = wp.radius_m == null ? wp.DEFAULT_RADIUS_M : wp.radius_m;
            // Sector = WAYPOINT
            wp.sector = L.circle(wp.position, {
                radius: radius_m,
                color: sector_color,
                weight: 1,
                interactive: false
            });
        }
        wp.sector.addTo(task.planner.map);
    }

    remove_sector(wp) {
        const task = this;
        if (wp.sector != null) {
            wp.sector.remove(task.planner.map);
            wp.sector = null;
        }
    }

    draw() {
        const task = this;
        console.log("Task.draw()");
        for (let i = 0; i < task.waypoints.length; i++) {
            let wp = task.waypoints[i];
            // Set current WP marker to foreground
            if (i == task.index) {
                wp.marker.setZIndexOffset(1000);
            } else {
                wp.marker.setZIndexOffset(0);
            }
            // Draw task line
            if (wp.task_line != null) {
                wp.remove_line(wp);
            }
            let non_task = ( i==1 && task.waypoints[0].icao != null ) ||
                           ( i == task.waypoints.length-1 && task.waypoints[task.waypoints.length-1].icao != null );
            //console.log("task.draw() non_task = "+non_task);
            if (i > 0) {
                task.add_line(task.waypoints[i - 1], task.waypoints[i], non_task);
            }
            // Draw WP circle, start, finish lines
            if (wp.sector != null) {
                task.remove_sector(wp);
            }
            //if (wp.radius_m != null || wp.index == task.start_index || wp.index == task.finish_index) {
                task.add_sector(wp);
            //}

        }
    }

    // *********************************************************************
    // ********  Task info                   *******************************
    // *********************************************************************

    hide_task_info() {
        const task = this;
        task.task_info_header_el.style.display = "none";
        task.task_info_content_el.style.display = "none";
    }

    // Update the 'task_info' element with the table of waypoint data
    display_task_info() {
        const task = this;
        console.log("Task.display_task_info()");

        B21_Utils.clear_div(task.task_info_content_el);
        task.task_info_header_el.style.display = "none";
        task.task_info_content_el.style.display = "block";
        task.remove_aat_lines();

        if (task.available()) {
            if (task.name==null) {
                task.task_info_header_el.style.display = "none";
            } else {
                task.display_task_info_header();
            }
            task.task_info_content_el.style.display = "block";
        } else {
            task.task_info_header_el.style.display = "none";
            task.task_info_content_el.style.display = "none";
            return;
        }

        let task_info_table_el = document.createElement("table");
        task_info_table_el.id = "task_info_table";

        let distance_units_str = "km";
        if (task.planner.settings.distance_units == "miles") {
            distance_units_str = "miles";
        }

        let altitude_units_str = "m";
        if (task.planner.settings.altitude_units == "feet") {
            altitude_units_str = "feet";
        }

        // Column headings
        let headings_el = document.createElement("tr");
        headings_el.id = "task_info_headings";
        let heading1 = document.createElement("th"); // WP #
        headings_el.appendChild(heading1);
        let heading2 = document.createElement("th"); // WP name
        headings_el.appendChild(heading2);
        let heading3 = document.createElement("th"); // WP alt
        heading3.innerHTML = altitude_units_str;
        headings_el.appendChild(heading3);
        let heading4 = document.createElement("th"); // leg bearing
        heading4.innerHTML = "deg(T)";
        headings_el.appendChild(heading4);
        let heading5 = document.createElement("th"); // leg distance
        heading5.innerHTML = distance_units_str;
        headings_el.appendChild(heading5);
        let heading6 = document.createElement("th"); // buttons
        headings_el.appendChild(heading6);

        task_info_table_el.appendChild(headings_el);

        // Add waypoints
        for (let i = 0; i < task.waypoints.length; i++) {
            task.display_task_waypoint(task_info_table_el, task.waypoints[i]);
        }
        task.task_info_content_el.appendChild(task_info_table_el);


        // Display task distance

        let distance_el = document.createElement("div");
        distance_el.className = "task_info_distance";

        // Regular task distance
        let task_distance_el = document.createElement("div");
        let distance_m = task.get_task_distance_m();
        let distance_str = (distance_m / 1000).toFixed(1);
        if (task.planner.settings.distance_units == "miles") {
            distance_str = (distance_m * task.planner.M_TO_MILES).toFixed(1);
        }
        distance_str = `${distance_str} ${distance_units_str}`;
        task_distance_el.innerHTML = "Task distance: " + distance_str;
        distance_el.appendChild(task_distance_el);

        // AAT min/max distances
        if (task.isAAT() &&
            task.start_index != null && task.finish_index != null && task.finish_index - task.start_index >= 2) {

            task.update_aat_distance();

            let aat_min_check_el = document.createElement("input");
            let aat_max_check_el = document.createElement("input");

            // Display AAT min distance
            let aat_min_distance_el = document.createElement("div");
            aat_min_distance_el.className = "task_info_aat_min_distance";
            aat_min_check_el.setAttribute("type","checkbox");
            aat_min_check_el.setAttribute("title","draw");
            aat_min_check_el.addEventListener("change", () => {task.task_info_aat_min_check(aat_min_check_el, aat_max_check_el);});
            aat_min_distance_el.appendChild(aat_min_check_el);
            distance_m = task.get_aat_min_distance_m();
            distance_str = (distance_m / 1000).toFixed(1);
            if (task.planner.settings.distance_units == "miles") {
                distance_str = (distance_m * task.planner.M_TO_MILES).toFixed(1);
            }
            distance_str = `${distance_str} ${distance_units_str}`;
            let aat_min_text_el = document.createTextNode("AAT min: "+distance_str);
            aat_min_distance_el.appendChild(aat_min_text_el);
            distance_el.appendChild(aat_min_distance_el);

            // Display AAT max distance
            let aat_max_distance_el = document.createElement("div");
            aat_max_distance_el.className = "task_info_aat_max_distance";
            aat_max_check_el.setAttribute("type","checkbox");
            aat_max_check_el.setAttribute("title","draw");
            aat_max_check_el.addEventListener("change", () => {task.task_info_aat_max_check(aat_min_check_el, aat_max_check_el);});
            aat_max_distance_el.appendChild(aat_max_check_el);
            distance_m = task.get_aat_max_distance_m();
            distance_str = (distance_m / 1000).toFixed(1);
            if (task.planner.settings.distance_units == "miles") {
                distance_str = (distance_m * task.planner.M_TO_MILES).toFixed(1);
            }
            distance_str = `${distance_str} ${distance_units_str}`;
            let aat_max_text_el = document.createTextNode("AAT max: "+distance_str);
            aat_max_distance_el.appendChild(aat_max_text_el);
            distance_el.appendChild(aat_max_distance_el);
        }
        task.task_info_content_el.appendChild(distance_el);
    }

    task_info_aat_min_check(aat_min_check_el, aat_max_check_el) {
        const task = this;
        console.log(`task_info_aat_min_check() checked=${aat_min_check_el.checked}`);
        aat_max_check_el.checked = false;
        if (aat_min_check_el.checked) {
            task.draw_min_aat_distance();
        } else {
            task.remove_aat_lines();
        }
    }

    task_info_aat_max_check(aat_min_check_el, aat_max_check_el) {
        const task = this;
        console.log("task_info_aat_max_check() checked=${aat_min_check_el.checked}");
        aat_min_check_el.checked = false;
        if (aat_max_check_el.checked) {
            task.draw_max_aat_distance();
        } else {
            task.remove_aat_lines();
        }
    }


    display_task_info_header() {
        const task = this;
        //console.log(`display_task_info_header() aat_min_time_s=${task.aat_min_time_s}`);
        B21_Utils.clear_div(task.task_info_header_el);
        // Display name in task info header //DEBUG show during task create
        let name_el = document.createElement("input");
        name_el.setAttribute("type","text");
        name_el.setAttribute("size","30");
        name_el.setAttribute("value",task.name);
        name_el.addEventListener("input", () => { task.task_info_update_name(task, name_el); });
        task.task_info_header_el.appendChild(name_el);

        if (task.isAAT()) {
            let aat_el = document.createElement("div");
            aat_el.className = "task_is_aat";
            let text_el = document.createElement("span");
            text_el.innerHTML = "AAT min &#128337;";
            aat_el.appendChild(text_el);

            let time_el = document.createElement("div");
            let time_hours_el = document.createElement("select");
            time_hours_el.innerHTML = `
                <option value="0">0</option>
                <option value="1">1</option>
                <option value="2">2</option>
                <option value="3">3</option>
                <option value="4">4</option>
                <option value="5">5</option>
            `;
            time_el.appendChild(time_hours_el);
            let colon_el = document.createTextNode(":");
            time_el.appendChild(colon_el);
            let time_mins_el = document.createElement("select");
            time_mins_el.innerHTML = `
                <option value="0">00</option>
                <option value="5">05</option>
                <option value="10">10</option>
                <option value="15">15</option>
                <option value="20">20</option>
                <option value="25">25</option>
                <option value="30">30</option>
                <option value="35">35</option>
                <option value="40">40</option>
                <option value="45">45</option>
                <option value="50">50</option>
                <option value="55">55</option>`;
            time_el.appendChild(time_mins_el); //DEBUG initialise value from task
            /*
            let time_el = document.createElement("input");
            time_el.setAttribute("type","time");
            */
            time_hours_el.addEventListener("input", () => { task.task_info_update_aat_time(task, time_hours_el, time_mins_el); });
            time_mins_el.addEventListener("input", () => { task.task_info_update_aat_time(task, time_hours_el, time_mins_el); });

            if (task.aat_min_time_s != null) {
                console.log(`display_task_info_header() updating aat_min_time_s=${task.aat_min_time_s}`);
                let hours = Math.floor(task.aat_min_time_s / 3600);
                let mins = Math.round(((task.aat_min_time_s - hours * 3600) / 60) / 5) * 5;
                time_hours_el.value = ""+hours;
                time_mins_el.value = ""+mins;
            }

            aat_el.appendChild(time_el);

            task.task_info_header_el.appendChild(aat_el);
        }

        if (task.isLocal()) {
            let local_el = document.createElement("div");
            local_el.className = "task_is_local";
            local_el.textContent = "Loaded from NB21 Logger";

            task.task_info_header_el.appendChild(local_el);
        }

        task.task_info_header_el.style.display = "block";
    }

    task_info_update_name(task, name_el) {
        console.log("task_info_update_name "+name_el.value);
        task.name = name_el.value;
        console.log("task_info_update_name title was "+task.title);
        task.title = task.name;
        console.log("task_info_update_name title updated to "+task.title);
    }

    task_info_update_aat_time(task, time_hours_el, time_mins_el) { //DEBUG incomplete
        console.log("task_info_update_aat_time ",time_hours_el.value, time_mins_el.value);
        task.aat_min_time_s = parseInt(time_hours_el.value)*3600 + parseInt(time_mins_el.value)*60;
        if (task.aat_min_time_s == 0) { // catch user setting time to zero
            task.aat_min_time_s = null;
        }
    }

    display_task_waypoint(task_info_table_el, wp) {
        const task = this;
        let wp_el = document.createElement("tr");
        wp_el.className = wp.index == task.index ? "task_info_wp_current" : "task_info_wp";

        // Build elevation string
        let alt_str = wp.alt_m.toFixed(0);
        if (task.planner.settings.altitude_units == "feet") {
            alt_str = (wp.alt_m * task.planner.M_TO_FEET).toFixed(0);
        }
        // Build distance string
        let dist_str = "";
        if (wp.index > 0) {
            if (task.planner.settings.distance_units == "miles") {
                dist_str = (wp.leg_distance_m * task.planner.M_TO_MILES).toFixed(1);
            } else {
                dist_str = (wp.leg_distance_m / 1000).toFixed(1);
            }
        }

        // Start/Finish indicator, or ICAO for takeoff/landing airports
        // Note here we will also FIXUP start/finish in the task if words "start" or "finish" are in wp name and
        // start/finish has otherwise not been set.
        let wp_index_el = document.createElement("td"); // WP #
        wp_index_el.className = "task_info_wp_index";
        wp_index_el.onclick = function() {
            task.set_current_wp(wp.index);
        };
        let index_note = "";
        // Check if no start set and WP name includes word "start"
        if (task.start_index_set == null && /\bstart\b/.test(wp.get_name().toLowerCase())) {
            console.log("Task.display_task_waypoint fixup START waypoint index=",wp.index);
            task.start_index = wp.index;
        }
        // Check if no finish set and WP name includes word "finish"
        if (task.finish_index_set == null && /\bfinish\b/.test(wp.get_name().toLowerCase())) {
            console.log("Task.display_task_waypoint fixup FINISH waypoint index=",wp.index);
            task.finish_index = wp.index;
        }

        if (wp.index == task.start_index) {
            index_note = "[St]";
            wp_index_el.className = "task_info_wp_index_startfinish";
        } else if (wp.index == task.finish_index) {
            index_note = "[Fin]";
            wp_index_el.className = "task_info_wp_index_startfinish";
        // For first and last waypoints, if they have an ICAO code, display that on left.
        } else if ((wp.index == 0 || wp.index == task.waypoints.length - 1) && wp.icao != null) {
            index_note = wp.icao;
            //if (wp.index == 0) {
            //    wp_index_el.style.verticalAlign = "top";
            //    wp_index_el.style.paddingTop = "3px";
            //}
        } else if (wp.isAAT()) {
            // Label this WP in the task display info as an Assigned Area
            wp_index_el.className = "task_info_wp_index_aat";
            index_note = "[AAT]";
        }
        wp_index_el.innerHTML = index_note; //(wp.index+1)+"&nbsp;"+index_note;
        wp_el.appendChild(wp_index_el);

        // WP name
        let wp_name_el = document.createElement("td");
        wp_name_el.className = "task_info_wp_name";
        wp_name_el.onclick = function() {
            task.set_current_wp(wp.index);
        };
        let wp_name_str = wp.get_name();
        if (wp.runway_str != null && wp.runway_str != "" && wp.runway_str != " ") {
            wp_name_str += "<br/>Runway: " + wp.get_runway_display_str(wp.runway_str);
        }
        wp_name_el.innerHTML = wp_name_str;
        wp_el.appendChild(wp_name_el);

        // WP alt
        let wp_alt_el = document.createElement("td");
        wp_alt_el.className = "task_info_wp_alt";
        wp_alt_el.onclick = function() {
            task.set_current_wp(wp.index);
        };
        wp_alt_el.innerHTML = alt_str;
        wp_el.appendChild(wp_alt_el);

        // leg bearing
        let wp_bearing_el = document.createElement("td");
        wp_bearing_el.onclick = function() {
            task.set_current_wp(wp.index);
        };
        wp_bearing_el.className = "task_info_wp_bearing";
        wp_bearing_el.innerHTML = wp.get_leg_bearing();
        wp_el.appendChild(wp_bearing_el);

        // leg distance
        let wp_dist_el = document.createElement("td");
        wp_dist_el.className = "task_info_wp_distance";
        wp_dist_el.onclick = function() {
            task.set_current_wp(wp.index);
        };
        wp_dist_el.innerHTML = dist_str;
        wp_el.appendChild(wp_dist_el);

        // up/down/delete buttons
        let wp_buttons_el = document.createElement("td");
        task.task_info_wp_buttons(wp_buttons_el, wp);
        wp_el.appendChild(wp_buttons_el);

        task_info_table_el.appendChild(wp_el);

        // Add another row if this WP has limits set
        if (wp.max_alt_m != null || wp.min_alt_m != null || wp.radius_m != null) {
            let wp_limits_row_el = document.createElement("tr");

            // Create spacer on left of limits under St/Fin/ICAO
            let wp_limits_left_el = document.createElement("td");
            wp_limits_left_el.className = "task_info_wp_limits";
            wp_limits_row_el.appendChild(wp_limits_left_el);

            // Create content for limits left-aligned spanning 5 columns
            let wp_limits_el = document.createElement("td");
            wp_limits_el.setAttribute("colspan", "5");
            wp_limits_el.className = "task_info_wp_limits";

            let alt_units_str = "m"
            let alt_scaler = 1;
            if (task.planner.settings.altitude_units == "feet") {
                alt_units_str = "ft";
                alt_scaler = task.planner.M_TO_FEET;
            }

            let limits_str = "";

            if (wp.max_alt_m != null) {
                limits_str += "Max alt: " + (wp.max_alt_m * alt_scaler).toFixed(0) + alt_units_str + ".";
            }

            if (wp.min_alt_m != null) {
                limits_str += " Min alt: " + (wp.min_alt_m * alt_scaler).toFixed(0) + alt_units_str + ".";
            }

            let radius_units_str = "m";
            let radius_scaler = 1;

            if (task.planner.settings.wp_radius_units == "feet") {
                radius_units_str = "ft";
                radius_scaler = task.planner.M_TO_FEET;
            }

            if (wp.radius_m != null) {
                limits_str += " Radius: " + (wp.radius_m * radius_scaler).toFixed(0) + radius_units_str + ".";
            }

            wp_limits_el.innerHTML = limits_str;
            wp_limits_row_el.appendChild(wp_limits_el);

            task_info_table_el.appendChild(wp_limits_row_el);
        }
    }

    task_info_wp_buttons(buttons_el, wp) {
        const task = this;
        buttons_el.className = "task_info_wp_buttons";

        if (wp.index != 0) {
            let up_el = document.createElement("img");
            up_el.src = "https://xp-soaring.github.io/tasks/b21_task_planner/images/arrow_up.png";
            up_el.className = "task_info_wp_button";
            up_el.addEventListener("click", () => {
                task.move_wp_up(wp.index);
            });
            buttons_el.appendChild(up_el);
        }

        if (wp.index != task.waypoints.length - 1) {
            let down_el = document.createElement("img");
            down_el.src = "https://xp-soaring.github.io/tasks/b21_task_planner/images/arrow_down.png";
            down_el.className = "task_info_wp_button";
            down_el.addEventListener("click", () => {
                task.move_wp_down(wp.index);
            });
            buttons_el.appendChild(down_el);
        }

        let delete_el = document.createElement("img");
        delete_el.src = "https://xp-soaring.github.io/tasks/b21_task_planner/images/delete.png";
        delete_el.className = "task_info_wp_button";
        delete_el.addEventListener("click", () => {
            task.remove_wp(wp.index);
        });
        buttons_el.appendChild(delete_el);

    }

    remove_wp_from_task(remove_index) {
        const task = this;
        console.log(`Task.remove_wp_from_task wp[${remove_index}] ${task.waypoints[remove_index].name} count=${task.waypoints.length}`);
        let wp = task.waypoints[remove_index];
        // remove line TO this waypoint
        if (remove_index > 0) {
            wp.remove_line(wp);
        }
        let next_wp = null;
        // remove line TO NEXT waypoint
        if (remove_index < task.waypoints.length - 1) {
            next_wp = task.waypoints[remove_index + 1];
            next_wp.remove_line(next_wp);
        }
        task.remove_marker(wp);
        task.remove_sector(wp);

        // If this WP is the first airport, and the next is also an airport, set the .icao value for the next WP
        if (remove_index == 0 && task.waypoints.length > 1 && next_wp.data_icao != null) {
            task.waypoints[remove_index + 1].icao = task.waypoints[remove_index + 1].data_icao;
        }

        // If this WP is the last airport, and the previous is also an airport, set the .icao value for the previous WP
        if (remove_index == task.waypoints.length - 1 && task.waypoints.length > 1 && task.waypoints[remove_index - 1].data_icao != null) {
            task.waypoints[remove_index - 1].icao = task.waypoints[remove_index - 1].data_icao;
        }

        // Remove this waypoint from waypoints list
        task.waypoints.splice(remove_index, 1);
        //console.log("Task.remove_wp_from_task waypoints.length=" + task.waypoints.length);

        // Reset index values in waypoints
        for (let i = 0; i < task.waypoints.length; i++) {
            task.waypoints[i].index = i;
        }
        // If we just deleted the last waypoint, we need to set current to new last WP
        if (remove_index <= task.index) {
            task.index = task.index == 0 ? null : task.index - 1;
            console.log(`Task.remove_wp_from_task wp[${remove_index}] task.index=${task.index}`);
        }

        // Fixup start index after we've deleted a waypoint
        if (task.start_index != null && remove_index <= task.start_index) {
            if (task.start_index == remove_index) {
                task.start_index = null;
            } else {
                task.start_index--;
            }
        }

        // Fixup finish index after we've deleted a waypoint
        if (task.finish_index != null && remove_index <= task.finish_index) {
            if (task.finish_index == remove_index) {
                task.finish_index = null;
            } else {
                task.finish_index--;
            }
        }
    }

    remove_wp(remove_index) {
        const task = this;
        console.log(`Task.remove_wp(${remove_index})`);
        console.log(`Task.remove_wp(${remove_index}) current WP is ${task.current_wp().index}`);
        task.remove_wp_from_task(remove_index);
        task.update_waypoints();
        task.update_waypoint_icons();
        task.draw();
        task.display_task_info();
        if (task.waypoints.length > 0) {
            let wp = task.current_wp();
            wp.display_menu(wp);
        } else {
            task.planner.map.closePopup();
        }
    }

    move_wp_down(index) {
        const task = this;
        console.log("Task.move_wp_down(" + index + ")");
        if (index >= task.waypoints.length - 1) { // Cannot move down if already last
            return;
        }
        let wp = task.waypoints[index];
        let next_wp = task.waypoints[index + 1]
        task.waypoints[index] = next_wp;
        task.waypoints[index + 1] = wp;
        task.update_waypoints();
        task.update_waypoint_icons();
        task.draw();
        task.display_task_info();
        if (task.waypoints.length > 0) {
            wp.display_menu(wp);
        } else {
            task.planner.map.closePopup();
        }
    }

    move_wp_up(index) {
        const task = this;
        console.log("Task.move_wp_up(" + index + ")");
        if (index == 0) { // Cannot move up if already first
            return;
        }
        let wp = task.waypoints[index];
        let prev_wp = task.waypoints[index - 1]
        task.waypoints[index] = prev_wp;
        task.waypoints[index - 1] = wp;
        task.update_waypoints();
        task.update_waypoint_icons();
        task.draw();
        task.display_task_info();
        if (task.waypoints.length > 0) {
            wp.display_menu(wp);
        } else {
            task.planner.map.closePopup();
        }
    }

    set_current_wp(index) {
        const task = this;
        console.log("Task.set_current_wp index=", index);
        task.index = index;
        task.update_waypoint_icons();
        task.draw();
        let wp = task.current_wp();
        wp.display_menu(wp);
        task.planner.show_task_info();
    }

    reset() {
        const task = this;
        console.log("task.reset()");
        let length = task.waypoints.length;
        //console.log(task.toString());
        for (let i = length - 1; i >= 0; i--) {
            task.remove_wp_from_task(i);
            //console.log(task.toString());
        }
        task.init();
        task.planner.map.closePopup();
        task.display_task_info();
    }

    // *******************************************
    // AAT task min/max distance
    // *******************************************

    update_aat_distance() {
        const task = this;
        if (!task.isAAT() || task.waypoints.length < 3) {
            return;
        }
        const start_index = task.start_index == null ? 0 : task.start_index;
        const finish_index = task.finish_index == null ? 0 : task.finish_index;
        const MAX_ITERATIONS = 5;
        for (let i=0; i<MAX_ITERATIONS; i++) {
            for (let wp_index = start_index+1; wp_index < finish_index; wp_index++) {
                let wp = task.waypoints[wp_index];
                if (wp.isAAT()) {
                    // Calculate MIN position for this AAT area
                    let p0 = task.waypoints[wp_index-1].aat_position_min;
                    let p1 = task.waypoints[wp_index+1].aat_position_min;
                    let track_in = Geo.get_bearing_deg(p0, wp.position);
                    let track_out = Geo.get_bearing_deg(wp.position, p1);
                    let bisector_deg = (Geo.get_bisector_deg(track_in, track_out) + 180) % 360;
                    // let prev_min = wp.aat_position_min;
                    let min_distance_m = Geo.get_distance_to_line_m(wp.position, [p0,p1]);
                    min_distance_m = Math.min(min_distance_m, wp.radius_m);
                    wp.aat_position_min = Geo.get_distance_and_bearing(wp.position, min_distance_m, bisector_deg);
                    //console.log(`task.update_aat_distance MIN wp[${wp_index}] adj ${Geo.get_distance_m(prev_min, wp.aat_position_min).toFixed(1)}m`);

                    // Calculate MAX position for this AAT area
                    p0 = task.waypoints[wp_index-1].aat_position_max;
                    p1 = task.waypoints[wp_index+1].aat_position_max;
                    track_in = Geo.get_bearing_deg(p0, wp.position);
                    track_out = Geo.get_bearing_deg(wp.position, p1);
                    bisector_deg = Geo.get_bisector_deg(track_in, track_out);
                    // let prev_max = wp.aat_position_max;
                    wp.aat_position_max = Geo.get_distance_and_bearing(wp.position, wp.radius_m, bisector_deg);
                    //console.log(`task.update_aat_distance MAX wp[${wp_index}] adj ${Geo.get_distance_m(prev_max, wp.aat_position_max).toFixed(1)}m`);
                }
            }
        }
    }

    remove_aat_lines() {
        const task = this;
        for (let wp_index = task.start_index+1; wp_index < task.waypoints.length; wp_index++) {
            let wp = task.waypoints[wp_index];
            wp.remove_aat_line(wp);
        }
    }

    draw_min_aat_distance() {
        let task = this;
        task.remove_aat_lines();
        if (!task.isAAT() || task.start_index == null || task.finish_index == null || task.finish_index - task.start_index < 2) {
            return;
        }
        for (let i=task.start_index; i<task.finish_index; i++) {
            let wp = task.waypoints[i];
            let wp1 = task.waypoints[i+1];
            wp1.add_aat_line(wp1, wp.aat_position_min, wp1.aat_position_min);
        }
    }

    draw_max_aat_distance() {
        let task = this;
        task.remove_aat_lines();
        if (!task.isAAT() || task.start_index == null || task.finish_index == null || task.finish_index - task.start_index < 2) {
            return;
        }
        for (let i=task.start_index; i<task.finish_index; i++) {
            let wp = task.waypoints[i];
            let wp1 = task.waypoints[i+1];
            wp1.add_aat_line(wp1, wp.aat_position_max, wp1.aat_position_max, true);
        }
    }

    // *******************************************
    // Tracklog Sector calculations
    // Using position as { "lat": , "lng", "alt_m" }
    // *******************************************

    // Return { "start": true|false, "ts": seconds timestamp of start }
    is_start(p1, p2) {
        const task = this;
        if (task.start_index == null) {
            console.log("Task.is_start false start_index is null");
            return false;
        }
        if (task.start_index > task.waypoints.length - 2) {
            console.log("Task.is_start false no leg after start");
            return false;
        }

        let leg_bearing_deg = task.waypoints[task.start_index + 1].leg_bearing_deg;
        //console.log("Task.is_start() leg_bearing_deg="+leg_bearing_deg);
        return task.waypoints[task.start_index].is_start(p1, p2, leg_bearing_deg);
    }

    // Return { "finish": true|false, "ts": seconds timestamp of finish }
    is_finish(p1, p2) {
        const task = this;
        if (task.finish_index == null) {
            return false;
        }
        return task.waypoints[task.finish_index].is_finish(p1, p2);
    }

    // Return { "wp": true|false, "ts": seconds timestamp of wp }
    // true id p1 -> p2 ENTERS radius of wp
    is_wp(wp_index, p1, p2) {
        const task = this;
        if (task.start_index == null || wp_index <= task.start_index ||
            task.finish_index == null || wp_index >= task.finish_index || wp_index >= task.waypoints.length) {
            return false;
        }
        return task.waypoints[wp_index].is_wp(p1, p2);
    }

    // Return { "wp": true|false, "ts": seconds timestamp of wp }
    // true id p1 -> p2 EXITS radius of wp
    is_wp_exit(wp_index, p1, p2) {
        const task = this;
        if (task.start_index == null || wp_index <= task.start_index ||
            task.finish_index == null || wp_index >= task.finish_index || wp_index >= task.waypoints.length) {
            return false;
        }
        return task.waypoints[wp_index].is_wp_exit(p1, p2);
    }

    // *******************************************
    // General - convert class instance to string
    // *******************************************

    toString() {
        const task = this;
        let str = "[";
        for (let i = 0; i < task.waypoints.length; i++) {
            str += (i == 0 ? "" : ",") + task.waypoints[i].toString();
        }
        str += "]";
        return str;
    }
} // end Task class
"use strict"

/*  This is the 'main' controller class for the B21 Task Planner application.
    index.html contains an onload script with
        b21_task_planner = new B21_TaskPlanner();
        b21_task_planner.init();
*/

/*  Note the use of 'planner' variables is simply a substitute for 'this', but consistently set to
    be an 'object reference' to the currently instantiated class object, as you would expect in most languages.
    Javascript has complex 'this' behaviour when code is executed following a 'click' on a DOM object or during
    setTimeout so passing a reference to the intended planner object avoids unexpected errors.
*/

class B21_TaskPlanner {

    constructor() {
        let planner = this;
        planner.VERSION = "v5.1.1";
        console.log(`B21_TaskPlanner ${planner.VERSION} created`);
        planner.M_TO_FEET = 3.28084;
        planner.M_TO_MILES = 0.000621371;
        planner.MS_TO_KPH = 3.6;
        planner.MS_TO_KNOTS = 1.94384;

        planner.HOST_URL = "https://xp-soaring.github.io/tasks/b21_task_planner";

        planner.URL_TIMEOUT_S = 10; // Given a PLN url on startup, will try this many seconds to load that URL file.
    }

    init() {
        console.log("B21_TaskPlanner init()");
        let planner = this;

        // Set unique id for user
        planner.id = localStorage.getItem('b21_task_planner_id');
        if (planner.id == null) {
            planner.id = planner.create_guid();
            localStorage.setItem('b21_task_planner_id', planner.id);
        }

        // Fetch B21_REFERENCE_DATA.json
        planner.B21_REFERENCE_DATA = null;
        planner.fetch_B21_REFERENCE_DATA(planner);

        // ********************************************
        // Define vars for DOM elements
        // ********************************************

        planner.skyvector_button_el = document.getElementById("skyvector_button"); // So we can update action URL

        // This 'player_local' checkbox will only be visible with file:// or http://
        planner.multiplayer_local_el = document.getElementById("multiplayer_local");
        planner.multiplayer_local_checkbox_el = document.getElementById("multiplayer_local_checkbox");
        planner.multiplayer_local_checkbox_el.addEventListener("click", (event) => { planner.multiplayer_local_clicked(planner); });
        planner.multiplayer_enable_checkbox_el = document.getElementById("multiplayer_enable_checkbox");
        planner.multiplayer_enable_checkbox_el.addEventListener("click", (event) => { planner.multiplayer_enable_clicked(planner); });

        planner.icon_data_name_el = document.getElementById("icon_data_name_checkbox");
        planner.icon_data_altitude_el = document.getElementById("icon_data_altitude_checkbox");
        planner.icon_data_speed_el = document.getElementById("icon_data_speed_checkbox");

        planner.multiplayer_center_checkbox_el = document.getElementById("multiplayer_center_checkbox");
        planner.multiplayer_center_checkbox_el.addEventListener("click", (event) => { planner.multiplayer_center_clicked(planner); });

        // Search box
        planner.search_results_el = document.getElementById("search_results");
        planner.search_input_el = document.getElementById("search_input");

        // left_pane content
        planner.left_pane_el = document.getElementById("left_pane"); // display none|block
        planner.left_pane_show_el = document.getElementById("left_pane_show"); // display none|block
        planner.left_pane_tabs_el = document.getElementById("left_pane_tabs"); // display none|block

        // tabs and their content on left pane
        // tabs
        planner.tab_task_el = document.getElementById("tab_task");
        planner.tab_weather_el = document.getElementById("tab_weather");
        planner.tab_tracklogs_el = document.getElementById("tab_tracklogs");
        // left-pane info content
        planner.task_info_el = document.getElementById("task_info");
        planner.weather_info_el = document.getElementById("weather_info");
        planner.tracklogs_el = document.getElementById("tracklogs");
        planner.tracklogs_select_all_el = document.getElementById("tracklogs_select_all");
        planner.tracklog_info_el = document.getElementById("tracklog_info");
        planner.rescore_button_el = document.getElementById("rescore_button");

        // right_pane content
        planner.right_pane_el = document.getElementById("right_pane");
        planner.panes_resize();

        // map pane
        planner.map_el = document.getElementById("map");

        // Wind rose
        planner.wind_rose_position = 0; // position of wind rose in left pane: 0 = top left, then clockwise
        planner.wind_rose_el = document.getElementById("wind_rose");
        planner.wind_speed_1_el = document.getElementById("wind_speed_1_value");
        planner.wind_speed_units_el = document.getElementById("wind_speed_units");
        planner.wind_arrow_1_el = document.getElementById("wind_arrow_1");
        planner.wind_arrow_1_text_el = document.getElementById("wind_arrow_1_text");
        planner.wind_hide_el = document.getElementById("wind_rose_hide");
        planner.wind_checked_el = document.getElementById("wind_rose_hide_check");

        // Tracklog fixup
        planner.tracklog_fixup_el = document.getElementById("tracklog_fixup");
        planner.tracklog_fixup_button_el = document.getElementById("tracklog_fixup_button");

        // replay bar
        planner.replay_el = document.getElementById("replay");
        planner.replay_hide_chart_el = document.getElementById("replay_hide_chart"); // button
        planner.replay_hide_tracks_el = document.getElementById("replay_hide_tracks"); // button
        planner.replay_speed_el = document.getElementById("replay_speed_value");
        planner.replay_time_el = document.getElementById("replay_time");
        planner.skip_pause_el = document.getElementById("skip_pause_checkbox");
        planner.skip_pause_progress_el = document.getElementById("skip_pause_progress");
        planner.replay_sync_el = document.getElementById("replay_sync_checkbox");
        // charts
        planner.charts_el = document.getElementById("charts");

        // ********************************************
        // Define class vars
        // ********************************************

        // Tracklogs array, will contain Tracklog objects for each loaded GPX file
        planner.tracklogs = []; // Loaded tracklogs
        planner.tracklog_index = null; // index of current tracklog

        // Replay clock - will set to earliest time from any loaded GPX file
        planner.replay_mode = false;      // true when replay is running.
        planner.replay_ts = null;         // Timestamp (s) for current replay
        planner.replay_end_ts = null;     // Latest timestamp in tracklogs, limit for replay
        planner.replay_speed = 20;        // Replay speed multiplier, relative to real time
        planner.replay_timer = null;      // JS interval timer
        planner.replay_completed = false; // set to true when planner.replay_ts is larger than any timestamp in tracklogs
        planner.replay_sync = false;      // true => replay will synchronize all tracklogs to a common start time
        planner.replay_start_datetime;    // JS Date() for start of replay, so we can keep in sync with real clock (needed for x1)
        planner.replay_start_ts;          // Complement to replay_start_datetime, to ensure replay_ts x1 is accurate

        // UI display controls
        planner.charts_hidden = true; // The 'charts' div is hidded until GPX file is loaded
        planner.tracks_hidden = false; // The tracks on the map can be hidden or displayed

        planner.local_waypoints = {};      // DICTIONARY of { key -> B21_Local_Waypoints }

        // Edit mode status, set to false on PLN/TSK load
        planner.edit_mode = true;
        planner.edit_mode_el = document.getElementById("click_to_edit");

        // Restore saved settings
        planner.settings = new B21_Settings(planner); // Load settings from localStorage incl. local_waypoints

        // Create multiplayer handler in case it's needed
        planner.players = new B21_Players(planner);

        // Create B21_Weather
        planner.weather = new B21_Weather(planner);

        planner.multiplayer_local_checkbox_el.checked = planner.settings.nb21_connect;
        console.log(`B21_TaskPlanner creating NB21Connect (${location.protocol})`);
        planner.nb21 = new NB21Connect(planner);

        window.addEventListener("resize", (e) => {
            //console.log("B21_TaskPlanner. window resized", window.innerWidth, window.innerHeight);
            planner.panes_resize();
        });

        planner.init_drop_zone();

        planner.init_task_download_menu();

        // Make sure is initialized ok
        planner.reset_all();

        // Note B21_Airports is common to this B21 Task Planner and the MSFS B21 Nav Panel
        planner.airports = new B21_Airports(planner, {
            //json_url: `${planner.HOST_URL}/airports/airports_2025-02-14.json`,
            json_url: `${planner.HOST_URL}/airports/airports.json`,
            airport_img_url: `${planner.HOST_URL}/images/airport_00.png`
        });

        planner.airports.init(planner.map); // Here we ASYCHRONOUSLY load the airports JSON data (& will draw on map)

        planner.files_count = 0 ;             // Number of files currently in 'batch load' (i.e. drag/drop multiple)
        planner.files_incl_tracklogs = false; // Whether files batch includes tracklogs

        // Load parameters from querystring into planner.querystring object
        planner.querystring = planner.parse_querystring();

        console.log(`B21_TaskPlanner.querystring='${planner.querystring}'`);

        planner.handle_querystring(planner.querystring);
    }

    fetch_B21_REFERENCE_DATA(planner) {
        fetch(`${planner.HOST_URL}/js/lib/B21_REFERENCE_DATA.json`)
        .then( r => { return r.json(); } )
        .then( j => {
            planner.B21_WEATHER_DATA = j.WEATHER;
            console.log("B21_WEATHER_DATA loaded");
        })
        .catch( e => {
            console.warn(e);
        })
    }

    // Clear the current task and start afresh
    reset_all() {
        let planner = this;
        console.log("B21_TaskPlanner.reset_all()");
        planner.init_task(planner);
        planner.init_tracklogs(planner);
        planner.init_tracklog_info(planner);
        planner.init_replay(planner);
        planner.init_charts(planner);
        planner.init_map(planner);
        if (planner.airports) {
            planner.airports.draw(planner.map);
        }
        for (const [local_waypoints_key, waypoints] of Object.entries(planner.local_waypoints) ) {
            try {
                console.log("B21_TaskPlanner.reset_all local_waypoints ",local_waypoints_key);
                waypoints.waypoints_loaded();
            } catch(e) {
                console.error("B21_TaskPlanner.reset_all could not draw waypoints",local_waypoints_key, e);
            }
        }
        planner.init_weather(planner);
        planner.players.reset_all();
        // Subscribe to NB21 Logger if we're file:// or http://
        //if (!location.protocol.startsWith("https") && planner.multiplayer_local_checkbox_el.checked) { //planner.settings.nb21_connect) {
        if (planner.multiplayer_local_checkbox_el.checked) { //planner.settings.nb21_connect) {
            planner.nb21.setup_connection(false); // true = use JSON, false = use IGC
        }
        planner.tracklog_fixup_el.style.display = "none";
    }

    panes_resize() {
        let planner = this;
        let left_pane_width_px = planner.left_pane_el.clientWidth;
        planner.right_pane_el.style.width = "calc(98% - " + (left_pane_width_px + 25).toFixed(0) + "px)";
        planner.set_wind_rose_position();
    }

    create_guid() {
        function _p8(s) {
            var p = (Math.random().toString(16) + "000000000").substr(2, 8);
            return s ? "-" + p.substr(0, 4) + "-" + p.substr(4, 4) : p;
        }
        return _p8() + _p8(true) + _p8(true) + _p8();
    }

    parse_querystring() {
        var search = location.search.substring(1);
        //console.log(search);
        let qs = null;
        try {
            qs = JSON.parse('{"' + search.replace(/&/g, '","').replace(/=/g, '":"') + '"}', function(key, value) {
                    return key === "" ? value : decodeURIComponent(value)
            });
        } catch (e) {
            qs = null;
        }
        return qs;
    }

    // *******************************************************************************
    // Define the map
    // *******************************************************************************

    init_map(planner) {

        // https://leaflet-extras.github.io/leaflet-providers/preview/
        let tfkey = "db5" + "ae1" + "f57" + "78a" + "448" + "ca6" + "625" + "545" + "81f" + "283" + "c5";
        let stkey = location.protocol == "https:" ? '' : '?'+'ap'+'i_k'+'ey'+'='+'f'+'037'+'5304'+'-25'+'ce'+'-4'+'def'+'-83'+'16'+'-9'+'bef'+'70'+'eaad'+'c8';
        let mbkey = "pk.eyJ"+"1Ij"+"oiY"+"jI"+"xc2"+"9hcm"+"luZ"+"yIs"+"ImEiOi"+"Jja3"+"M0Z2"+"o0ZWE"+"yNjJ"+"1Mz"+"Ftcm5"+"rYnA"+"wbjJ"+"6In0"+".frJ"+"xiv"+"-ZU"+"V8e2"+"li7"+"r4_3"+"_A";

        let tiles_mapnik = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 19,
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        });

        let tiles_outdoor = L.tileLayer(
                'https://api.mapbox.com/styles/v1/b21soaring/clofysl63007901o6ahsu552m/tiles/512/{z}/{x}/{y}@2x?access_token='+mbkey, {
                //'https://api.mapbox.com/styles/v1/b21soaring/clofysl63007901o6ahsu552m/tiles/256/{z}/{x}/{y}@2x?access_token='+mbkey, {
                //'https://api.mapbox.com/styles/v1/{id}/tiles/{z}/{x}/{y}?access_token='+mbkey, {
                attribution: 'Map data &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, Imagery © <a href="https://www.mapbox.com/">Mapbox</a>',
                maxZoom: 18,
                //id: 'mapbox/outdoors-v11',
                tileSize: 512,
                zoomOffset: -1,
                minZoom: 2,
                accessToken: mbkey
            });

        let tiles_opentopomap = L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
            maxZoom: 17,
            attribution: 'Map data: &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, <a href="http://viewfinderpanoramas.org">SRTM</a> | Map style: &copy; <a href="https://opentopomap.org">OpenTopoMap</a> (<a href="https://creativecommons.org/licenses/by-sa/3.0/">CC-BY-SA</a>)'
        });

        let thunderforest_landscape = L.tileLayer(
            'https://{s}.tile.thunderforest.com/landscape/{z}/{x}/{y}.png?apikey='+tfkey, {
                attribution: '&copy; <a href="http://www.thunderforest.com/">Thunderforest</a>, &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
                apikey: tfkey,
                maxZoom: 22
            });

        let thunderforest_outdoors = L.tileLayer('https://{s}.tile.thunderforest.com/outdoors/{z}/{x}/{y}.png?apikey='+tfkey, {
            attribution: '&copy; <a href="http://www.thunderforest.com/">Thunderforest</a>, &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
            apikey: tfkey,
            maxZoom: 22
        });

        let stamen_terrain = L.tileLayer('https://tiles.stadiamaps.com/tiles/stamen_terrain/{z}/{x}/{y}{r}.jpg'+stkey, {
            attribution: '&copy; <a href="https://www.stadiamaps.com/" target="_blank">Stadia Maps</a>&copy; <a href = "https://www.stamen.com/" target = "_blank" >Stamen Design</a>&copy; <a href="https://openmaptiles.org/" target="_blank">OpenMapTiles</a>&copy; <a href="https://www.openstreetmap.org/about/" target="_blank">OpenStreetMap contributors</a>',
            minZoom: 0,
            maxNativeZoom: 13
        });

        let cyclosm = L.tileLayer('https://{s}.tile-cyclosm.openstreetmap.fr/cyclosm/{z}/{x}/{y}.png', {
            maxZoom: 20,
            attribution: '<a href="https://github.com/cyclosm/cyclosm-cartocss-style/releases" title="CyclOSM - Open Bicycle render">CyclOSM</a> | Map data: &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        });

        let esri_natgeo_world = L.tileLayer(
            'https://server.arcgisonline.com/ArcGIS/rest/services/NatGeo_World_Map/MapServer/tile/{z}/{y}/{x}', {
                attribution: 'Tiles &copy; Esri &mdash; National Geographic, Esri, DeLorme, NAVTEQ, UNEP-WCMC, USGS, NASA, ESA, METI, NRCAN, GEBCO, NOAA, iPC',
                maxZoom: 16
            });

        let esri_world_imagery = L.tileLayer(
            'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community'
            });

        let google_terrain = L.tileLayer('https://{s}.google.com/vt/lyrs=p&x={x}&y={y}&z={z}', {
                maxZoom: 16,
                minZoom: 0,
                subdomains:['mt0','mt1','mt2','mt3']
            });

        // Airspace - not using currently
        let openaip = L.tileLayer('https://{s}.api.tiles.openaip.net/api/data/openaip/{z}/{x}/{y}.png?apiKey=7beacc9257a32efe75a26bcbcb222874', {
                maxZoom: 16,
                minZoom: 0,
                subdomains:['a','b','c']
            });

        // b21_airports requirements

        planner.canvas_renderer = L.canvas();

        planner.airport_markers = L.layerGroup(); //.addTo(planner.map);

        let open_railway_map = L.tileLayer('https://{s}.tiles.openrailwaymap.org/standard/{z}/{x}/{y}.png', {
            maxZoom: 19,
            attribution: 'Map data: &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors | Map style: &copy; <a href="https://www.OpenRailwayMap.org">OpenRailwayMap</a> (<a href="https://creativecommons.org/licenses/by-sa/3.0/">CC-BY-SA</a>)'
        });

        planner.base_maps = {
            "Google Terrain": google_terrain,
            "Streetmap": tiles_mapnik,
            "TopoMap": tiles_opentopomap,
            "NatGeo": esri_natgeo_world,
            "Outdoor": tiles_outdoor,
            "Thunderforest Land": thunderforest_landscape,
            "Thunderforest Outdoor": thunderforest_outdoors,
            //"Open AIP": openaip,
            "StamenTerrain": stamen_terrain,
            //"CyclOSM": cyclosm,
            "Satellite": esri_world_imagery
        }

        planner.map_layers = {
            "Airports": planner.airport_markers,
            "Railways": open_railway_map
        }

        // Clear old map
        if (planner.map) {
            planner.map.off();
            planner.map.remove();
        }

        planner.map = L.map(planner.map_el, {
            minZoom: 5,
            maxZoom: 16,
            worldCopyJump: true,
            layers: [planner.base_maps[planner.settings.base_layer_name], planner.airport_markers]
        });

        // Create pane in foreground to display the tracklogs
        planner.tracklogs_pane = planner.map.createPane("tracklogs_pane");
        planner.tracklogs_pane.style.zIndex = 450;

        planner.map.on("baselayerchange", (e) => {
            console.log("baselayerchange", e);
            planner.settings.set("base_layer_name", e.name);
        });

        L.control.layers(planner.base_maps, planner.map_layers).addTo(planner.map);

        planner.load_map_coords();

        planner.update_skyvector_link(planner.map.getCenter(), planner.map.getZoom());

        planner.set_map_events(planner);

    }

    // Close all WP popup menus
    close_popups(planner) {
        //console.log("B21_TaskPlanner.close_popups()");
        planner.map.eachLayer((l) => { l.closePopup();});
    }

    adjust_right_pane(planner) {
        //console.log(`B21_TaskPlanner.adjust_right_pane() zoom=${planner.map.getZoom()}`);

        let checked_count = planner.tracklogs_checked_count(planner);
        //console.log("B21_TaskPlanner.hecked_count", checked_count);

        if (checked_count == 0) {
            planner.replay_el.style.display = "none";
            planner.hide_charts(planner);
        } else {
            planner.replay_el.style.display = "flex";
            planner.show_charts(planner);
        }

        planner.map.invalidateSize();
    }

    set_map_events(planner) {
        // Set up the map mouse click callbacks
        planner.map.on('click', (e) => {
            planner.map_left_click(planner, e);
        });

        planner.map.on('contextmenu', (e) => {
            planner.map_right_click(planner, e);
        });

        planner.map.on("moveend", () => {
            //console.log("B21_TaskPlanner.on moveend",planner.map.getZoom());
            planner.save_map_coords(planner.map.getCenter(), planner.map.getZoom());
            planner.update_skyvector_link(planner.map.getCenter(), planner.map.getZoom());
            planner.airports.draw(planner.map);

            // redraw currently loaded waypoints
            planner.draw_waypoints(planner);
            //console.log("B21_TaskPlanner.moveend end zoom=",planner.map.getZoom());
        });

        planner.map.on('zoomend', () => { // Will also call moveend
            //console.log("B21_TaskPlanner.zoomend");
        });

        planner.add_lat_long_display(planner);
    }

    show_tracks_on_map(planner) {
        //console.log("B21_TaskPlanner.show_tracks");
        planner.tracks_hidden = false;
        planner.tracklogs_pane.style.display = "";
    }

    hide_tracks_on_map(planner) {
        //console.log("B21_TaskPlanner.hide_tracks");
        planner.task.remove_aat_lines();
        planner.tracks_hidden = true;
        planner.tracklogs_pane.style.display = "none";
    }

    // Called when map moves
    draw_waypoints(planner) {
        //console.log("B21_TaskPlanner.draw_waypoints");
        for (const [local_waypoints_key, waypoints] of Object.entries(planner.local_waypoints)) {
            waypoints.draw();
        }
    }

    // ***********************************************************************
    // ********** MSFS Wind Arrow              *******************************
    // ***********************************************************************

    init_msfs_wind_arrow() {
        let planner = this;
        if (planner.init_msfs_wind_arrow_complete == null) {

            planner.msfs_wind_div_el = document.getElementById("msfs_wind_div"); // Containing div for visibility
            planner.msfs_wind_arrow_el = document.getElementById("msfs_wind_arrow"); // Actual SVG arrow for rotation
            planner.msfs_wind_arrow_display = false;

            planner.init_msfs_wind_arrow_complete = true;
        }
    }

    update_msfs_wind_arrow(wind_deg, display) {
        let planner = this;
        planner.init_msfs_wind_arrow();

        // Toggle the arrow display on/off according to 'display' arg
        if (planner.msfs_wind_arrow_display && !display) {
            planner.msfs_wind_arrow_display = false;
            planner.msfs_wind_div_el.style.display = "none";
        } else if (!planner.msfs_wind_arrow_display && display) {
            planner.msfs_wind_arrow_display = true;
            planner.msfs_wind_div_el.style.display = "block";
        }

        let arrow_deg = (720 + wind_deg) % 360;
        planner.msfs_wind_arrow_el.style.transform = "rotate("+arrow_deg.toFixed(0)+"deg)";
    }

    // ************************************************************
    // Charts
    // ************************************************************

    init_charts(planner) {
        B21_Utils.clear_div(planner.charts_el)
        planner.hide_charts(planner);
        planner.replay_el.style.display = "none";
    }

    show_charts(planner) {
        //console.log("B21_TaskPlanner.show_charts()");
        planner.map_el.style.height = "calc(75% - 42px)";
        planner.charts_el.style.display = "block";
        planner.charts_hidden = false;
        planner.replay_hide_chart_el.innerHTML = "hide chart";
        planner.set_wind_rose_position();
        planner.resize_charts();
    }

    hide_charts(planner) {
        //console.log("B21_TaskPlanner.hide_charts()");
        // Adjust map size to either full height or full minus the replay bar height
        if (planner.replay_el.style.display == "none" || planner.replay_el.style.display == "") {
            //console.log("B21_TaskPlanner.replay_el display == none");
            // No replay bar so map can take 100%
            planner.map_el.style.height = "100%";
        } else {
            //console.log("B21_TaskPlanner.replay_el display != none : ", `"${planner.replay_el.style.display}"`);
            // tracklogs loaded and replay bar showing, so map subtract height of replay bar
            planner.map_el.style.height = "calc(100% - 42px)";
        }
        // hide the charts div
        planner.charts_el.style.display = "none";
        planner.charts_hidden = true;
        planner.replay_hide_chart_el.innerHTML = "show chart";
        planner.set_wind_rose_position();
    }

    add_lat_long_display(planner) {
        let Position = L.Control.extend({
            _container: null,
            options: {
                position: 'bottomleft'
            },
            onAdd: function(map) {
                var latlng = L.DomUtil.create('div', 'mouseposition');
                planner._latlng = latlng;
                return latlng;
            },

            updateHTML: function(lat, lng) {
                var latlng = lat + " " + lng;
                //planner._latlng.innerHTML = "Latitude: " + lat + "   Longitiude: " + lng;
                planner._latlng.innerHTML = "LatLng: " + latlng;
            }
        });

        let position = new Position();
        planner.map.addControl(position);

        planner.map.addEventListener('mousemove', (event) => {
            let lat = Math.round(event.latlng.lat * 100000) / 100000;
            let lng = Math.round(event.latlng.lng * 100000) / 100000;
            position.updateHTML(lat, lng);
        });
    }

    init_task_download_menu() {
        let planner = this;
        console.log("init_task_download_menu()");

        let download_button_el = document.getElementById("task_download_button");
        let menu_el = document.getElementById("task_download_menu");

        document.getElementById("panes").addEventListener("mouseenter", () => {
            planner.task_download_menu_hide(menu_el);
        });

        download_button_el.addEventListener("mouseenter", () => {
            planner.task_download_menu_show(menu_el);
        });
        download_button_el.addEventListener("mouseleave", () => {console.log("download flightplan button mouse leave");});

        menu_el.addEventListener("mouseenter", () => {console.log("menu mouse enter");});
        menu_el.addEventListener("mouseleave", () => {
            planner.task_download_menu_hide(menu_el);
        });

        let download_PLN_el = document.createElement("div");
        download_PLN_el.className = "task_download_item";
        download_PLN_el.innerText = "Download PLN";
        download_PLN_el.addEventListener("click", () => {
            console.log("download PLN click");
            planner.task_download_menu_hide(menu_el);
            planner.download_pln();
        });
        menu_el.appendChild(download_PLN_el);

        let download_TSK_el = document.createElement("div");
        download_TSK_el.className = "task_download_item";
        download_TSK_el.innerText = "Download TSK";
        download_TSK_el.addEventListener("click", () => {
            console.log("download TSK click");
            planner.task_download_menu_hide(menu_el);
            planner.download_tsk();
        });
        menu_el.appendChild(download_TSK_el);

        let download_KML_el = document.createElement("div");
        download_KML_el.className = "task_download_item";
        download_KML_el.innerText = "Download KML";
        download_KML_el.addEventListener("click", () => {
            console.log("download KML click");
            planner.task_download_menu_hide(menu_el);
            planner.download_kml();
        });
        menu_el.appendChild(download_KML_el);

        let send_to_logger_el = document.createElement("div");
        send_to_logger_el.className = "task_download_item";
        send_to_logger_el.innerText = "Send to Logger";
        send_to_logger_el.addEventListener("click", () => {
            console.log("Send to Logger click");
            planner.task_download_menu_hide(menu_el);
            planner.send_task_to_logger();
        });
        menu_el.appendChild(send_to_logger_el);
    }

    task_download_menu_show(menu_el) {
        menu_el.style.display = "block";
    }

    task_download_menu_hide(menu_el) {
        menu_el.style.display = "none";
    }

    // ********************************************************************************************
    // *********  File loads handling                      ****************************************
    // ********************************************************************************************

    init_drop_zone() {
        let drop_zone_el = document.getElementById("drop_zone");
        //drop_zone_el.style.display = "block";
        let planner = this;
        drop_zone_el.ondragover = (e) => {
            planner.dragover_handler(e);
        };
        drop_zone_el.ondrop = (e) => {
            planner.drop_handler(planner, e);
        };

        let drop_zone_choose_input_el = document.getElementById("drop_zone_choose_input");

        drop_zone_choose_input_el.onchange = () => {
            console.log("B21_TaskPlanner.drop_zone_choose_input_el.onchange");
            planner.drop_choose_handler(planner, [...drop_zone_choose_input_el.files]);
        };

        let drop_zone_choose_button_el = document.getElementById("drop_zone_choose_button");

        drop_zone_choose_button_el.onclick = () => {
            console.log("B21_TaskPlanner.drop_zone_choose_button_el.onclick");
            drop_zone_choose_input_el.value = ""; // reset so you can load the same file a second time
            drop_zone_choose_input_el.click();
        };
    }

    drop_handler(planner, ev) {
        console.log('B21_TaskPlanner.drop_handler() File(s) dropped');
        // Prevent default behavior (Prevent file from being opened)
        ev.preventDefault();

        if (ev.dataTransfer.items && ev.dataTransfer.items.length > 0) {
            console.log(`B21_TaskPlanner.drop_handler()  dataTransfer.items ${ev.dataTransfer.items.length} found`, ev.dataTransfer.items);

            planner.files_count = ev.dataTransfer.items.length;
            planner.files_incl_tracklogs = false;

            // Use DataTransferItemList interface to access the file(s)
            for (var i = 0; i < ev.dataTransfer.items.length; i++) {
                console.log("B21_TaskPlanner.drop_handler() checking data item " + i);
                let item = ev.dataTransfer.items[i];

                // If dropped items aren't files, reject them
                if (item.kind === 'file') {
                    let file = item.getAsFile();
                    console.log('B21_TaskPlanner.drop_handler() DataTransferItemList... file[' + i + ']' + file.name + '=', file);
                    let reader = new FileReader();
                    reader.onload = (e) => {
                        console.log("B21_TaskPlanner.drop_handler() .. B21_TaskPlanner.FileReader.onload")
                        planner.files_count--;
                        planner.handle_file_content(planner, Date.now(), e.target.result, file.name);
                        if (planner.files_count == 0) {
                            planner.files_load_completed(planner);
                        }
                    }
                    console.log("B21_TaskPlanner.reader.readAsArrayBuffer", file.name);
                    reader.readAsArrayBuffer(file);
                } else {
                    console.log("B21_TaskPlanner.drop_handler() Item dropped not of kind 'file':", ev.dataTransfer.items[i].kind, ev.dataTransfer.items[i]);
                    if (item.kind === 'string') {
                        item.getAsString(function(s) {
                            console.log("B21_TaskPlanner.drop_handler() item string", s);
                        });
                    }
                    planner.files_count--;
                    if (planner.files_count == 0) {
                        planner.files_load_completed(planner);
                    }
                }
            }
        } else {
            console.log("BB21_TaskPlanner.drop_handler() dataTransfer.items not found, using dataTransfer.files", ev);
            planner.handle_files(planner, ev.dataTransfer.files);
        }
    }

    drop_choose_handler(planner, files) {
        console.log("B21_TaskPlanner.drop_choose_handler", files);
        planner.handle_files(planner, files);
    }

    handle_files(planner, files) {

        console.log(`B21_TaskPlanner.handle_files(), starting with files_count=${files.length}`);

        planner.files_count = files.length;
        planner.files_incl_tracklogs = false;

        // Use DataTransfer interface to access the file(s)
        for (var i = 0; i < files.length; i++) {
            console.log("B21_TaskPlanner.checking file " + i)
            let file = files[i];
            console.log('DataTransfer... file[' + i + '].name = ' + file.name);
            let reader = new FileReader();
            reader.addEventListener("load", (e) => {
                planner.files_count--;
                planner.handle_file_content(planner, Date.now(), e.target.result, file.name);
                if (planner.files_count == 0) {
                    planner.files_load_completed(planner);
                }
            });
            // event fired when file reading failed
            reader.addEventListener('error', (e) => {
                planner.files_count--;
                if (planner.files_count == 0) {
                    planner.files_load_completed(planner);
                }
                alert('Error : Failed to read file');
            });
            reader.readAsArrayBuffer(file);
        }

        console.log(`B21_TaskPlanner.handle_files() completed, files_count=${planner.files_count}`);
    }

    files_load_completed(planner) {
        console.log("B21_TaskPlanner.files_load_completed()");
        planner.adjust_right_pane(planner);
        if (planner.files_incl_tracklogs) {
            planner.replay_restart();
            planner.show_tracklogs();
        }
        planner.files_incl_tracklogs = false;
    }

    // Handle the file contents, called after a URL access, file drop, or file choose
    handle_file_content(planner, fetch_start, file_content, name = null) {
        console.log(`B21_TaskPlanner.handle_file_content() ${name} files_count=${planner.files_count}`);
        if (name == null) {
            console.log("B21_TaskPlanner.No name for dropped file - aborting");
            return;
        }

        let suffix = B21_Utils.file_suffix(name);

        let decoder = new TextDecoder();

        if (suffix == "pln") {
            console.log("B21_TaskPlanner.handle_file_content() for PLN file");
            planner.init_task(planner);
            const pln_str = decoder.decode(file_content);
            planner.handle_pln_str(planner, fetch_start, pln_str, name);
            if (planner.settings.nb21_connect && planner.task.available()) {
                planner.nb21.pln_set(planner.nb21, pln_str);
            }
        } else if (suffix == "tsk") {
            console.log("B21_TaskPlanner.handle_file_content() for TSK file");
            planner.init_task(planner);
            planner.handle_tsk_str(planner, fetch_start, decoder.decode(file_content), name);

        } else  if (suffix == "gpx") {
            console.log("B21_TaskPlanner.handle_file_content() for GPX file");
            planner.files_incl_tracklogs = true; // signal that show_tracklogs() should be called in files_load_completed()
            planner.handle_gpx_str(planner, fetch_start, decoder.decode(file_content), name);

        } else if (suffix == "igc") {
            console.log("B21_TaskPlanner.handle_file_content() for IGC file");
            planner.files_incl_tracklogs = true; // signal that show_tracklogs() should be called in files_load_completed()
            planner.handle_igc_str(planner, fetch_start, decoder.decode(file_content), name);

        } else if (suffix == "cup") {
            planner.handle_cup_str(planner, fetch_start, decoder.decode(file_content), name);

        } else if (suffix == "comp") {
            planner.handle_comp_str(planner, fetch_start, decoder.decode(file_content), name);

        } else if (suffix == "zip") {
            planner.handle_zip_str(planner, fetch_start, file_content, name);

        } else if (suffix == "wpr") {
            planner.handle_wpr_str(planner, fetch_start, decoder.decode(file_content), name);

        } else {
            alert(`${name} not a recognized type`);
            return;
        }
        console.log(`File load time for ${name} was ${Date.now() - fetch_start} milliseconds`);
    }

    dragover_handler(ev) {
        //console.log("B21_TaskPlanner.dragover_handler preventDefault");
        // Prevent default behavior (Prevent file from being opened)
        ev.preventDefault();
    }

    // ********************************************************************************************
    // *********  Handle files from drop or URL                        ****************************
    // ********************************************************************************************

    // Load a PLN file from "pln": "url"
    // Currently param_obj is simply the parsed querystring
    handle_querystring(param_obj) {
        let planner = this;

        if (param_obj == null) {
            return;
        }

        console.log(`Starting querystring file downloads`);

        if (param_obj["pln"] != null) {
            let request_url = "https://" + param_obj["pln"];
            console.log("B21_TaskPlanner.load pln url", request_url);
            planner.handle_url_file(planner, request_url);
        }

        if (param_obj["gpx"] != null) {
            let request_url = "https://" + param_obj["gpx"];
            console.log("B21_TaskPlanner.load gpx url", request_url);
            planner.handle_url_file(planner, request_url);
        }

        if (param_obj["igc"] != null) {
            let request_url = "https://" + param_obj["igc"];
            console.log("B21_TaskPlanner.load igc url", request_url);
            try {
                planner.handle_url_file(planner, request_url);
            } catch (e) {
                console.error(e);
            }
        }

        if (param_obj["wpr"] != null) {
            let request_url = "https://" + param_obj["wpr"];
            console.log("B21_TaskPlanner.load wpr url", request_url);
            planner.handle_url_file(planner, request_url);
        }

        if (param_obj["cup"] != null) {
            let request_url = "https://" + param_obj["cup"];
            console.log("B21_TaskPlanner.load cup url", request_url);
            planner.handle_url_file(planner, request_url);
        }

        if (param_obj["tsk"] != null) {
            let request_url = "https://" + param_obj["tsk"];
            console.log("B21_TaskPlanner.load tsk url", request_url);
            planner.handle_url_file(planner, request_url);
        }

        if (param_obj["comp"] != null) {
            let request_url = "https://" + param_obj["comp"];
            console.log("B21_TaskPlanner.load comp url", request_url);
            planner.handle_url_file(planner, request_url);
        }

    }

    handle_url_file(planner, url) {
        // Get name from url, i.e. between last '/' and '.'
        let filename = url.slice(url.lastIndexOf('/') + 1);
        let name = filename.slice(0, filename.lastIndexOf('.'));
        console.log("B21_TaskPlanner.loading url name=", filename);

        let fetch_start = Date.now();

        fetch(url).then(response => {
            if (!response.ok) {
                alert("A file referenced in the querystring failed to load:\n"+filename);
                return null;
            }
            return response.arrayBuffer();
        }).then(result_content => {
            //console.log("B21_TaskPlanner.fetch(url) return");
            if (result_content != null) {
                planner.handle_file_content(planner, fetch_start, result_content, filename);
            }
        }).catch(error => {
            console.error('Network error accessing user URL:', error);
        });
    }

    handle_pln_str(planner, fetch_start, pln_str, name) {
        console.log("B21_TaskPlanner.handle_pln_str string containing PLN XML '" + name + "'");
        if (planner.airports.available) {
            console.log("B21_TaskPlanner.airports available, so loading PLN");
            planner.task.load_pln_str(pln_str, name);
        } else {
            console.log(
                `WARNING: handle_pln_str airports not ready after ${((Date.now() - fetch_start)/1000).toFixed(2)} seconds`
            );
            // The airports data is not ready, so have another try loading this PLN after a delay
            let seconds_since_start = (Date.now() - fetch_start) / 1000;
            if (seconds_since_start > planner.URL_TIMEOUT_S) {
                alert(`ERROR: timeout after ${seconds_since_start.toFixed(2)} seconds loading the airports.json data file`);
                return;
            }
            console.log("B21_TaskPlanner.Setting timer to retry PLN load after one second");
            setTimeout(function() {
                planner.handle_pln_str(planner, fetch_start, pln_str, name);
            }, 1000);
            return;
        }
        console.log("B21_TaskPlanner.handle_pln_str fitting map bounds");
        planner.map.fitBounds([
            [planner.task.min_lat, planner.task.min_lng],
            [planner.task.max_lat, planner.task.max_lng]
        ]);
        planner.score_tracklogs();
        planner.display_tracklogs(planner);
        planner.draw_charts();
        planner.show_task_info();
        planner.reset_edit_mode(planner); // Prevent edits when we first load a PLN file
    }

    handle_tsk_str(planner, fetch_start, tsk_str, name) {
        console.log("B21_TaskPlanner.handle string containing TSK XML '" + name + "'");
        if (planner.airports.available) {
            console.log("B21_TaskPlanner.airports available, so loading TSK");
            planner.task.load_tsk_str(tsk_str, name);
        } else {
            console.log(
                `WARNING: handle_tsk_string airports not ready after ${((Date.now() - fetch_start)/1000).toFixed(2)} seconds`
            );
            // The airports data is not ready, so have another try loading this TSK after a delay
            let seconds_since_start = (Date.now() - fetch_start) / 1000;
            if (seconds_since_start > planner.URL_TIMEOUT_S) {
                alert(`ERROR: timeout after ${seconds_since_start.toFixed(2)} seconds loading the airports.json data file`);
                return;
            }
            console.log("B21_TaskPlanner.Setting timer to retry TSK load after one second");
            setTimeout(function() {
                planner.handle_tsk_str(planner, fetch_start, tsk_str, name);
            }, 1000);
            return;
        }
        planner.map.fitBounds([
            [planner.task.min_lat, planner.task.min_lng],
            [planner.task.max_lat, planner.task.max_lng]
        ]);
        planner.score_tracklogs();
        planner.display_tracklogs(planner);
        planner.draw_charts();
        planner.show_task_info();
        planner.reset_edit_mode(planner); // Prevent edits when we first load a TSK file
    }

    // ********************************************************************************************
    // *********  Handle GPX file (from drop or URL)                   ****************************
    // ********************************************************************************************

    handle_gpx_str(planner, fetch_start, file_str, filename) {
        console.log("B21_TaskPlanner.loading GPX as tracklogs[" + planner.tracklogs.length + "]", filename);
        let tracklog = new B21_TrackLog(planner.tracklogs.length, planner, planner.map);

        let ok = tracklog.load_gpx(file_str, filename);

        if (planner.skip_pause_el.checked) {
            tracklog.skip_pause_on();
        }

        if (ok) {
            planner.tracklog_loaded(planner, tracklog);
        } else {
            alert("Problem loading GPX file "+filename);
        }
    }

    // ********************************************************************************************
    // *********  Handle IGC file (from drop or URL)                   ****************************
    // ********************************************************************************************

    handle_igc_str(planner, fetch_start, file_str, filename) {
        console.log("B21_TaskPlanner.handle_igc_str() loading IGC as tracklogs[" + planner.tracklogs.length + "]", filename);
        let tracklog = new B21_TrackLog(planner.tracklogs.length, planner, planner.map);

        let ok = tracklog.load_igc(file_str, filename);

        if (planner.skip_pause_el.checked) {
            tracklog.skip_pause_on();
        }

        if (ok) {
            planner.tracklog_loaded(planner, tracklog);
            if ((!planner.task.available() || planner.task.isLocal())  && tracklog.hasTask) {
                planner.load_task_from_tracklog(tracklog);
                planner.show_tracklogs();
            }
        } else {
            alert("B21_TaskPlanner.handle_igc_str() Problem loading IGC file "+filename);
        }
    }

    // ********************************************************************************************
    // *********  Handle CUP file (from drop or URL)                   ****************************
    // ********************************************************************************************

    handle_cup_str(planner, fetch_start, file_str, filename) {
        console.log("B21_TaskPlanner.loading CUP waypoints", filename);
        let key = filename;
        let waypoints = new B21_Local_Waypoints(planner, key); // filename here is the reference key.

        let ok = waypoints.load_cup(file_str, filename);
        if (ok) {
            // Set the local_waypoints object
            planner.local_waypoints[key] = waypoints;
            let prompt_str = `"${filename}" loaded for this session.\n\n`;
            prompt_str += `Click 'OK' if you want these waypoints reloaded each time you use this app. `;
            prompt_str += `You can enable/disable/delete these waypoints in Settings.`;
            if(confirm(prompt_str)) {
                // persist these waypoints to localStorage
                planner.settings.set_settings_local_waypoints(key, waypoints);
            }
        }
    }

    // ********************************************************************************************
    // *********  Handle COMP file (from drop or URL)                  ****************************
    // A .comp file is simply a text file containing a list of URL's
    // ********************************************************************************************

    handle_comp_str(planner, fetch_start, file_str, filename) {
        console.log("B21_TaskPlanner.loading COMP files from", filename);
        let lines = file_str.split("\n");
        for (let i=0; i < lines.length; i++) {
            let url = lines[i].replace(/(\r\n|\n|\r)/gm, "");
            let suffix = B21_Utils.file_suffix(url);
            if (url.startsWith("https://") && ["pln","tsk","igc","gpx","cup","wpr"].includes(suffix)) {
                planner.handle_url_file(planner, url);
            } else {
                if (url.length > 2) {
                    console.log(`${filename} contains bad url '${url}'`);
                }
            }
        }
    }

    // ********************************************************************************************
    // *********  Handle ZIP file (from drop or URL)                   ****************************
    // ********************************************************************************************

    handle_zip_str(planner, fetch_start, file_content, filename) {
        console.log("B21_TaskPlanner.loading ZIP files from", filename);

        JSZip.loadAsync(file_content)
            .then( function (zip) {
                zip.forEach( function (path, zip_object) {
                    if (! zip_object.dir) {
                        let name = zip_object.name;
                        console.log("B21_TaskPlanner.handle_zip_str",name);
                        zip.file(name).async("arraybuffer")
                            .then( function (file_content) {
                                planner.handle_file_content(planner, fetch_start, file_content, name);
                            });
                    }
                });
            });
    }

    // ********************************************************************************************
    // *********  Handle WPR file (from drop or URL)                   ****************************
    // ********************************************************************************************

    handle_wpr_str(planner, fetch_start, file_str, filename) {
        console.log("B21_TaskPlanner.loading WPR", filename);
        planner.init_weather(planner);
        let ok = planner.weather.load_wpr_str(file_str, filename);
        if (ok) {
            planner.weather.set_filename(filename);


            planner.show_wind_rose(planner);

            // left-pane weather info
            planner.tab_weather_el.style.display = "inline-flex"; // Hide the Weather tab unless we've loaded weather
            planner.left_pane_tabs_el.style.display = 'block';

            planner.show_weather_tab();

        }
    }

    // Show the 'Wind Rose' relevant to the current WPR
    // Note also in this planner we display "msfs_wind_arrow" which is the realtime wind from NB21 Logger
    show_wind_rose(planner) {
            console.log(`B21_TaskPlanner.show_wind_rose`);

            planner.wind_rose_el.style.display = "block";
            planner.wind_hide_el.style.display = "flex";
            planner.wind_checked_el.checked = true;

            // Speed number, knots or kph
            let speed_scalar = planner.settings.speed_units == "kph" ? planner.MS_TO_KPH : planner.MS_TO_KNOTS;
            let wind_1_str = (planner.weather.speed_ms * speed_scalar).toFixed(0);
            planner.wind_speed_1_el.innerText = wind_1_str;

            // Speed units
            let wind_units_str = planner.settings.speed_units == "kph" ? "kph" : "knots";
            planner.wind_speed_units_el.innerText = wind_units_str;

            // Direction arrow
            // Arrow image default points to 90 degrees
            let rotation_deg = (planner.weather.angle_deg+90) % 360;
            planner.wind_arrow_1_el.style.transform = "rotate("+rotation_deg.toFixed(1)+"deg)";

            // Direction arrow text

            // arrow text content
            let alt_scalar = planner.settings.altitude_units == "m" ? 1 : planner.M_TO_FEET;
            let arrow_str = (planner.weather.alt_m * alt_scalar).toFixed(0);
            arrow_str += " " + planner.settings.altitude_units;
            arrow_str += " " + (planner.weather.alt_amgl ? "AGL" : "MSL");
            planner.wind_arrow_1_text_el.innerText = arrow_str;

            // text rotation (either 0 or 180 degrees) so right way up on arrow rotation.
            if (rotation_deg > 90 && rotation_deg < 270) {
                planner.wind_arrow_1_text_el.style.transform = "rotate(180deg)";
            } else {
                planner.wind_arrow_1_text_el.style.transform = "rotate(0deg)";
            }
    }

    set_windlayer_index(windlayer_index) {
        let planner = this;
        planner.weather.set_windlayer_index(windlayer_index);
        planner.show_wind_rose(planner);
        planner.show_weather_tab();
    }

    // ********************************************************************************************
    // *********  Persist map position and scale between sessions      ****************************
    // ********************************************************************************************

    save_map_coords(center, zoom) {
        //console.log(center.toString(), zoom);
        let move_obj = {
            lat: center.lat,
            lng: center.lng,
            zoom: zoom
        };
        let move_str = JSON.stringify(move_obj);
        localStorage.setItem("b21_task_planner_map_coords", move_str);
    }

    load_map_coords() {
        let planner = this;
        let move_str = localStorage.getItem("b21_task_planner_map_coords");
        console.log("B21_TaskPlanner.load_map_coords", move_str);
        if (move_str == null | move_str == "undefined") {
            planner.map.setView(new L.latLng(52.194748, 0.144295), 11);
            return;
        }
        let move_obj = {};
        try {
            move_obj = JSON.parse(move_str);
        } catch (e) {
            console.error("bad b21_task_planner_map_coords localStorage");
            return;
        }
        if (move_obj.lat == null || move_obj.lng == null) {
            return;
        }

        planner.map.setView(new L.latLng(move_obj.lat, move_obj.lng), move_obj.zoom);
    }

    // ********************************************************************************************
    // *********  Manage the SkyVector link                            ****************************
    // ********************************************************************************************

    // Build the SkyVector button link
    // e.g. https://skyvector.com/?ll=54.65188861732224,-2.073669422461872&chart=301&zoom=1
    update_skyvector_link(center, zoom) {
        let planner = this;
        let sv_link = "https://skyvector.com/?ll=#LAT#,#LNG#&chart=301&zoom=#ZOOM#"
        let sv_zoom = 2 * (11 - zoom); // Convert OSM zoom to SV zoom
        if (sv_zoom < 1) { // limit SkyVector zoom to 1..12
            sv_zoom = 1;
        }
        if (sv_zoom > 12) {
            sv_zoom = 12;
        }
        sv_link = sv_link.replace("#LAT#", center.lat.toFixed(8));
        sv_link = sv_link.replace("#LNG#", center.lng.toFixed(8));
        sv_link = sv_link.replace("#ZOOM#", sv_zoom.toFixed(0));

        planner.skyvector_button_el.setAttribute("href", sv_link);
    }

    // ********************************************************************************************
    // *********  Request altitude                         ****************************************
    // ********************************************************************************************

    request_alt_m(planner, position, callback_ok, callback_fail) {
        console.log("B21_TaskPlanner.request_alt_m()", planner.id, position);
        // Fake the API call if not calling from correct host
        if (!document.location.href.includes("sr"+"c"+"/"+"fli"+"ghts"+"im/"+"b"+"21") &&
            !document.location.href.startsWith("ht"+"tp"+"s://"+"xp"+"-so"+"aring.git"+"hub.io") &&
            !document.location.href.startsWith("ht"+"tp"+"://"+"loc"+"alh"+"ost") &&
            !(document.location.href.startsWith("ht"+"tp"+"://") && /^\d+$/.test(document.location.href.slice(7,9)))
            ) {
            callback_ok(planner, position, 417.9);
            return;
        }
        let request_str = "ht"+"tp"+"s://"+"tfc-app9"+".cl.cam.ac.uk/";
        request_str += "82e99718-bcdc-4e66-a4e2-90734378d509/lookup";
        request_str += "?locations=" + position.lat + "," + position.lng;
        let id_str = "&id=" + planner.id;
        if (id_str=="&id=undefined") {
            id_str = "&id=bad-id-"+navigator.language;
        }
        request_str += id_str;
        let request_error = false;
        //console.log(request_str);
        try {
            fetch(request_str)
            .then(response => {
                if (!response.ok) {
                    console.log(response);
                    throw new Error(response.statusText);
                }
                //console.log("B21_TaskPlanner.response ok");
                return response.json();
            }).catch(error => {
                request_error = true;
                console.error('Elevation fetch error:', response.status, error);
                callback_fail(planner, position, "Elevation fetch error",error);
            }).then(results => {
                //console.log("B21_TaskPlanner.request_alt_m(): handle results, request_error=", request_error);
                if (!request_error){
                    console.log("B21_TaskPlanner.elevation(m):", results["results"][0]["elevation"], "query time(s):", parseFloat(results["query_time"]).toFixed(6));
                    callback_ok(planner, position, results["results"][0]["elevation"]);
                }
            }).catch(error => {
                console.error('Elevation access error:', error);
                callback_fail(planner, position, "Elevation access error",error);
            });
        } catch (e) {
            console.error('elevation request error');
            callback_fail(planner, position, "Elevation request error",error);

        }
    }

    // ********************************************************************************************
    // *********  Map click callbacks                      ****************************************
    // ********************************************************************************************

    // A left-click on the map will add a waypoint to the current task
    map_left_click(planner, e) {
        if (planner.edit_mode) {
            let position = e.latlng;
            planner.add_task_point(position);
        } else {
            // If edit_mode is false, we'll do an alt lookup rather than add waypoint
            planner.map_right_click(planner, e);
        }
    }

    // Right-click on the map does an elevation lookup
    map_right_click(planner, e) {
        planner.current_latlng = e.latlng; // Preserve 'current' latlng so page methods can use it

        if (planner.map_contextmenu == null) {
            planner.map_contextmenu = L.popup({interactive: true});
            planner.map_contextmenu.on('contextmenu', (e) => {
                console.log("B21_TaskPlanner.right click popup contextmenu");
                planner.map_right_click(planner, e);
            });
        }

        planner.request_alt_m(planner, planner.current_latlng, planner.map_alt_request_ok, planner.map_alt_request_fail);
    }

    // This is the callback for the right-click elevation request (if successful)
    map_alt_request_ok(planner, position, alt_m) {
        console.log("B21_TaskPlanner.Map right click ok", position, alt_m, planner);
        let alt_str = planner.settings.altitude_units == "m" ? alt_m.toFixed(0)+" m" : (alt_m * planner.M_TO_FEET).toFixed(0) +" feet";
        let pos_str = position.lat.toFixed(5)+"<br/>"+position.lng.toFixed(5);
        planner.map_contextmenu
            .setLatLng(position)
            .setContent("<div>"+pos_str+"<br/><b>"+alt_str+"</b></div>")
            .openOn(planner.map);
    }

    // This is the callback when the right-click elevation request fails
    map_alt_request_fail(planner, position, error_str, error) {
        console.log("B21_TaskPlanner.Map right click fail", error_str, error);
        planner.map_contextmenu
            .setLatLng(position)
            .setContent(error_str)
            .openOn(planner.map);
    }

    menuitem(menu_str, menu_function_name) {
        return '<button onclick="b21_task_planner.' + menu_function_name + '()" class="wp_menuitem">' + menu_str + '</button>';
    }

    // User has clicked somewhere on the map (called from map_left_click)
    add_task_point(position) {
        let planner = this;
        console.log("B21_TaskPlanner.add_task_point " + position);
        let wp = planner.task.add_point_wp(position);

        planner.map.closePopup();

        planner.request_alt_m(wp, position, wp.request_alt_m_ok, wp.request_alt_m_fail);

        planner.task.update_display();

        wp.display_menu(wp);
    }

    // User has clicked on an existing WP and selected 'Add this WP to task'
    append_wp_to_task() {
        let planner = this;
        console.log("B21TaskPlanner append_wp_to_task()");
        planner.task.append_current_wp();
    }

    // User has clicked on WP menu (Update waypoint elevation)
    update_wp_elevation() {
        let planner = this;
        console.log("B21_TaskPlanner.User click Update WP elevation");
        let wp = planner.task.current_wp();
        planner.request_alt_m(wp, wp.position, wp.request_alt_m_ok, wp.request_alt_m_fail);
    }

    change_wp_name(new_name) {
        let planner = this;
        console.log("B21_TaskPlanner.new wp name = ", new_name);
        let error = false;
        if (new_name.indexOf("|") != -1 || new_name.indexOf("+") != -1) {
            error = true;
            alert("Your waypoint name "+new_name+' should not contain "|" or "+".');
        }
        if (!error) {
            planner.task.current_wp().set_name(new_name);
            planner.task.display_task_info();
        } else {
            console.log("B21_TaskPlanner.new wp name had error, so ignoring an refreshing wp icon with previous name");
            let wp = planner.task.current_wp();
            wp.display_menu(wp);
        }
    }

    change_wp_icao(new_icao) {
        let planner = this;
        console.log("B21_TaskPlanner.new wp icao = ", new_icao);
        planner.task.current_wp().set_icao(new_icao);
        planner.task.display_task_info();
    }

    change_wp_runway(runway) {
        let planner = this;
        console.log(`B21_TaskPlanner.new wp runway = '${runway}'`);
        planner.task.current_wp().set_runway_str(runway);
        planner.task.display_task_info();
    }

    // Runway selected from drop-down box
    select_wp_runway(runway) {
        let planner = this;
        console.log(`B21_TaskPlanner.Selected runway '${runway}'`);
        planner.change_wp_runway(runway);
    }

    change_wp_alt(new_alt) {
        let planner = this;
        console.log("B21_TaskPlanner.new wp alt = ", new_alt);
        let wp = planner.task.current_wp();
        wp.alt_m = parseFloat(new_alt) / (planner.settings.altitude_units == "m" ? 1 : planner.M_TO_FEET);
        wp.alt_m_updated = true;
        planner.task.display_task_info();
    }

    change_wp_radius(radius_str) {
        let planner = this;
        console.log("B21_TaskPlanner.new wp radius = " + radius_str);
        let radius_m = parseFloat(radius_str) / (planner.settings.wp_radius_units == "m" ? 1 : planner.M_TO_FEET);
        let wp = planner.task.current_wp();
        if (radius_m == null || isNaN(radius_m) || radius_m == 0) {
            wp.set_radius(null);
        } else {
            wp.set_radius(radius_m);
        }
        planner.task.draw();
        planner.task.display_task_info();
    }

    change_wp_max_alt(new_alt) {
        let planner = this;
        console.log("B21_TaskPlanner.new wp max alt = ", new_alt);
        let wp = planner.task.current_wp();
        wp.max_alt_m = parseFloat(new_alt) / (planner.settings.altitude_units == "m" ? 1 : planner.M_TO_FEET);
        if (isNaN(wp.max_alt_m) || wp.max_alt_m == 0) {
            wp.max_alt_m = null;
        }
        planner.task.display_task_info();
    }

    change_wp_min_alt(new_alt) {
        let planner = this;
        console.log("B21_TaskPlanner.new wp min alt = ", new_alt);
        let wp = planner.task.current_wp();
        wp.min_alt_m = parseFloat(new_alt) / (planner.settings.altitude_units == "m" ? 1 : planner.M_TO_FEET);
        if (isNaN(wp.min_alt_m) || wp.min_alt_m == 0) {
            wp.min_alt_m = null;
        }
        planner.task.display_task_info();
    }

    remove_wp_from_task() {
        let planner = this;
        console.log("B21_TaskPlanner.remove WP from task", planner.task.current_wp().get_name());
        planner.task.remove_wp(planner.task.index);
    }

    click_soaring_task(el) {
        let planner = this;
        console.log("B21_TaskPlanner.click_soaring_task", el.checked);
        let option = el.checked;
        planner.settings.set("soaring_task", option ? 1 : 0);
    }

    // AAT checkbox on WP menu has been clicked
    click_wp_aat(e) {
        let planner = this;
        console.log("B21_TaskPlanner.click_wp_aat()",e.target.checked);
        L.DomEvent.stopPropagation(e);
        let wp = planner.task.current_wp();
        if (e.target.checked) {
            console.log("B21_TaskPlanner.click_wp_aat() checked");
            if (planner.task.finish_index == wp.index) {
                planner.task.finish_index = null;
            } else if (planner.task.start_index == wp.index) {
                planner.task.start_index = null;
            }

            if (wp.radius_m == null) {
                wp.radius_m = wp.DEFAULT_AAT_RADIUS_M;
            }
            if (planner.task.finish_index != null && planner.task.finish_index <= wp.index) {
                planner.task.finish_index = null;
            }
            wp.isAAT(true);
        } else {
            console.log("B21_TaskPlanner.click_wp_aat() unchecked");
            wp.isAAT(false);
        }
        planner.task.update_waypoint_icons();
        wp.display_menu(wp);
        planner.task.draw();
        planner.task.display_task_info();
    }

    // AAT checkbox on WP menu has been clicked
    click_wp_start(e) {
        let planner = this;
        console.log("B21_TaskPlanner.click_wp_start()",e);
        L.DomEvent.stopPropagation(e);
        let wp = planner.task.current_wp();
        if (e.target.checked) {
            console.log("B21_TaskPlanner.click_wp_start() checked");
            // See if this WP is an airport (so cannot be start or finish)
            if (wp.icao != null) {
                let alert_str = "You cannot set the departure airport as a soaring task START in a flightplan.";
                alert_str += " Create another waypoint after this one and set that as start.";
                alert_str += " See General Hint (1) in help.";
                alert(alert_str);
                e.target.checked = false;
                return;
            }
            planner.task.start_index = wp.index;
            planner.task.start_index_set = true; // Flag the fact USER has explicitly set start (so no need to guess)

            if (wp.name == null) {
                wp.name = "Start";
            }
            if (wp.radius_m == null) {
                wp.radius_m = wp.DEFAULT_START_RADIUS_M;
            }
            if (planner.task.finish_index != null && planner.task.finish_index <= wp.index) {
                planner.task.finish_index = null;
            }
            // Ensure the AAT flag is false
            wp.isAAT(false);
        } else {
            console.log("B21_TaskPlanner.click_wp_start() unchecked");
            planner.task.start_index = null;
            planner.task.start_index_set = null;
            if (wp.name == "Start") {
                wp.name = null;
            }
        }
        planner.task.update_waypoint_icons();
        wp.display_menu(wp);
        planner.task.draw();
        planner.task.display_task_info();
    }

    // AAT checkbox on WP menu has been clicked
    click_wp_finish(e) {
        let planner = this;
        console.log("B21_TaskPlanner.click_wp_finish()",e);
        L.DomEvent.stopPropagation(e);
        let wp = planner.task.current_wp();
        if (e.target.checked) {
            // See if this WP is an airport (so cannot be start or finish)
            if (wp.icao != null) {
                let alert_str = "You cannot set the destination airport as a soaring task FINISH in a flightplan.";
                alert_str += " Create a waypoint before this and set that as task FINISH.";
                alert_str += " Click Help Button on top right of page and see General Hint (1).";
                alert(alert_str);
                e.target.checked = false;
                return;
            }
            planner.task.finish_index = wp.index;
            planner.task.finish_index_set = true; // Flag the fact USER has explicitly set finish (so no need to guess)

            if (wp.name == null) {
                wp.name = "Finish";
            }
            if (wp.radius_m == null) {
                wp.radius_m = wp.DEFAULT_FINISH_RADIUS_M;
            }
            console.log("B21_TaskPlanner.Setting finish_index to", planner.task.finish_index);
            // Remove start if it is AFTER this finish
            if (planner.task.start_index != null && planner.task.start_index >= wp.index) {
                planner.task.start_index = null;
                planner.task.start_index_set = null;
            }
            // Ensure the AAT flag is false
            wp.isAAT(false);
        } else {
            planner.task.finish_index = null;
            planner.task.finish_index_set = null;
            if (wp.name == "Finish") {
                wp.name = null;
            }
        }
        planner.task.update_waypoint_icons();
        wp.display_menu(wp);
        planner.task.draw();
        planner.task.display_task_info();
    }

    // ********************************************************************************************
    // *********  Edit mode                                ****************************************
    // ********************************************************************************************

    // User clicked on 'click to edit' button on dropzone
    click_to_edit() {
        let planner = this;
        planner.set_edit_mode(planner);
    }

    // Allow editing of the task, e.g. click to add waypoint.
    set_edit_mode(planner) {
        planner.edit_mode = true;
        planner.edit_mode_el.style.display = "none";
        if (planner.task != null) {
            planner.task.set_edit_mode();
        }
    }

    reset_edit_mode(planner) {
        planner.edit_mode = false;
        planner.edit_mode_el.style.display = "block";
        if (planner.task != null) {
            planner.task.reset_edit_mode();
        }
    }

    // ********************************************************************************************
    // *********  Reset things                             ****************************************
    // ********************************************************************************************

    init_task(planner) {
        planner.set_edit_mode(planner);
        if (planner.task) {
            planner.task.reset();
        } else {
            // Task object to hold accumulated waypoints
            planner.task = new B21_Task(planner);
        }
    }

    init_replay(planner) {
        planner.replay_restart();
    }

    init_tracklog_info(planner) {
        planner.rescore_button_el.style.display = "none";
        planner.tracklog_info_el.style.display = "none";
        planner.scoresheet_csv = false; // determines tracklogs scores layout text vs csv
    }

    init_weather(planner) {
        planner.weather.init();
        planner.wind_rose_position = 0; // position of wind rose in left pane: 0 = top left, then clockwise
        planner.wind_rose_el.style.display = "none";
        planner.wind_hide_el.style.display = "none";
        planner.wind_checked_el.checked = true;
        planner.weather_info_el.style.display = "none";
        planner.set_wind_rose_position();
    }

    // ********************************************************************************************
    // *********  Page buttons                             ****************************************
    // ********************************************************************************************

    reset_all_button() {
        let planner = this;
        console.log("reset_all_button()");

        if (planner.multiplayer_local_checkbox_el.checked) {
            console.log("reset_all_button, multiplayer_local_checkbox checked");
            planner.multiplayer_local_checkbox_el.checked = false;
            planner.nb21.close_connection();
        }

        planner.reset_all();

    }

    download_pln() {
        let planner = this;
        console.log("B21_TaskPlanner.download_pln()");
        try {
            planner.task.save_file_pln();
        } catch (e) {
            alert(e.message);
            console.warn(e);
            return;
        }
    }

    download_tsk() {
        let planner = this;
        console.log("B21_TaskPlanner.download_tsk()");
        try {
            planner.task.save_file_tsk();
        } catch (e) {
            alert("No flightplan to download.");
            console.warn(e);
            return;
        }
    }

    download_kml() {
        let planner = this;
        console.log("B21_TaskPlanner.download_kml()");
        try {
            planner.task.save_file_kml();
        } catch (e) {
            alert("No flightplan to download.");
            console.warn(e);
            return;
        }
    }

    send_task_to_logger() {
        let planner = this;
        console.log("B21_TaskPlanner.send_task_to_logger()");
        try {
            let msfs_pln = new B21FilePLN(planner.task);
            let pln_xml_str = msfs_pln.get_text();
            planner.nb21.pln_set(planner.nb21, pln_xml_str);
        } catch (e) {
            alert("No flightplan to download.");
            console.warn(e);
            return;
        }
    }

    update_elevations() {
        let planner = this;
        console.log("B21_TaskPlanner.Update elevations");
        planner.task.update_elevations();
    }

    zoom_to_task() {
        let planner = this;
        if (planner.task.available()) {
            planner.task.update_bounds();
            console.log([
                [planner.task.min_lat, planner.task.min_lng],
                [planner.task.max_lat, planner.task.max_lng]
            ]);
            planner.map.fitBounds([
                [planner.task.min_lat, planner.task.min_lng],
                [planner.task.max_lat, planner.task.max_lng]
            ]);
            return;
        }
        for (let i=0; i<planner.tracklogs.length; i++) {
            let tracklog = planner.tracklogs[i];
            if (tracklog.checked) {
                if (tracklog.map_bounds != null) {
                    planner.map.fitBounds(tracklog.map_bounds);
                    return;
                }
            }
        }
        alert("No task or selected tracklog to zoom to.");
    }

    toggle_settings() {
        let planner = this;
        planner.settings.toggle();
    }

    // User has typed in search box
    search(e) {
        let planner = this;
        planner.search_results_el.style.display = "none";
        let search_value = planner.search_input_el.value.toLowerCase();
        console.log("B21_TaskPlanner.search", search_input.value);
        if (!planner.airports.available) {
            return;
        }
        if (search_value.length < 3) {
            return;
        }

        // Search airports (msfs and ourairports)
        let airports_results = planner.airports.search(search_value);
        console.log("B21_TaskPlanner.airports search results", airports_results);

        // Search local waypoints
        let local_waypoints_results = [];
        for (let i=0; i<planner.settings.local_waypoints_info.length; i++) {
            let wp_info = planner.settings.local_waypoints_info[i];
            console.log("B21_TaskPlanner.searching local_waypoints[",wp_info.local_waypoints_key,"]");
            if (wp_info.active) {
                let waypoints = planner.local_waypoints[wp_info.local_waypoints_key];
                let wp_results = waypoints.search(search_value);
                console.log(wp_info.local_waypoints_key, "wp_results length",wp_results.length);
                local_waypoints_results = local_waypoints_results.concat(wp_results);
            }
        }

        console.log("B21_TaskPlanner.local_waypoints search results", local_waypoints_results);

        let results = airports_results.concat(local_waypoints_results);

        // Sort results based on distance from current map center
        let map_center = planner.map.getCenter();
        results.sort((a,b) => {
            let da = Geo.get_distance_m(a,map_center);
            let db = Geo.get_distance_m(b,map_center);
            return db > da ? -1 : 1;
        });

        if (results.length > 0) {
            while (planner.search_results_el.firstChild) {
                planner.search_results_el.removeChild(planner.search_results_el.lastChild);
            }
            planner.search_results_el.style.display = "block";
            for (let i = 0; i < results.length; i++) {
                let location = results[i];
                let result_el = document.createElement("div");
                result_el.className = "search_result";
                let marker_el = document.createElement("div");
                marker_el.className = location.source == "msfs_airports" ? "search_result_marker_msfs"
                                    : location.source == "ourairports" ? "search_result_marker_ourairports"
                                    : "search_result_marker_waypoint";
                result_el.appendChild(marker_el);
                //console.log("B21_TaskPlanner.marker for ",location.source,marker_el.className);
                let text_el = document.createElement("div");
                text_el.className = "search_result_text";
                text_el.innerHTML = (location["id"] + " " + location["name"]).replaceAll(" ", "&nbsp;");
                result_el.appendChild(text_el);

                result_el.onclick = (e) => {
                    planner.search_results_el.style.display = "none";
                    planner.search_result_clicked(planner, location);
                }
                planner.search_results_el.appendChild(result_el);
            }
        }
    }

    search_result_clicked(planner, location) {
        console.log("B21_TaskPlanner.result clicked", location);
        let lat = location["lat"];
        let lng = location["lng"];
        // Set the search_ident so draw() knows the redraw is due to a search and can highlight the location on map
        if (location.local_waypoints_key != null) {
            planner.local_waypoints[location.local_waypoints_key].search_location_id = location.id;
        }
        planner.airports.search_ident = location["ident"];
        planner.map.panTo([lat, lng]);
    }


    left_pane_hide_click() {
        let planner = this;
        console.log("B21_TaskPlanner.left_pane_hide_click()");
        planner.left_pane_el.style.display = "none";
        planner.left_pane_show_el.style.display = "inline-block";
        planner.right_pane_el.style.width = "calc(98% - 50px)";
        planner.set_wind_rose_position();
        planner.resize_charts();
        planner.map.invalidateSize();
    }

    left_pane_show_click() {
        let planner = this;
        console.log("B21_TaskPlanner.left_pane_show_click()");
        planner.left_pane_el.style.display = "inline-block";
        planner.left_pane_show_el.style.display = "none";
        console.log("B21_TaskPlanner.left_pane width=", planner.left_pane_el.clientWidth);
        let left_pane_width_px = planner.left_pane_el.clientWidth;
        planner.right_pane_el.style.width = "calc(98% - " + (left_pane_width_px + 25).toFixed(0) + "px)";
        planner.set_wind_rose_position();
        planner.resize_charts();
        planner.map.invalidateSize();
    }

    wind_hide_clicked() {
        let planner = this;
        console.log("B21_TaskPlanner.wind_hide_clicked() position="+planner.wind_rose_position);
        let hidden = planner.wind_rose_el.style.display == "none";
        if (hidden) {
            planner.set_wind_rose_position();
            planner.wind_rose_el.style.display = "block";
        } else {
            planner.wind_rose_el.style.display = "none";
            console.log("B21_TaskPlanner.wind_hide_clicked() updated position="+planner.wind_rose_position);
        }
    }

    wind_position_clicked() {
        let planner = this;
        if (planner.wind_rose_el.style.display == "none") {
            return;
        }
        planner.wind_rose_position = planner.wind_rose_position == 4 ? 0 : planner.wind_rose_position + 1;
        planner.set_wind_rose_position();
    }

    set_wind_rose_position() {
        let planner = this;
        if (planner.wind_rose_position == 0) {
            planner.wind_rose_el.style.left = "20px";
            planner.wind_rose_el.style.top = "20px";
        } else if (planner.wind_rose_position == 1) {
            planner.wind_rose_el.style.left = (planner.map_el.clientWidth - planner.wind_rose_el.clientWidth - 50).toFixed(0)+"px";
            planner.wind_rose_el.style.top = "20px";
        } else if (planner.wind_rose_position == 2) {
            planner.wind_rose_el.style.left = (planner.map_el.clientWidth - planner.wind_rose_el.clientWidth - 50).toFixed(0)+"px";
            planner.wind_rose_el.style.top = (planner.map_el.clientHeight - planner.wind_rose_el.clientWidth - 30).toFixed(0)+"px";
        } else if (planner.wind_rose_position == 3) {
            planner.wind_rose_el.style.left = "20px";
            planner.wind_rose_el.style.top = (planner.map_el.clientHeight - planner.wind_rose_el.clientWidth - 30).toFixed(0)+"px";
        } else if (planner.wind_rose_position == 4) {
            planner.wind_rose_el.style.left = `calc(50% - ${(planner.wind_rose_el.clientWidth/2).toFixed(0)}px)`;
            planner.wind_rose_el.style.top = `calc(50% - ${(planner.wind_rose_el.clientWidth/2).toFixed(0)}px)`;
        }
    }

    // *************************************************************************************************************************
    // *************************************************************************************************************************
    // Replay - animates all checked tracklogs
    // The planner loops with a fixed period (REPLAY_TIMESTEP_MS)
    //
    // planner.replay_ts:              core timestamp all tracklogs are synced to via tracklog.replay_ts(planner.replay_ts)
    // planner.replay_speed:           multiplier for timestep for each update
    // planner.replay_start_datetime:  JS Date() initialised at replay start, so we can stay in sync with realtime
    //
    // *************************************************************************************************************************
    // *************************************************************************************************************************

    replay_play() {
        console.log("B21_TaskPlanner replay_play()");
        let planner = this;
        clearTimeout(planner.replay_timer); // ensure only one running timer
        if (planner.tracklogs_checked_count(planner) == 0) {
            alert("No tracklogs selected to play.");
            return;
        }
        planner.replay_mode = true;

        // Init the replay timers
        planner.replay_start_datetime = new Date();
        planner.replay_start_ts = planner.replay_ts;
        console.log(`replay_play() setting replay_start_ts: ${B21_Utils.hh_mm_ss_from_ts(planner.replay_start_ts)} real: ${B21_Utils.hh_mm_ss_from_datetime(planner.replay_start_datetime)}`);

        // Start the looping with this first call to replay_continue()
        planner.replay_continue(planner);
    }

    replay_continue(planner) {
        //console.log("B21_TaskPlanner.replay_continue()");
        const REPLAY_TIMESTEP_MS = 100; // wait time at the end of each iteration of this update loop.

        // Update the UI time display
        planner.replay_update_time(planner);

        // Iterate the tracklogs and set their current logpoints index to replay time
        for (let i = 0; i < planner.tracklogs.length; i++) {
            planner.tracklogs[i].replay_ts(planner.replay_ts);
        }

        // Update global replay timer (in seconds)
        if (planner.replay_speed == 1) {
            let now = new Date();
            planner.replay_ts = planner.replay_start_ts + (now - planner.replay_start_datetime) / 1000;
            //console.log(`replay_continue() at ${B21_Utils.hh_mm_ss_from_datetime(now)} speed=1 with replay_start_ts: ${B21_Utils.hh_mm_ss_from_ts(planner.replay_start_ts)} replay_start_datetime: ${B21_Utils.hh_mm_ss_from_datetime(planner.replay_start_datetime)}`);
        } else {
            planner.replay_ts += planner.replay_speed * REPLAY_TIMESTEP_MS / 1000;
        }

        // If we've reached the latest timestamp in all the tracklogs
        // we will terminate the repeating loop by NOT calling setTimeout
        if (planner.replay_ts > planner.replay_end_ts) {
            console.log("B21_TaskPlanner.Replay ended for all tracklogs");
            planner.replay_restart();
        } else {
            // Call this again after a fixed delay
            planner.replay_timer = setTimeout(() => {
                planner.replay_continue(planner);
            }, REPLAY_TIMESTEP_MS);
        }
    }

    replay_pause() {
        let planner = this;
        console.log("B21_TaskPlanner.replay_pause()");
        clearTimeout(planner.replay_timer);
    }

    // reset replay timer back by 10 mins & pause
    replay_back(s) {
        let planner = this;
        console.log(`B21_TaskPlanner.replay_back(${s})`);
        // Update the UI time display using planner.replay_ts
        planner.replay_ts -= s; // subtract s seconds
        planner.replay_update_time(planner);

        // Iterate the tracklogs and set their current logpoints index to replay time
        for (let i = 0; i < planner.tracklogs.length; i++) {
            planner.tracklogs[i].set_logpoints_index(0);
            planner.tracklogs[i].replay_ts(planner.replay_ts);
        }

        planner.replay_pause();
    }

    replay_restart() {
        let planner = this;
        console.log("B21_TaskPlanner.replay_restart()");

        // Init the replay timers
        planner.replay_start_datetime = new Date();
        planner.replay_start_ts = planner.replay_ts;
        console.log(`replay_restart() with replay_start_ts: ${B21_Utils.hh_mm_ss_from_ts(planner.replay_start_ts)} replay_start_datetime: ${B21_Utils.hh_mm_ss_from_datetime(planner.replay_start_datetime)}`);

        // Stop the replay timer running, just in case
        clearTimeout(planner.replay_timer);

        // Update the replay bar
        planner.replay_speed_el.innerHTML = "x" + planner.replay_speed;

        planner.replay_ts = null;

        // Calculate a 'start_ts' from all the tracklogs
        let start_ts = null;
        for (let i = 0; i < planner.tracklogs.length; i++) {
            //console.log(`b21_task_manager resetting tracklog ${i}`);
            let tracklog = planner.tracklogs[i];
            tracklog.replay_restart();
            // Collect the begin / end timestamp bounds for all the checked logs
            if (tracklog.checked && tracklog.logpoints.length > 0) {
                // Update planner.replay_ts if this tracklog begins earlier
                let current_start_ts;
                if (planner.replay_sync) {
                    current_start_ts = tracklog.get_start_ts();
                    if (current_start_ts == null) {
                        continue; // skip this tracklog
                    }
                } else {
                    current_start_ts = tracklog.get_begin_ts();
                }

                if (start_ts == null || (current_start_ts != null && start_ts > current_start_ts)) {
                    start_ts = current_start_ts;
                    //console.log("B21_TaskPlanner.Updating b21_task_planner.replay_ts with begin time of GPX", start_ts, tracklog.get_filename());
                }

                // Update planner.replay_end_ts if this tracklog ends later
                let end_ts = tracklog.logpoints[tracklog.logpoints.length - 1].ts;
                if (planner.replay_end_ts == null || planner.replay_end_ts < end_ts) {
                    planner.replay_end_ts = end_ts;
                    console.log("B21_TaskPlanner.Updating b21_task_planner.replay_end_ts with end time of GPX", planner.replay_end_ts, tracklog.get_filename());
                }
            }
        }
        // Here is where planner.replay.ts gets initialised
        planner.replay_ts = start_ts;

        // Given current start_ts, set time offset for each log
        for (let i = 0; i < planner.tracklogs.length; i++) {
            let tracklog = planner.tracklogs[i];
            if (planner.replay_sync) {
                tracklog.replay_update_offset(start_ts);
            } else {
                tracklog.replay_update_offset(null);
            }

        }

        planner.replay_mode = false;
        planner.replay_update_time(planner);
    }

    replay_slower() {
        let planner = this;
        let replay_inc = planner.replay_speed <= 5 ? 1 : 5;
        planner.replay_speed -= replay_inc;
        if (planner.replay_speed < 1.1) { // Detect  speed == 1 which is special case for accurate real-world clock sync.
            planner.replay_start_datetime = new Date();
            planner.replay_start_ts = planner.replay_ts;
            console.log(`replay_slower() speed set to 1 at sim: ${B21_Utils.hh_mm_ss_from_ts(planner.replay_ts)} real: ${B21_Utils.hh_mm_ss_from_datetime(planner.replay_start_datetime)}`);
            console.log(`replay_slower() replay_start_ts updated to ${B21_Utils.hh_mm_ss_from_ts(planner.replay_start_ts)}`);
            planner.replay_speed = 1;
        }
        planner.replay_speed_el.innerHTML = "x" + planner.replay_speed;
    }

    replay_faster() {
        let planner = this;
        let replay_inc = planner.replay_speed < 5 ? 1 : 5;
        planner.replay_speed += replay_inc;
        planner.replay_speed_el.innerHTML = "x" + planner.replay_speed;
    }

    // User has clicked the replay_hide_chart button to show/hide the charts
    replay_hide_chart() {
        let planner = this;
        console.log("B21_TaskPlanner.replay_hide_chart currently charts_hidden = ", planner.charts_hidden);
        if (planner.charts_hidden) {
            planner.show_charts(planner);
        } else {
            planner.hide_charts(planner);
        }
        planner.set_wind_rose_position();
        planner.map.invalidateSize();
    }

    // User has clicked the replay_hide_tracks button to show/hide the tracks on the map
    replay_hide_tracks() {
        let planner = this;
        console.log("B21_TaskPlanner.replay_hide_tracks currently tracks_hidden = ", planner.tracks_hidden);
        if (planner.tracks_hidden) {
            planner.show_tracks_on_map(planner);
            planner.replay_hide_tracks_el.innerHTML = "hide map tracks";
        } else {
            planner.hide_tracks_on_map(planner);
            planner.replay_hide_tracks_el.innerHTML = "show map tracks";
        }
    }

    replay_sync_click() {
        let planner = this;
        if (planner.replay_sync_el.checked) {
            console.log("B21_TaskPlanner.replay_sync_click ON");
            if (!planner.task.available()) {
                alert("You must have a task loaded for 'Sync starts' to work");
                planner.replay_sync_el.checked = false;
                return;
            }
            planner.replay_sync = true;
            planner.replay_restart();
        } else {
            console.log("B21_TaskPlanner.replay_sync_click OFF");
            planner.replay_sync = false;
            planner.replay_restart();
        }
    }

    skip_pause_loop(planner, i) {
        console.log(`skip_pause_loop ${i}`);
        if (i==0) {
            planner.skip_pause_progress_el.style.display = "block";
            planner.skip_pause_progress_el.style.width = "0px";
        } else if (i==planner.tracklogs.length) {
            planner.skip_pause_progress_el.style.display = "none";
            planner.score_tracklogs();
            planner.display_tracklogs(planner);
            return;
        } else {
            planner.skip_pause_progress_el.style.width = ( (i+1) / (planner.tracklogs.length+1) * 100).toFixed(0)+"%";
        }
        planner.tracklogs[i].skip_pause_on();
        window.setTimeout( () => { planner.skip_pause_loop(planner,i+1); }, 10);
    }

    // User has clicked the 'skip pause' checkbox on the replay bar
    skip_pause_click() {
        let planner = this;
        if (planner.skip_pause_el.checked) {
            console.log("B21_TaskPlanner.skip_pause_click ON");
            window.setTimeout( () => { planner.skip_pause_loop(planner,0); }, 10);
        } else {
            console.log("B21_TaskPlanner.skip_pause_click OFF");
            for (let i=0; i<planner.tracklogs.length; i++) {
                planner.tracklogs[i].skip_pause_off();
            }
        }
    }

    // User has clicked the 'icon data' checkbox on the replay bar
    icon_data_name_click() {
        let planner = this;
        planner.players.set_names_display(planner.icon_data_name_el.checked);

        if (planner.icon_data_name_el.checked) {
            console.log("B21_TaskPlanner.icon_data_name_click ON");
            for (let i = 0; i < planner.tracklogs.length; i++) {
                planner.tracklogs[i].show_icon_name_data();
            }
        } else {
            console.log("B21_TaskPlanner.icon_data_name_click OFF");
            for (let i = 0; i < planner.tracklogs.length; i++) {
                planner.tracklogs[i].hide_icon_name_data();
            }
        }
    }

    // User has clicked the 'icon data' checkbox on the replay bar
    icon_data_altitude_click() {
        let planner = this;
        planner.players.set_altitude_display(planner.icon_data_altitude_el.checked);

        if (planner.icon_data_altitude_el.checked) {
            console.log("B21_TaskPlanner.icon_data_altitude_click ON");
            for (let i = 0; i < planner.tracklogs.length; i++) {
                planner.tracklogs[i].show_icon_altitude_data();
            }
        } else {
            console.log("B21_TaskPlanner.icon_data_altitude_click OFF");
            for (let i = 0; i < planner.tracklogs.length; i++) {
                planner.tracklogs[i].hide_icon_altitude_data();
            }
        }
    }

    // User has clicked the 'icon data' checkbox on the replay bar
    icon_data_speed_click() {
        let planner = this;
        planner.players.set_speed_display(planner.icon_data_speed_el.checked);

        if (planner.icon_data_speed_el.checked) {
            console.log("B21_TaskPlanner.icon_data_speed_click ON");
            for (let i = 0; i < planner.tracklogs.length; i++) {
                planner.tracklogs[i].show_icon_speed_data();
            }
        } else {
            console.log("B21_TaskPlanner.icon_data_speed_click OFF");
            for (let i = 0; i < planner.tracklogs.length; i++) {
                planner.tracklogs[i].hide_icon_speed_data();
            }
        }
    }

    // Update the time displayed in the replay bar
    replay_update_time(planner) {
        let ts = planner.replay_ts == null ? 0 : planner.replay_ts;

        planner.replay_time_el.innerHTML = (new Date(ts * 1000)).toUTCString().substring(5, 25) + "Z";
    }

    // ********************************************************************************************
    // *********  Tabs Area                                ****************************************
    // ********************************************************************************************

    tab_task_click() {
        let planner = this;
        planner.show_task_info();
        planner.close_tracklog_info(); // Close tracklog info popup window
    }

    tab_weather_click() {
        let planner = this;
        planner.show_weather_tab();
        planner.close_tracklog_info(); // Close tracklog info popup window
    }

    tab_tracklogs_click() {
        let planner = this;
        planner.show_tracklogs();
        planner.score_tracklogs();
        planner.close_tracklog_info(); // Close tracklog info popup window
    }

    rescore_click() {
        let planner = this;
        let showing_scores = planner.showing_scores;
        planner.show_tracklogs();
        planner.close_tracklog_info(); // Close tracklog info popup window
        planner.score_tracklogs();
        if (showing_scores) {
            planner.display_tracklogs(planner);
        } else {
            planner.display_scores(planner);
        }
    }

    // Show task info
    show_task_info() {
        let planner = this;
        planner.update_rescore_button();
        planner.task.display_task_info();
        planner.tab_task_el.className = "tab_active";
        //planner.task_info_el.style.display = "block";
        // hide weather
        planner.weather_info_el.style.display = "none";
        planner.tab_weather_el.className = "tab_inactive";
        // hide tracklogs
        planner.tab_tracklogs_el.className = "tab_inactive";
        planner.tracklogs_el.style.display = "none";
    }

    // Show weather info
    show_weather_tab() {
        let planner = this;
        console.log("B21_TaskPlanner.show_weather_tab()");
        if (planner.weather.filename == null) {
            planner.weather_info_el.innerText = "NO WEATHER LOADED";
            return;
        }
        planner.weather.display_weather_info(planner.weather_info_el);
        // show weather
        planner.tab_weather_el.className = "tab_active";
        planner.weather_info_el.style.display = "block";
        // hide task info
        planner.tab_task_el.className = "tab_inactive";
        planner.task.hide_task_info();
        // hide tracklogs
        planner.tab_tracklogs_el.className = "tab_inactive";
        planner.tracklogs_el.style.display = "none";
    }

    // Show list of tracklogs
    show_tracklogs() {
        let planner = this;
        console.log("B21_TaskPlanner.show_tracklogs()");
        planner.update_rescore_button();
        planner.display_tracklogs(planner);
        planner.tab_task_el.className = "tab_inactive";
        // hide weather
        planner.weather_info_el.style.display = "none";
        planner.tab_weather_el.className = "tab_inactive";
        // show tracklogs
        planner.tab_tracklogs_el.className = "tab_active";
        planner.tracklogs_el.style.display = "block";
        planner.task.hide_task_info();
    }

    update_rescore_button() {
        let planner = this;
        if (planner.task.available()) {
            planner.rescore_button_el.style.display = "inline-flex";
        } else {
            planner.rescore_button_el.style.display = "none";
        }
    }

    // ********************************************************************************************
    // *********  Tracklogs                                ****************************************
    // ********************************************************************************************

    init_tracklogs(planner) {
        // Discard existing tracklogs
        planner.tracklogs = [];
        // Empty the 'tracklogs' div
        B21_Utils.clear_div(planner.tracklogs_el);
        // Hide the tabs in the left-pane
        planner.left_pane_tabs_el.style.display = "none";
        planner.showing_scores = false;
    }

    sort_tracklog_indexes(planner) {
        // Create array with tracklogs sorted by speed (no task, or incompleted task => 0)
        let sorted_tracklog_indexes = [];

        for (let i=0; i < planner.tracklogs.length; i++) {
            let tracklog = planner.tracklogs[i];
            let speed = tracklog.scoring_data == null ? 0 :
                tracklog.scoring_data.finished_ok == null ? 0 :
                tracklog.scoring_data.finished_ok.task_speed_ms ;

            let distance = tracklog.scoring_data == null ? 0 :
                tracklog.scoring_data.landout == null ? 0 :
                tracklog.scoring_data.landout.max_distance_m;

            sorted_tracklog_indexes.push({ tracklog_index: i, speed: speed, distance: distance});
        }
        sorted_tracklog_indexes.sort( (a,b) => {
            let speed_diff = b.speed - a.speed;
            let distance_diff = b.distance - a.distance;
            let diff = (a.speed != 0 || b.speed != 0) ? speed_diff : distance_diff;
            return diff;
        } );

        return sorted_tracklog_indexes;
    }

    // Display the complete list of sorted tracklogs on the Tracklogs tab
    display_tracklogs(planner) {

        planner.showing_scores = false;

        B21_Utils.clear_div(planner.tracklogs_el);

        let tracklogs_table_el = document.createElement("table");
        tracklogs_table_el.id = "tracklogs_table";

        let sorted_tracklog_indexes = planner.sort_tracklog_indexes(planner);

        // Add tracklog entries sorted by speed
        for (let i = 0; i < sorted_tracklog_indexes.length; i++) {
            let tracklog_index = sorted_tracklog_indexes[i].tracklog_index;
            planner.tracklogs[tracklog_index].display_entry(tracklogs_table_el);
        }
        planner.tracklogs_el.appendChild(tracklogs_table_el);
    }

    // Display scoresheet on the Tracklogs tab
    display_scores(planner) {

        planner.showing_scores = true;

        B21_Utils.clear_div(planner.tracklogs_el);

        let scoresheet_el = document.createElement("div");
        scoresheet_el.id = "tracklogs_scoresheet";

        // Show CSV checkbox
        let scoresheet_csv_div_el = document.createElement("div");
        scoresheet_csv_div_el.id = "tracklogs_scoresheet_csv_div";
        let csv_checkbox_button_el = document.createElement("button");
        let csv_checkbox_el = document.createElement("input");
        csv_checkbox_el.setAttribute("type","checkbox");
        csv_checkbox_el.checked = planner.scoresheet_csv;
        // Set up click callback, where e will be the element clicked
        csv_checkbox_el.addEventListener("click", (e) => {
            planner.scoresheet_csv_checkbox_clicked(planner, e);
        });

        let csv_checkbox_text_el = document.createTextNode("CSV");
        csv_checkbox_button_el.appendChild(csv_checkbox_el);
        csv_checkbox_button_el.appendChild(csv_checkbox_text_el);
        scoresheet_csv_div_el.appendChild(csv_checkbox_button_el);
        scoresheet_el.appendChild(scoresheet_csv_div_el);

        let sorted_tracklog_indexes = planner.sort_tracklog_indexes(planner);

        // Add tracklog entries sorted by speed
        for (let i = 0; i < sorted_tracklog_indexes.length; i++) {
            let tracklog_index = sorted_tracklog_indexes[i].tracklog_index;
            planner.tracklogs[tracklog_index].display_scoresheet_entry(scoresheet_el, planner.scoresheet_csv);
        }
        planner.tracklogs_el.appendChild(scoresheet_el);
    }

    scoresheet_csv_checkbox_clicked(planner, e) {
        console.log(`B21_TaskPlanner.scoresheet_csv_checkbox_clicked ${e.currentTarget.checked}`);
        planner.scoresheet_csv = e.currentTarget.checked;
        planner.display_scores(planner);
    }

    // * Handle loaded tracklog
    tracklog_loaded(planner, tracklog) {
        console.log(`B21_TaskPlanner.tracklog_loaded ${tracklog.name} zoom=${planner.map.getZoom()}`);
        planner.tracklogs.push(tracklog);
        planner.tracklog_index = planner.tracklogs.length - 1;

        tracklog.draw_map();

        planner.left_pane_tabs_el.style.display = 'block';

        // zoom the map to the polyline
        //DEBUG before zooming to tracklog check to see if we have already zoomed to task
        try {
            //console.log(`B21_TaskPlanner.tracklog_loaded ${tracklog.name} fitting bounds zoom=${planner.map.getZoom()}`);
            if (!planner.task.available()) {
                planner.map.fitBounds(tracklog.map_bounds);
            }
            //console.log(`B21_TaskPlanner.tracklog_loaded ${tracklog.name} fitted bounds zoom=${planner.map.getZoom()}`);
        } catch (e) {
            console.error("B21_TaskPlanner.tracklog_loaded fitBounds error with:", tracklog.map_bounds, e);
        }
        if (planner.task != null) {
            console.log(`B21_TaskPlanner.tracklog_loaded calling tracklog.score_task()`);
            tracklog.score_task();
        }
        tracklog.draw_chart();

        console.log(`B21_TaskPlanner.tracklog_loaded end ${tracklog.name} zoom=${planner.map.getZoom()}`);
    }

    set_current_tracklog(index) {
        let planner = this;
        console.log(`B21_TaskPlanner.set_current_tracklog(${index}`);
        for (let i = 0; i < planner.tracklogs.length; i++) {
            if (i == index) {
                planner.tracklogs[i].tracklogs_entry_el.className = "tracklogs_entry_current";
            } else {
                planner.tracklogs[i].tracklogs_entry_el.className = "tracklogs_entry";
            }
        }
        planner.tracklog_index = index;
        planner.tracklogs[index].show();
    }

    scoring_penalties() {
        let planner = this;
        return planner.settings.scoring_penalties == "yes";
    }

    score_tracklogs() {
        let planner = this;
        for (let i = 0; i < planner.tracklogs.length; i++) {
            planner.tracklogs[i].score_task();
        }
        //planner.display_tracklogs(planner);
    }

    // User has checked or unchecked the checkbox in the "Tracklogs" header
    tracklogs_select_all_clicked() {
        let planner = this;
        console.log("B21_TaskPlanner.tracklogs_select_all_clicked", planner.tracklogs_select_all_el.checked);
        if (planner.tracklogs_select_all_el.checked) {
            // Select all CHECKED
            for (let i=0; i<planner.tracklogs.length; i++) {
                planner.tracklogs[i].checked = true;
                planner.tracklogs[i].show();
            }
        } else {
            // Select all UNCHECKED
            planner.task.remove_aat_lines();
            for (let i=0; i<planner.tracklogs.length; i++) {
                planner.tracklogs[i].checked = false;
                planner.tracklogs[i].hide();
            }
        }
        planner.display_tracklogs(planner);
        planner.adjust_right_pane(planner);
        planner.replay_restart();
    }

    // Handle tick of checkbox on Tracklogs tab
    tracklog_checkbox_clicked(planner, e, tracklog_index) {
        console.log(`B21_TaskPlanner.tracklog_checkbox_clicked ${tracklog_index} checked=${e.target.checked}`);

        let checked_count = planner.tracklogs_checked_count(planner);
        console.log("B21_TaskPlanner.checked_count", checked_count);

        if (e.target.checked) {
            // CHECKED
            console.log("B21_TaskPlanner.tracklog was checked");
            planner.set_current_tracklog(tracklog_index);
        } else {
            // UNCHECKED
            console.log("B21_TaskPlanner.tracklog was unchecked");
            planner.tracklog_info_el.style.display = "none";
            planner.task.remove_aat_lines();
            planner.tracklogs[tracklog_index].hide();
        }
        console.log("B21_TaskPlanner.tracklog_checkbox_clicked: redrawing map");
        planner.adjust_right_pane(planner);
        planner.replay_restart();
    }

    // Return the count of how many tracklogs currently have ticked checkboxes
    tracklogs_checked_count(planner) {
        let count = 0;
        if (planner.tracklogs != null) {
            for (let i = 0; i < planner.tracklogs.length; i++) {
                if (planner.tracklogs[i].checked) {
                    count++;
                }
            }
        }
        return count;
    }

    // Show single tracklog info
    show_tracklog_info() {
        let planner = this;
        planner.tracklog_info_el.style.display = "block";
        if (planner.tracklog_index != null) {
            planner.tracklogs[planner.tracklog_index].display_info();
        } else {
            document.getElementById("tracklog_info").innerHTML = "No tracklogs loaded";
        }
    }

    // Close the tracklog_info panel
    close_tracklog_info() {
        let planner = this;
        if (planner.tracklogs.length > 0 && planner.tracklog_index != null && planner.tracklog_index < planner.tracklogs.length) {
            planner.tracklogs[planner.tracklog_index].tracklog_info_exit();
        }
        planner.tracklog_info_el.style.display = "none";
    }

    // User has clicked the "load task" button on the tracklog info
    load_task_from_current_tracklog() {
        let planner = this;
        //console.log(`B21TaskPlanner.load_task_from_current_tracklog ${planner.tracklog_index}`);
        planner.load_task_from_tracklog(planner.tracklogs[planner.tracklog_index]);
        planner.close_tracklog_info();
    }

    load_task_from_tracklog(tracklog) {
        let planner = this;
        //console.log(`B21TaskPlanner.load_task_from_tracklog ${tracklog.index}`);
        planner.task.load_task_from_tracklog(tracklog);
        planner.map.fitBounds([
            [planner.task.min_lat, planner.task.min_lng],
            [planner.task.max_lat, planner.task.max_lng]
        ]);
        planner.score_tracklogs();
        planner.display_tracklogs(planner);
        planner.draw_charts();
        planner.show_task_info();
        planner.reset_edit_mode(planner); // Prevent edits when we first load a PLN file

    }

    // User click on "draw AAT route" button on tracklog info page
    draw_aat_for_current_tracklog() {
        let planner = this;
        console.log(`B21TaskPlanner.draw_aat_for_current_tracklog ${planner.tracklog_index}`);
        planner.tracklogs[planner.tracklog_index].draw_aat();
        planner.close_tracklog_info();
    }

    resize_charts() {
        let planner = this;
        //console.log("B21TaskPlanner.resize_charts()");
        for (let i = 0; i < planner.tracklogs.length; i++) {
            let tracklog = planner.tracklogs[i];
            if (tracklog.checked) {
                tracklog.resize_chart();
            }
        }
    }

    draw_charts() {
        let planner = this;
        //console.log("B21TaskPlanner.draw_charts()");
        for (let i = 0; i < planner.tracklogs.length; i++) {
            let tracklog = planner.tracklogs[i];
            if (tracklog.checked) {
                tracklog.draw_chart();
            }
        }
    }

    // **************************************************************
    // Scoring event checkbox click
    // **************************************************************

    scoring_event_click(tracklog_index, scoring_event_index) {
        let planner = this;
        //console.log(`B21TaskPlanner.scoring_event_click(${tracklog_index},${scoring_event_index})`);
        planner.tracklogs[tracklog_index].scoring_event_click(scoring_event_index);
    }

    // **************************************************************
    // Waypoints
    // **************************************************************

    // Add a new B21_Local_Waypoints object to .local_waypoints
    add_local_waypoints(local_waypoints_key, waypoints) {
        let planner = this;
        planner.local_waypoints[local_waypoints_key] = waypoints;
    }

    // Return true if local waypoints with given key are already loaded
    local_waypoints_loaded_status(local_waypoints_key) {
        let planner = this;
        return planner.local_waypoints[local_waypoints_key] != null;
    }

    // Used by settings to tell this planner new waypoints have been loaded
    local_waypoints_load_completed(local_waypoints_key) {
        let planner = this;
        planner.local_waypoints[local_waypoints_key].waypoints_loaded();
    }

    // hide the markers for given local waypoints key
    local_waypoints_hide(local_waypoints_key) {
        let planner = this;
        planner.local_waypoints[local_waypoints_key].hide();
    }

    // Remove loaded waypoints entry from .local_waypoints
    local_waypoints_delete(local_waypoints_key) {
        let planner = this;
        delete planner.local_waypoints[local_waypoints_key];
    }

    local_waypoints_set_active(local_waypoints_key) {
        let planner = this;
        planner.local_waypoints[local_waypoints_key].active = true;
    }

    local_waypoints_set_inactive(local_waypoints_key) {
        let planner = this;
        planner.local_waypoints[local_waypoints_key].active = false;
    }

    // **************************************************************
    // Multiplayer & NB21 Logger handling
    // **************************************************************

    // Start/stop display of local player
    multiplayer_local_clicked(planner) {
        console.log(`multiplayer_local_clicked() ${planner.multiplayer_local_checkbox_el.checked}`);
        if (planner.multiplayer_local_checkbox_el.checked) {
            planner.settings.set("nb21_connect", true);
            planner.nb21.setup_connection();
        } else {
            planner.settings.set("nb21_connect", false);
            planner.nb21.close_connection();
        }
    }

    // Start/stop multiplayer gliders display
    multiplayer_enable_clicked(planner) {
        console.log(`multiplayer_enable_clicked() ${planner.multiplayer_enable_checkbox_el.checked}`);
        if (planner.multiplayer_enable_checkbox_el.checked) {
            let ok = planner.players.start_multiplayer();
            if (!ok) {
                planner.multiplayer_enable_checkbox_el.checked = false;
            }
        } else {
            planner.players.stop_multiplayer();
        }
    }

    multiplayer_connected() {
        const planner = this;
        console.log(`multiplayer connected`);
        planner.multiplayer_enable_checkbox_el.style.accentColor = "green";
    }

    multiplayer_disconnected() {
        const planner = this;
        console.log(`multiplayer disconnected`);
        planner.multiplayer_enable_checkbox_el.style.accentColor = "red";
    }

    // center on user aircraft
    multiplayer_center_clicked(planner) {
        console.log(`multiplayer_center_clicked() ${planner.multiplayer_center_checkbox_el.checked}`);
        planner.players.set_center_on_user(planner.multiplayer_center_checkbox_el.checked);
    }

    // *******************************************
    // Functions called by NB21Connect

    handle_nb21_header(planner, msg) {
        planner.players.handle_nb21_header(planner.players, msg);
    }

    handle_nb21_message(planner, msg) {
        planner.players.handle_nb21_msg(planner.players, msg);
    }

    handle_nb21_message_json(planner, msg_json) {
        console.log("handle_nb21_message_json", msg_json);
        planner.players.handle_nb21_msg_json(planner.players, msg_json);
    }

    handle_nb21_pln(planner, pln_xml) {
        console.log("handle_nb21_pln", pln_xml);
    }

    local_player_connected() {
        let c = document.getElementById("multiplayer_local_checkbox");
        c.style.accentColor = "green";
    }

    local_player_disconnected() {
        let planner = this;
        let c = document.getElementById("multiplayer_local_checkbox");
        c.style.accentColor = "red";
        planner.players.local_player_disconnected();
    }
} // End class B21_TaskPlanner
"use strict"

//
// draw(chart_el) - draw the chart
//

class B21_TracklogChart {

    constructor(tracklog) {
        let tracklog_chart = this;
        tracklog_chart.tracklog = tracklog;

        tracklog_chart.chart = null; // holds Highcharts chart

        // Chart elements to hold chart POINT display text (i.e. time/alt/speed of current highlighted point)
        tracklog_chart.chart_point_info = null;

        // Chart elements to hold chart RANGE display text (i.e. time/alt/speed across current zoomed range)
        tracklog_chart.chart_range_info = null;
        tracklog_chart.chart_range_glide = null;

    }

    resize(tracklog) {
        let tracklog_chart = this;
        //console.log(`B21_Tracklog.resize_chart() ${tracklog.filename}`);
        if (tracklog_chart.chart == null) {
            console.warn(`B21_TracklogChart.resize() ${tracklog.filename} exit no chart.`);
            return;
        }
        if (tracklog_chart.chart.isResizing != 0) {
            console.warn(`B21_TracklogChart.resize() ${tracklog.filename} is resizing.`);
            return;
        }
        try {
            tracklog_chart.chart.setSize(null,null);
        } catch (e) {
            console.warn(`B21_TracklogChart.resize() ${tracklog.filename} exception on chart.setSize`);
        }
    }

    // ************************************************************************************
    // ********** Create and draw the Highcharts altitude/speed chart for this tracklog ***
    // ************************************************************************************

    // Use Highcharts to draw a time/altitude plot
    draw(chart_el, useTitle) {
        let tracklog_chart = this;
        let tracklog = tracklog_chart.tracklog;

        //console.log(`B21_TracklogChart.draw() tracklog_index:${tracklog.index} ${tracklog.filename}`);

        if (tracklog.file_obj == null) {
            console.log("B21_TracklogChart.draw() skipping as file not loaded.");
            return;
        }

        B21_Utils.clear_div(chart_el);

        // Create chart data values
        let baro_points = [];
        let speed_points = [];
        let chart_start_index = -1; // Set this to the logpoint index of the start of the first active segment
        for (let i=0; i<tracklog.logpoints.length; i++) {
            let p = tracklog.logpoints[i];
            if (tracklog.segments[p.segment_index].active) {
                // update the chart start index
                if (chart_start_index == -1) {
                    chart_start_index = i;
                    //console.log(`B21_TracklogChart.draw() setting the chart_start_index to ${chart_start_index}`);
                }
                baro_points.push([p.ts*1000, p.alt_m * tracklog.alt_scalar]);
                speed_points.push([p.ts*1000, p.speed_ms * tracklog.speed_scalar]);
            }
        }

        let title_length = tracklog.name == null ? tracklog.filename.length : tracklog.filename.length + tracklog.name.length;
        let title_join = title_length > 35 ? "<br/>" : " - ";
        let filename_str = tracklog.filename;

        let title_text = tracklog.name == null ? tracklog.filename : tracklog.name + title_join + filename_str;

        let speed_axis_title = (tracklog.using_airspeed == "GND" ? "Ground Speed" : tracklog.using_airspeed == "IAS" ? "Indicated Airspeed" : "True Airspeed") + " (" + tracklog.speed_units_str + ")"
        // Draw chart
        tracklog_chart.chart = new Highcharts.Chart(chart_el, {
            chart: {
                animation: false,
                //reflow: false,
                accessibility: {
                    enabled: false
                },
                //backgroundColor: "yellow",
                zoomType: 'x',
                resetZoomButton: {
                    position: {
                        // align: 'right', // by default
                        // verticalAlign: 'top', // by default
                        x: 40,
                        y: 40
                    }
                },
                events: {
                    selection: function(e) {
                        tracklog_chart.chart_selected(tracklog, e);
                    },
                    click: function (e) {
                        // Convert timestamp to logpoints index, args (start_index, ts) where ts is JS seconds timestamp
                        let logpoints_index = tracklog.ts_to_logpoints_index(0, e.xAxis[0].value/1000); // Axis is JS Date values (ms)
                        console.log("chart clicked",logpoints_index);
                        tracklog.click_logpoints_index(logpoints_index);
                    }
                }
            },
            title: {
                text: useTitle ? title_text : null,
                useHTML: true,
                style: {
                    fontSize: "12px"
                },
                y: 2
            },
            //subtitle: { text: document.ontouchstart === undefined ?
            //        'Click and drag in the plot area to zoom in' : 'Pinch the chart to zoom in'
            //},
            xAxis: {
                type: 'datetime',
                labels: {
                    formatter: function() {
                        return Highcharts.dateFormat('%H:%M', tracklog.value);
                    }
                }
            },
            yAxis: [{
                title: {
                    text: 'Altitude (' + tracklog.alt_units_str + ')'
                },
                lineColor: '#666633',
                lineWidth: 2,
                //min: 0,
                //max: 12000,
                startOnTick: true,
                endOnTick: true
                //tickInterval: 1000,
                //tickPixelInterval: 40
            }, {
                title: {
                    text: speed_axis_title,
                    style: {
                        color: '#FF2222'
                    }
                },
                labels: {
                    style: {
                        color: '#FF2222'
                    }
                },
                startOnTick: true,
                endOnTick: true,
                lineColor: '#FF2222',
                lineWidth: 2,
                //min: 0,
                //max: 200,
                //tickInterval: 20,
                alignTicks: true,
                opposite: true,
                visible: tracklog.planner.settings["show_speed_line_on_chart"] == "yes"
            }],
            legend: {
                enabled: false
            },
            tooltip: {
                enabled: false
            },
            /*
                backgroundColor: '#FCFFC5',
                borderColor: 'black',
                borderRadius: 10,
                borderWidth: 3,
                formatter: function () {
                    let str = tracklog.x+"<br/>";
                    let p = tracklog.logpoints[tracklog.point.index];
                    str += "Speed ("+tracklog.speed_units_str+"): "+ (p.speed_ms * tracklog.speed_scalar).toFixed(0)+"<br/>";
                    str += "Alt ("+tracklog.alt_units_str+"): "+(p.alt_m * tracklog.alt_scalar).toFixed(0);
                     return str;
                }
            }, */
            plotOptions: {
                series: {
                    animation: false,
                    cursor: 'pointer',
                    //events: {
                        //click: function(e) {
                        //    console.log("series click", e);
                        //    return true;
                        //    //alert('You just clicked the graph at '+e.point.index);
                        //}
                    //},
                    point: {
                        events: {
                            click: function(e) {
                                console.log("point click", e.point.index);
                                tracklog.click_logpoints_index(e.point.index);
                            },
                            mouseOver: function(e) {
                                if (! tracklog.planner.replay_mode) {
                                    let track_index = e.target.index + chart_start_index;
                                    let p1 = tracklog.logpoints_file[track_index];
                                    tracklog.set_logpoints_index(track_index);
                                    //console.log("mouseover", tracklog.x, tracklog.y, e.target.index);
                                    tracklog_chart.draw_chart_point_data(p1);
                                }
                            },
                            mouseOut: function(e) {
                                //console.log("mouseout", tracklog.x, tracklog.y, e.target.index);
                            }
                        }
                    }
                },
                line: {
                    enableMouseTracking: true,
                    lineWidth: 1,
                    color: '#666666'
                }
            },
            series: [{
                yAxis: 0,
                type: 'line',
                color: '#666633',
                name: "Alt",
                //lineWidth: 3,
                data: baro_points
            }, {
                yAxis: 1,
                type: 'line',
                name: "Speed",
                color: '#FF2222',
                data: speed_points,
                enableMouseTracking: false,
                visible: tracklog.planner.settings["show_speed_line_on_chart"] == "yes"
            }],
            credits: {
                enabled: false
            }
        });

        // POINT data values top-left of chart
        tracklog_chart.chart_point_info = tracklog_chart.chart.renderer.label("Mouse over to see point.", null, -5)
            .attr({ zIndex: 2,
                x: 70
            })
            .css({
                color: 'blue',
                fontSize: '12px',
                lineHeight: '12px'
            })
            .add();

        // RANGE data values top-right of chart
        console.log(`B21_TracklogChart.draw() tracklog_index:${tracklog.index} chart_el.offsetWidth:${chart_el.offsetWidth}`);
        tracklog_chart.chart_range_info = tracklog_chart.chart.renderer.label("", null, -4)
            .attr({
                zIndex: 2,
                x: tracklog_chart.chart.plotWidth + tracklog_chart.chart.plotLeft - 140
            })
            .css({
                color: 'blue',
                fontSize: '12px',
                lineHeight: '12px'
            })
            .add();
        tracklog_chart.chart_range_glide = tracklog_chart.chart.renderer.label("", null, -4)
            .attr({
                zIndex: 2,
                x: tracklog_chart.chart.plotWidth + tracklog_chart.chart.plotLeft - 260             })
            .css({
                fontSize: "14px",
                color: 'blue'
            }).add();

        // Create colors boxes for assigned tracklog colors (x,y,w,h)
        // Wings
        tracklog_chart.chart.renderer.rect(5,5,54,6).attr({
            stroke: "#000",
            'stroke-width': 2,
            fill: tracklog.color1
        }).add();
        // Fuselage
        tracklog_chart.chart.renderer.circle(32,9,8).attr({
            stroke: "#000",
            'stroke-width': 2,
            fill: tracklog.color2 == null ? tracklog.color1 : tracklog.color2
        }).add();

        // Create colored rectangle for each segment
        if (tracklog.segments.length > 1) {
            for (let segment_index=0; segment_index<tracklog.segments.length; segment_index++) {
                let x = 5 + 12 * segment_index;
                tracklog_chart.chart.renderer.rect(x,20,10,14).attr({
                    stroke: "#000",
                    'stroke-width': 1,
                    fill: tracklog.segments[segment_index].active ? "#4f4" : "#fff"
                }).add();
            }
        }

        tracklog_chart.draw_chart_wp_lines();

        tracklog_chart.draw_landout_line();

    } // end draw()

    // Draw the Start, Finish and WP completion lines on the chart
    draw_chart_wp_lines() {
        let tracklog_chart = this;
        let tracklog = tracklog_chart.tracklog;
        // Do nothing if no scoring data or no start
        if (tracklog.scoring_data == null || tracklog.scoring_data.started_ok == null) {
            return;
        }
        // Draw Start line
        let p = tracklog.logpoints[tracklog.scoring_data.started_ok.logpoints_index];
        let start_wp_index = tracklog.scoring_data.started_ok.wp_index;
        tracklog_chart.draw_chart_line(tracklog, p, "⠀⠀⠀⠀Start", 2, "green");

        // Draw WP lines
        let wp_index = start_wp_index + 1;
        while (tracklog.scoring_data.waypoints[wp_index] != null) {
            if (tracklog.scoring_data.finished_ok == null || wp_index < tracklog.scoring_data.finished_ok.wp_index) {
                let wp_name = tracklog.planner.task.waypoints[wp_index].name;
                let wp_scoring_data = tracklog.scoring_data.waypoints[wp_index];
                let p;
                if (wp_scoring_data.is_aat) {
                    p = tracklog.logpoints[tracklog.scoring_data.waypoints[wp_index].logpoints_index_aat];
                } else {
                    p = tracklog.logpoints[tracklog.scoring_data.waypoints[wp_index].logpoints_index];
                }
                //console.log(`B21_TracklogChart drawing wp line ${wp_index}`);
                tracklog_chart.draw_chart_line(tracklog, p, wp_name, 1, "green");
            }
            wp_index++;
        }

        // Draw Finish line
        if (tracklog.scoring_data.finished_ok != null) {
            p = tracklog.logpoints[tracklog.scoring_data.finished_ok.logpoints_index];
            tracklog_chart.draw_chart_line(tracklog, p, "Finish", 2, "green");
        }
    }

    draw_landout_line() {
        let tracklog_chart = this;
        let tracklog = tracklog_chart.tracklog;
        if (tracklog.scoring_data == null || tracklog.scoring_data.landout == null) {
            return;
        }
        let scoring_landout = tracklog.scoring_data.landout;
        if (scoring_landout.event_logpoints_index >= tracklog.logpoints_file.length - 1) {
            return;
        }

        // Draw line for landout 'event' (e.g. where a landing or slew occurred)
        let p_event = tracklog.logpoints[scoring_landout.event_logpoints_index];
        let label = scoring_landout.event_key;
        tracklog_chart.draw_chart_line(tracklog, p_event, label, 2, "brown");

        // Draw line at the max final leg distance
        if (scoring_landout.max_logpoints_index != scoring_landout.event_logpoints_index) {
            let p_max = tracklog.logpoints[scoring_landout.max_logpoints_index];
            let label = "(max distance)";
            tracklog_chart.draw_chart_line(tracklog, p_max, label, 2, "green");
        }
    }

    draw_chart_line_for_logpoint(tracklog, logpoints_index) {
        let tracklog_chart = this;
        //console.log(`B21_TracklogChart.draw_chart_line_for_logpoint() ${tracklog.name}`);
        if (tracklog_chart.chart == null) {
            console.warn(`B21_TracklogChart.draw_chart_line_for_logpoint() ${tracklog.name} exit no chart`);
            return;
        } else if (tracklog_chart.chart.isResizing != 0) {
            console.warn(`B21_TracklogChart.draw_chart_line_for_logpoint() ${tracklog.name} isResizing=${tracklog_chart.chart.isResizing}`);
            return;
        }

        // Draw line on speed/alt chart
        let x_value = new Date(tracklog.logpoints[logpoints_index].time_iso);
        tracklog_chart.chart.xAxis[0].removePlotLine("CURRENT");
        tracklog_chart.chart.xAxis[0].addPlotLine({
            id: "CURRENT",
            width: 1,
            value: x_value,
            color: 'blue',
            dashStyle: 'Solid',
            zIndex: 5
        });
    }

    draw_chart_line(tracklog, p, label, width, color) {
        let tracklog_chart = this;
        //console.log(`B21_TracklogChart.draw_chart_line() ${tracklog.name} point:${JSON.stringify(p)}`);
        if (tracklog_chart.chart == null) {
            console.error(`B21_TracklogChart.draw_chart_line() ${tracklog.name} exit no chart`);
            return;
        }
        try {
            tracklog_chart.chart.xAxis[0].addPlotLine({
                //id: label,
                width: width,
                value: new Date(p.time_iso),
                color: color,
                dashStyle: 'Solid',
                label: {
                    text: label
                },
                zIndex: 5
            });
        } catch(e) {
            console.warn(`draw_chart_line exception`,p,e);
        }
    }


    // User has dragged mouse across chart and selected a range of this tracklog
    chart_selected(tracklog, e) {
        let tracklog_chart = this;
        if (e.xAxis) {
            console.log("chart_selected [" + e.xAxis[0].min + ".." + e.xAxis[0].max + "]", e);
            // log the min and max of the primary, datetime x-axis
            console.log(
                Highcharts.dateFormat(
                    '%Y-%m-%d %H:%M:%S',
                    e.xAxis[0].min
                ),
                Highcharts.dateFormat(
                    '%Y-%m-%d %H:%M:%S',
                    e.xAxis[0].max
                )
            );
            // Get timestamps for range (note highcharts xaxis values are milliseconds)
            let ts_min = e.xAxis[0].min / 1000;
            let ts_max = e.xAxis[0].max / 1000;
            console.log("Chart select timestamps",ts_min, ts_max, "delta:", ts_max - ts_min);
            let index_min = tracklog.ts_to_logpoints_index(0,ts_min);
            let index_max = tracklog.ts_to_logpoints_index(index_min,ts_max);
            console.log("Chart select indexes",index_min, index_max);
            let p1 = tracklog.logpoints[index_min];
            let p2 = tracklog.logpoints[index_max];
            tracklog_chart.draw_chart_range_data(p1,p2);
        } else {
            console.log("chart_selected no e.xAxis");
            tracklog_chart.clear_chart_range_data();
        }
        return false;
    } // End chart_selected

    // Write the points data numbers to top-left corner of the chart
    draw_chart_point_data(p1) {
        //console.log("B21_TracklogChart.draw_chart_point_data",p1);
        let tracklog_chart = this;
        let tracklog = tracklog_chart.tracklog;
        let time_str = (new Date(p1.ts*1000)).toUTCString().substring(5,25)+"Z";

        let speed_str = ((p1.speed_ms == null ? 0 : p1.speed_ms) * tracklog.speed_scalar).toFixed(0)+" "+
            tracklog.speed_units_str;

        let flp_str = p1.FLP == null ? "" : " (Flap "+p1.FLP+")";

        let alt_str = (p1.alt_m * tracklog.alt_scalar).toFixed(0) + " " + tracklog.alt_units_str;

        let agl_str = p1.AGL == null ? "" : " ("+(p1.AGL * tracklog.alt_scalar).toFixed(0)+" AGL)";

        if (p1.GND != null && p1.GND) {
            agl_str = "GROUND";
        }

        let enl_str = p1.ENL == null ? "" : p1.ENL ? "<br>ENGINE" : "";

        let netto_str = p1.NET == null ? "" : "<br>Netto "+(p1.NET * tracklog.climb_scalar).toFixed(1)+" "+
            tracklog.climb_units_str;

        let info_str = time_str+"<br>"+speed_str+flp_str+"<br>"+alt_str+" "+agl_str+netto_str+enl_str;

        tracklog_chart.chart_point_info.attr({
            text: info_str
        });
    } // End draw_chart_point_data

    // Write the range data numbers to top-right corner of chart
    draw_chart_range_data(p1,p2) {
        let tracklog_chart = this;
        let tracklog = tracklog_chart.tracklog;
        console.log("draw_chart_range_data", p1, p2);

        let time_delta_s = p2.ts - p1.ts

        let time_str = "&#916;time: "+B21_Utils.h_m_ss_from_ts_delta(time_delta_s);

        let height_delta_m = p2.alt_m - p1.alt_m;

        let alt_str = "&#916;height (" + tracklog.alt_units_str + "): " + ( height_delta_m * tracklog.alt_scalar).toFixed(0);

        let distance_m = Geo.get_distance_m(p1,p2);

        let dist_str = "Dist ";
        if (tracklog.planner.settings.distance_units == "km") {
            dist_str += "(km): " + (distance_m / 1000).toFixed(3);
        } else {
            dist_str += "(miles): " + (distance_m * tracklog.planner.M_TO_MILES).toFixed(3);
        }

        let ground_speed_ms = time_delta_s > 0 ? distance_m / time_delta_s : 0;

        let speed_str = "Gnd speed (" + tracklog.speed_units_str + "): " + ((ground_speed_ms == null ? 0 : ground_speed_ms) * tracklog.speed_scalar).toFixed(
            0);

        let glide_str;
        if (height_delta_m > 0) {
            let climb_ms = height_delta_m / time_delta_s;
            glide_str = "Climb ";
            if (tracklog.planner.settings.altitude_units == "m") {
                glide_str += "(m/s): " + climb_ms.toFixed(2);
            } else {
                glide_str += "(knots): " + (climb_ms * tracklog.planner.MS_TO_KNOTS).toFixed(1);
            }
        } else {
            let glide_ratio = distance_m / height_delta_m;

            glide_str = "Glide: " + (glide_ratio > 100 ? "100+" : (-distance_m / height_delta_m).toFixed(0))+":1";
        }

        let info_str = time_str+"<br>"+alt_str+"<br>"+speed_str+"<br>"+dist_str;

        tracklog_chart.chart_range_info.attr({
            text: info_str
        });

        tracklog_chart.chart_range_glide.attr({
            text: glide_str
        });
    } // End draw_chart_range_data()

    clear_chart_range_data() {
        let tracklog_chart = this;
        tracklog_chart.chart_range_info.attr({
            text: null
        });
        tracklog_chart.chart_range_glide.attr({
            text: null
        });
    } // End clear_chart_range_data()

} // end B21_TracklogChart
"use strict"
// ******************************************************************************
// ***********   TrackLog class            **************************************
// ******************************************************************************

class B21_TrackLog {

    constructor(index, planner, map) {
        let tracklog = this;
        tracklog.M_TO_FEET = 3.28084;
        tracklog.M_TO_MILES = 0.000621371;
        tracklog.MS_TO_KPH = 3.6;
        tracklog.MS_TO_KNOTS = 1.94384;

        tracklog.index = index; // Index of this tracklog in planner.tracklogs[]
        tracklog.planner = planner;

        tracklog.segments = []; // list of segments loaded (e.g. trkseg from GPX) entries { segments_index: 0, active: true } ...
        tracklog.draw_map_invalid = false; // this is a flag we'll set if score_task skips segments so the map polyline can be redrawn

        tracklog.map = map;
        tracklog.map_bounds = null; // The Leaflet bounds of the line drawn on the map for this TrackLog

        tracklog.current_plotline == null; // plotLine cursor for the currently selected plot point

        // info_chart
        tracklog.info_chart_el = document.getElementById("tracklog_info_chart");
        tracklog.info_chart = new B21_TracklogChart(tracklog);

        // Track Log file data
        tracklog.logpoints_index = null; // Currently selected logpoint

        // E.g. if the current task has a waypoint "MISSED", and user clicks "SELECT POINT" button, this will be non-null
        tracklog.select_point_info = null; // E.g. { "mode": "task_fixup", "waypoints_index": N }

        // Data from the GPX/IGC file
        tracklog.logpoints = []; // { lat: lng: alt_m: ts: time_iso: ...}
        tracklog.logpoints_file = []; // will store the ORIGINAL logpoints from gpx/igc file if we update e.g. for pauses
        tracklog.name = null;       // from the <trk>... <name> property in the GPX file
        tracklog.filename = null;   // from the dropped filename or URL
        tracklog.pilot_name = null; // E.g. "DG808S RUSSIA (ANRI)"
        tracklog.competition_id = null; // E.g. B21
        tracklog.glider_type = null;  // E.g. DG808S
        tracklog.using_airspeed = "GND"; // set to "IAS" | "TAS" if we detect 'airspeed' properties in the tracklog
        tracklog.file_obj = null;  // Will contain a reference to a B21_File_GPX or B21_File_IGC object
        tracklog.NB21_fcheck = null;
        tracklog.hasTask = false; // true => can call load_task

        // Scoring data for each WP for this tracklog over task - see score_task()
        tracklog.scoring_data = null; // { started_ok: .. finished_ok: .., waypoints: [ ... ]}

        tracklog.file_events = []; // List of Tracklog_FileEvent objects derived directly from tracklog file

        tracklog.scoring_events = []; // List of notable scoring 'events' e.g. { ts: XX, event_key: "LTIM", text:" ...." }

        tracklog.init_penalty_data();

        // Skip pauses flag
        tracklog.skip_pause = false;     // Will be set to true if the on-page checkbox is checked
        tracklog.pauses_skipped = false; // Will be set to true if this tracklog has its pauses removed

        //tracklog.add_map_chart_el();

        tracklog.info_name_el = document.getElementById("tracklog_info_name");
        tracklog.info_alerts_el = document.getElementById("tracklog_info_alerts");
        tracklog.info_details_el = document.getElementById("tracklog_info_details");
        tracklog.info_timeline_el = document.getElementById("tracklog_info_timeline");
        tracklog.info_footer_el = document.getElementById("tracklog_info_footer");
        tracklog.info_load_task_el = document.getElementById("tracklog_info_load_task");
        tracklog.info_draw_aat_task_el = document.getElementById("tracklog_info_draw_aat_task");

        tracklog.checked = true; // checkbox status = ticked when we first load tracklog

        // Set tracklog.color1, tracklog.color2 for the polylines (c1=long, c2=short) and aircraft_marker (c1=wings, c2=fuselage)
        const C1_COLORS = ['#333','#b30000','#AE6F03','#46A844', '#178CE9', '#0000b3', '#b300b3'];//'#6a428a', '#C05FBC'];
        // Note we make c2 line length shorter than c1 length to increase pattern count
        const C2_COLORS = ['#FF4F4F','#FFB44F','#93FF4F','#FFFF4F','#4FFFF1','#f799ff','white'];

        tracklog.color1 = C1_COLORS[tracklog.index % C1_COLORS.length];
        if (tracklog.index < C1_COLORS.length) {
            tracklog.color2 =  tracklog.color1; // Start with solid colors
        } else {
            // Here tracklog.index >= C1_COLORS.length
            // After solid colors, we'll iterate through the c2 colors
            let c1_cycle = Math.floor(tracklog.index / C1_COLORS.length) - 1;
            let c2_offset = c1_cycle % C2_COLORS.length;
            tracklog.color2 = C2_COLORS[(tracklog.index % C1_COLORS.length + c2_offset) % C2_COLORS.length];
        }

        //console.log("tracklog colors",index,tracklog.color1, tracklog.color2);

        tracklog.line1_polyline = null; // line drawn for tracklog on map
        tracklog.line2_polyline = null; // Optional dashes for line

        tracklog.aircraft_marker = tracklog.create_marker();

        tracklog.alt_units_str = "m";
        tracklog.alt_scalar = 1;

        tracklog.speed_units_str = "kph";
        tracklog.speed_scalar = tracklog.MS_TO_KPH;

        tracklog.climb_units_str = "ms";
        tracklog.climb_scalar = 1;

        // make string units value and scaler for Altitudes and Climb Rates
        if (tracklog.planner.settings.altitude_units == "feet") {
            tracklog.alt_scalar = tracklog.M_TO_FEET;
            tracklog.alt_units_str = "feet";
            tracklog.climb_scalar = tracklog.MS_TO_KNOTS;
            tracklog.climb_units_str = "knots";
        }

        // make string units value and scaler for Speeds
        if (tracklog.planner.settings.speed_units == "knots") {
            tracklog.speed_scalar = tracklog.MS_TO_KNOTS;
            tracklog.speed_units_str = "knots";
        }

        // Chart elements to hold chart POINT display text (i.e. time/alt/speed of current highlighted point)
        tracklog.chart_point_time = null;
        tracklog.chart_point_altitude = null;
        tracklog.chart_point_speed = null;

        // Chart elements to hold chart RANGE display text (i.e. time/alt/speed across current zoomed range)
        tracklog.chart_range_time = null;
        tracklog.chart_range_altitude = null;
        tracklog.chart_range_speed = null;
        tracklog.chart_range_distance = null;
        tracklog.chart_range_glide = null;

        tracklog.replay_ts_offset = 0; // The number of seconds to offset time for this tracklog during a replay, to sync starts.

        // name/numbers display controlled by 'icon_data' checkboxes
        tracklog.icon_name_display = false;
        tracklog.icon_altitude_display = false;
        tracklog.icon_speed_display = false;

        // Weather info when crossing start line
        tracklog.weather_start_hash = null;
        tracklog.weather_start_name = null;

        tracklog.glider_data = null;
    }

    init_penalty_data() {
        let tracklog = this;

        tracklog.penalties = false;     // set to true if ANY penalties

        tracklog.weather_penalty = false;   // preset changed after start
        tracklog.slew_penalty = false;      // slew after start
        tracklog.eng_penalty = false;       // engine on after start
        tracklog.rate_penalty = false;      // rate change after start
        tracklog.igc_penalty = false;       // igc file checksum error
        tracklog.ballast_plus_penalty = false; // ballast added after start
        tracklog.overweight_penalty = false; // TOTAL WEIGHT > B21_GLIDERS_DATA..MAX_WEIGHT_KG

        // vne
        tracklog.VNE_TAS_MS = null; // Vne (TAS m/s) for aircraft. Vne values are set in vne_init()
        tracklog.vne_time_s = 0;        // Total time in overspeed
        tracklog.vne_tas_max_ms = 0;    // Max speed
        tracklog.vne_tas_start_ms = 0;  // Speed through start gate
        tracklog.vne_ms_s = 0;          // cumulative overspeed ms.seconds
        tracklog.vne_count = 0;         // count of separate overspeed event
        tracklog.vne_penalty_s = 0;     // Seconds of penalty time for overspeed

        // aat
        tracklog.aat_penalty_s = 0;     // seconds penalty for early finish
    }

    // Collect glider data entry from B21_GLIDERS_DATA
    get_glider_data() {
        let tracklog = this;
        console.log(`Tracklog.get_glider_data '${tracklog.glider_type}'`);
        if (tracklog.glider_type == null) {
            return;
        }
        tracklog.glider_data = B21_GLIDERS.get_glider_data(tracklog.glider_type);
    }

    add_map_chart_el(tracklog) {
        // HTML elements updated by TrackLog
        tracklog.map_chart_el = document.createElement("div");
        tracklog.map_chart_el.className = "map_chart";
        tracklog.planner.charts_el.appendChild(tracklog.map_chart_el);
    }

    load_gpx(file_str, filename) {
        let tracklog = this;
        try {
            tracklog.file_obj = new B21_File_GPX(tracklog);
            let load_ok = tracklog.file_obj.load(file_str, filename);
            if (!load_ok) {
                console.log("b21_tracklog failed to load GPX "+filename);
                return false;
            }

            tracklog.add_map_chart_el(tracklog);

            console.log(`B21_Tracklog loading tracklog ${tracklog.index} ${filename}`);
            tracklog.logpoints_file = tracklog.logpoints;

            if (tracklog.skip_pause) {
                console.log("B21_Tracklog.load_gpx loading tracklog with skip_pause = true");
                tracklog.skip_pause_logpoints();
            } else {
                tracklog.logpoints = tracklog.logpoints_file;
            }

            if (tracklog.segments.length > 1) {
                console.log(`B21_Tracklog.load_gpx multi-segment tracklog: ${tracklog.segments.length} segments.`);
            }

            tracklog.aircraft_marker_update(tracklog);
            return true;
        } catch (e) {
            console.log("load_gpx exception",filename, e);
        }

        return false;
    }

    load_igc(file_str, filename) {
        let tracklog = this;
        try {
            tracklog.file_obj = new B21_File_IGC(tracklog);
            let load_ok = tracklog.file_obj.load(file_str, filename);
            if (!load_ok) {
                console.log("b21_tracklog failed to load IGC "+filename);
                return false;
            }

            tracklog.get_glider_data();

            tracklog.add_map_chart_el(tracklog);

            tracklog.logpoints_file = tracklog.logpoints;

            if (tracklog.skip_pause) {
                console.log("B21_Tracklog.load_igc loading tracklog with skip_pause = true");
                tracklog.skip_pause_logpoints();
            } else {
                tracklog.logpoints = tracklog.logpoints_file;
            }

            tracklog.aircraft_marker_update(tracklog);
            return true;
        } catch (e) {
            console.warn("load_igc exception "+filename, e);
        }

        return false;
    }

    show() {
        let tracklog = this;
        //console.log(`B21_Tracklog.show()[${tracklog.index}] ${tracklog.name} show()`);
        tracklog.checked = true;
        tracklog.map_chart_el.style.display = "block";
        tracklog.scroll_chart();


        tracklog.map.removeLayer(tracklog.line1_polyline);
        tracklog.map.removeLayer(tracklog.line2_polyline);

        tracklog.draw_map(); // will draw polyline on map and set tracklog.map_bounds

        if (! tracklog.map.getBounds().intersects(tracklog.map_bounds) && !tracklog.draw_map_invalid) {
            tracklog.map.fitBounds(tracklog.map_bounds);
        }
        tracklog.aircraft_marker.addTo(tracklog.planner.map);
    }

    hide() {
        let tracklog = this;
        //console.log(`B21_Tracklog.hide()[${tracklog.index}] ${tracklog.name}`);
        tracklog.checked = false;
        tracklog.map_chart_el.style.display = "none";
        tracklog.map.removeLayer(tracklog.line1_polyline);
        if (tracklog.line2_polyline != null) {
            tracklog.map.removeLayer(tracklog.line2_polyline);
        }
        tracklog.map.removeLayer(tracklog.aircraft_marker);
    }

    // Resize the chart to fit its container
    resize_chart() {
        let tracklog = this;
        tracklog.info_chart.resize(tracklog);
    }

    // Called by b21_task_planner when another tab is clicked
    tracklog_info_exit() {
        let tracklog = this;
        tracklog.unset_select_point_status(tracklog,null);
        tracklog.info_chart.draw(tracklog.map_chart_el, true);
    }

    finished_ok() {
        let tracklog = this;
        return tracklog.scoring_data.finished_ok != null;
    }

    get_name() {
        let tracklog = this;
        return tracklog.name == null ? "" : tracklog.name;
    }

    get_pilot_name() {
        let tracklog = this;
        return tracklog.pilot_name;
    }

    get_filename() {
        let tracklog = this;
        return tracklog.filename == null ? "" : tracklog.filename;
    }

    // Return the JS seconds timestamp when this tracklog begins
    get_begin_ts() {
        let tracklog = this;
        let begin_ts = tracklog.logpoints[0].ts;
        // Code to skip over inactive segments
        //if (tracklog.segments.length > 1 && !tracklog.segments[0].active) {
        //    let i=0;
        //    while ( i<tracklog.logpoints.length && !tracklog.segments[tracklog.logpoints[i].segment_index].active) {
        //        i++;
        //    }
        //    if (i<tracklog.logpoints.length) {
        //        begin_ts = trackpoint.logpoints[i].ts;
        //    }
        //}
        return begin_ts;
    }

    // Return the JS second timestamp when this tracklog did a good start (or return null)
    get_start_ts() {
        let tracklog = this;
        if (tracklog.scoring_data == null || tracklog.scoring_data["started_ok"] == null) {
            return null;
        }
        return tracklog.logpoints[tracklog.scoring_data["started_ok"]["logpoints_index"]]["ts"];
    }

    // Is this a NB21-format IGC file
    isNB21() {
        let tracklog = this;

        if (tracklog.file_obj == null) {
            return false;
        }

        if (tracklog.file_obj.isNB21 == null) {
            return false;
        }

        if (!tracklog.file_obj.isNB21()) {
            return false;
        }

        return true;
    }

    // Is this tracklog DIRECTLY from the NB21 Logger
    isLocal() {
        let tracklog = this;

        if (tracklog.file_obj == null) {
            return false;
        }

        if (tracklog.file_obj.isLocal == null) {
            return false;
        }

        if (!tracklog.file_obj.isLocal()) {
            return false;
        }

        return true;
    }

    // Return True Airspeed m/s directly from the indexed logpoint
    get_tas_ms(logpoints_index) {
        let tracklog = this;

        if (logpoints_index < 0 || logpoints_index >= tracklog.logpoints.length) {
            return null;
        }

        let logpoint = tracklog.logpoints[logpoints_index];

        if (logpoint == null) {
            return null;
        }

        if (logpoint.TAS == null) {
            return null;
        }

        return logpoint.TAS;
    }

    // Get aircraft total weight at a given logpoint
    // This requires iterating the Tracklog_FileEvent records up to the time of that logpoint
    get_weight_kg(logpoints_index) {
        let tracklog = this;
        if (!tracklog.isNB21()) {
            return null;
        }

        return tracklog.file_obj.get_weight_kg(logpoints_index);
    }

    // Get sim date YYYYMMDD
    get_sim_date(logpoints_index) {
        let tracklog = this;
        if (!tracklog.isNB21()) {
            return null;
        }

        return tracklog.file_obj.get_sim_date(logpoints_index);
    }

    // Get sim time HHMMSS
    get_sim_time(logpoints_index) {
        let tracklog = this;
        if (!tracklog.isNB21()) {
            return null;
        }

        return tracklog.file_obj.get_sim_time(logpoints_index);
    }

    // Draw the polyline for this tracklog on the map
    draw_map() {
        //console.log("B21_Tracklog.draw_map() "+this.filename);
        let tracklog = this;

        // remove existing lines
        if (tracklog.line1_polyline != null) {
            tracklog.line1_polyline.remove(tracklog.map);
        }
        if (tracklog.line2_polyline != null) {
            tracklog.line2_polyline.remove(tracklog.map);
        }

        let coords = [];
        // If Sync Starts is selected, choose start of tracklog to draw somewhere near the start
        let draw_start_logpoints_index = 0;
        if (tracklog.planner.replay_sync && tracklog.scoring_data != null && tracklog.scoring_data.started_ok != null) {
            draw_start_logpoints_index = tracklog.scoring_data.started_ok.logpoints_index;
            let p_start = tracklog.logpoints[draw_start_logpoints_index];
            let draw_start_ts = p_start.ts;
            const PRE_START_S = 80; // amount of time to draw the tracklog for before the start
            // step backwards through the logpoints until PRE_START_S seconds before the start (or at start of active tracklog)
            while (draw_start_logpoints_index > 0) {
                let next_index = draw_start_logpoints_index - 1;
                let p = tracklog.logpoints[next_index];
                if (!tracklog.segments[p.segment_index].active) {
                    break;
                }
                if (draw_start_ts - p.ts > PRE_START_S) {
                    break;
                }
                draw_start_logpoints_index = next_index;
            }

            if (draw_start_logpoints_index < 0) {
                draw_start_logpoints_index = 0;
            }
        }
        //console.log(`B21_Tracklog.draw_map() ${tracklog.filename}. start index=${draw_start_logpoints_index}`);
        for (let i=draw_start_logpoints_index; i<tracklog.logpoints.length; i++) {
            let p = tracklog.logpoints[i];
            if (tracklog.segments[p.segment_index].active) {
                coords.push([p.lat.toFixed(6), p.lng.toFixed(6)]);
            }
        }

        //console.log(`B21_Tracklog.draw_map() starting logpoint lat:${coords[0][0]} lng:${coords[0][1]}`);

        let line1_properties = {
            weight: 2,
            color: tracklog.color1,
            pane: "tracklogs_pane",
            lineCap: "butt"
        };

        // Draw line1 on map
        tracklog.line1_polyline = L.polyline(coords, line1_properties).addTo(tracklog.map);

        // Set the map bounds
        tracklog.map_bounds = tracklog.line1_polyline.getBounds();

        // Draw overlay dashed line for 2nd color if we've done all the solid dark colors
        if (tracklog.color2 != null) {
            let line2_properties = {
                weight: 2,
                color: tracklog.color2,
                pane: "tracklogs_pane",
                lineCap: "butt",
                dashArray: "6 12", //dash2_length + " " + dash1_length,
                dashOffset: "24" //dash1_length.toFixed(0)
            };
            tracklog.line2_polyline = L.polyline(coords, line2_properties).addTo(tracklog.map);
        }
        tracklog.map_draw_invalid = false; // Reset the flag that can trigger a polyline redraw
    }

    // *********************************************************************
    // ********  Draw AAT track lines        *******************************
    // Note the AAT lines are properties of the WAYPOINTS                 **
    // i.e. we only expect to have AAT lines drawn for ONE tracklog.      **
    // *********************************************************************

    draw_aat() {
        let tracklog = this;
        let task = tracklog.planner.task;
        console.log(`Task.draw_aat() tracklog: ${tracklog.name}`);
        if (!task.isAAT() || tracklog.scoring_data.started_ok == null) {
            console.warn(`Task.draw_aat() non-aat or non-started tracklog: ${tracklog.name}`);
            return;
        }
        let p1 = task.waypoints[task.start_index].position;
        let wp_index;
        let wp;
        // First clear all existing AAT lines
        task.remove_aat_lines();

        // Now add AAT lines for this tracklog
        for (wp_index = task.start_index+1; wp_index < task.waypoints.length; wp_index++) {
            wp = task.waypoints[wp_index];
            let wp_scoring_data = tracklog.scoring_data.waypoints[wp_index];
            if (wp_scoring_data == null) {
                break;
            }
            let p2 = null;
            if (wp_scoring_data.is_aat) {
                p2 = tracklog.logpoints[wp_scoring_data.logpoints_index_aat];
            } else {
                p2 = wp.position;
            }
            // Draw aat line
            wp.add_aat_line(wp, p1, p2);
            p1 = p2;
        }
        // check for landout, if so draw line p1 -> logpoints[landout max_logpoints_index]
        if (tracklog.scoring_data.landout != null) {
            // From loop above, wp_index is the first waypoint with 'null' scoring_data.waypoints[wp_index]
            wp = task.waypoints[wp_index];
            let max_landout_pos = tracklog.logpoints[tracklog.scoring_data.landout.max_logpoints_index];
            wp.add_aat_line(wp, p1, max_landout_pos);
        }
    }

    // *****************************************************************
    // * Find the logpoint index given a timestamp
    // *****************************************************************

    // Return index of tracklog point with nearest timestamp (in seconds)
    // Works well when incrementing index forwards, but random point from zero should be binary split.
    ts_to_logpoints_index(start_index, ts) {
        return Math.round(this.ts_to_logpoints_index_proportion(start_index, ts));
    }

    // This returns the index as a floating point number with the fraction part the progress between two nearest points
    ts_to_logpoints_index_proportion(start_index, ts) {
        let tracklog = this;

        // Choose a 'start_index' that skips over inactive segments
        let segment_start_index = start_index;
        while ( segment_start_index < tracklog.logpoints.length &&
            !tracklog.segments[tracklog.logpoints[segment_start_index].segment_index].active) {
            segment_start_index++;
        }

        // Immediately return final trackpoint if start_index already past end of tracklog
        if (segment_start_index >= tracklog.logpoints.length - 1) {
            return tracklog.logpoints.length - 1;
        }
        // Immediately return start_index if given ts is earlier
        let ts_delta = ts - tracklog.logpoints[segment_start_index].ts;
        if (ts_delta <= 0) {
            return segment_start_index;
        }

        let index = segment_start_index;
        let prev_delta;
        // Iterate forwards until we find point with later ts than given
        while (ts_delta > 0 && ++index < tracklog.logpoints.length) {
            prev_delta = ts_delta;
            ts_delta = ts - tracklog.logpoints[index].ts;
        }

        // prev_delta > 0
        // ts_delta <= 0
        // Set index to the floating-point number between index and index+1
        index = index - 1 + prev_delta / (prev_delta - ts_delta);

        if (index >= tracklog.logpoints.length) {
            return tracklog.logpoints.length - 1;
        }

        return index;
    }

    // *****************************************************************
    // * Set the tracklog status for given logpoints_index
    // *****************************************************************

    // User has clicked on the speed/alt chart or replay is running so update tracklog.logpoints_index
    set_logpoints_index(logpoints_index, replay = false) {
        //console.log("B21_Tracklog.set_logpoints_index() setting index="+logpoints_index.toFixed(3));

        let tracklog = this;

        // Check for broken tracklog
        if (tracklog.logpoints.length < 5) {
            return;
        }

        let track_index = replay ? Math.floor(logpoints_index) : Math.round(logpoints_index);

        // Update tracklog.logpoints_index
        if (track_index < 0) {
            track_index = 0;
        }
        if (track_index >= tracklog.logpoints.length) {
            track_index = tracklog.logpoints.length - 1;
        }
        tracklog.logpoints_index = track_index;

        let p1 = tracklog.logpoints[track_index];
        //console.log("p1 index="+track_index,p1);
        // Calculate bearing from this trackpoint to next
        let bearing = 0;
        let p2;
        if (track_index + 1 < tracklog.logpoints.length) {
            p2 = tracklog.logpoints[track_index + 1];
            //console.log("p2 index="+(track_index+1),p2);
            bearing = Geo.get_bearing_deg(p1,p2);
        } else if (track_index + 1 == tracklog.logpoints.length & tracklog.logpoints.length > 2) {
            // If we are at the final trackpoint, we'll use the bearing from the previous trackpoint to this one
            p2 = tracklog.logpoints[track_index - 1];
            //console.log("p2 index="+(track_index-1),p2);
            bearing = Geo.get_bearing_deg(p2,p1);
        }

        if (replay) {
            let p = Geo.interp_p1_p2(logpoints_index % 1, p1, p2);
            //console.log("replay point p=",p);
            tracklog.aircraft_marker.setLatLng(new L.LatLng(p.lat, p.lng));
        } else {
            tracklog.aircraft_marker.setLatLng(new L.LatLng(p1.lat, p1.lng));
        }

        tracklog.aircraft_marker.setRotationAngle(bearing);

        tracklog.aircraft_marker_update(tracklog);

        if (!replay) {
            tracklog.info_chart.draw_chart_line_for_logpoint(tracklog, track_index)

            tracklog.info_chart.draw_chart_point_data(p1);
        }
    }

    inc_current_logpoints_index() {
        let tracklog = this;
        tracklog.set_logpoints_index(tracklog.logpoints_index + 1);
    }

    dec_current_logpoints_index() {
        let tracklog = this;
        tracklog.set_logpoints_index(tracklog.logpoints_index - 1);
    }

    // ************************************************************************************
    // ********** Draw the Highcharts altitude/speed chart for this tracklog ***
    // ************************************************************************************

    draw_chart() {
        let tracklog = this;
        console.log("tracklog.draw_chart()");
        tracklog.info_chart.draw(tracklog.map_chart_el, true);
    }


    // User has clicked on the chart
    click_logpoints_index(logpoints_index) {
        let tracklog = this;
        console.log(`B21_Tracklog.click_logpoints_index() ${logpoints_index}`);
        if (tracklog.info_chart.chart == null) {
            console.error(`B21_Tracklog.click_logpoints_index() ${tracklog.filename} exit no chart.`);
            return;
        }
        tracklog.set_logpoints_index(logpoints_index);
        // If we're in task_fixup mode then manually set current logpoint as achieving current waypoint
        if (tracklog.select_point_info != null) {
            if (tracklog.select_point_info["mode"] == "task_fixup") {
                tracklog.task_fixup(tracklog, tracklog.select_point_info["wp_index"], logpoints_index);
                tracklog.info_chart.chart.update({ chart: { backgroundColor: 'white' }})

            }
        } else {
            tracklog.aircraft_marker.togglePopup();
        //    tracklog.draw_chart_line_for_logpoint(tracklog, logpoints_index);
        }
    }

    // ******************************
    // SKIP SEGMENT
    // ******************************

    skip_segment(segment_index) {
        console.log(`B21_Tracklog skipping segment ${segment_index}`);
        let tracklog = this;
        tracklog.segments[segment_index]["active"] = false;
        tracklog.draw_map_invalid = true; // Set flag to trigger one polyline redraw
    }

    // ******************************
    // SKIP PAUSE on/off
    // ******************************

    // Skip pause ON
    skip_pause_on() {
        let tracklog = this;
        console.log("B21_Tracklog.skip_pause_on");
        tracklog.skip_pause = true;
        tracklog.skip_pause_logpoints();
        //tracklog.draw_chart();
        tracklog.info_chart.draw(tracklog.map_chart_el, true);
    }

    // Skip pause OFF
    skip_pause_off() {
        let tracklog = this;
        console.log("B21_Tracklog.skip_pause_off");
        tracklog.skip_pause = false;
        tracklog.logpoints = tracklog.logpoints_file;
        tracklog.pauses_skipped = false;
        //tracklog.draw_chart();
        tracklog.info_chart.draw(tracklog.map_chart_el, true);
    }

    skip_pause_logpoints() {
        let tracklog = this;
        console.log(`B21_Tracklog.skip_pause_logpoints() ${tracklog.filename}`);
        if (tracklog.pauses_skipped) {
            console.log(`B21_Tracklog.skip_pause_logpoints() tracklog ${tracklog.filename} pause removal already done`);
            return;
        }
        //console.log("B21_Tracklog.skip_pause_logpoints()");
        if (tracklog.logpoints_file.length < 100) {
            console.log("B21_Tracklog.skip_pause_logpoints() cancel too short");
            return;
        }

        let sample_period = 3;
        let prev_point = tracklog.logpoints_file[0];

        let time_adj_s = 0;

        let new_points = [];

        const SAMPLE_LENGTH = 2;
        for (let i=0; i<tracklog.logpoints.length-SAMPLE_LENGTH; i++) {
            let point = Object.assign({},tracklog.logpoints_file[i]); // SHALLOW COPY, ok for logpoint
            let sample_delta_s = point.ts - prev_point.ts;
            if (i>1 && sample_delta_s > Math.max(15,sample_period * 3)) {
                // time delta between data points is enough for us to consider this as a possible 'pause'
                // Pause time  = sample_delta_s
                let distance_m = Geo.get_distance_m(prev_point, point);
                try {
                    console.log(`B21_Tracklog.skip_pause_logpoints() logpoints_file[${i}] pause ${sample_delta_s}s detected`, point, prev_point);
                    console.log(`pause[${i}] distance ${distance_m.toFixed(0)}m,  speed ${prev_point.speed_ms.toFixed(1)}m/s`);
                } catch (e) {
                    console.log("Exception on trackpoint "+i,e);
                }

                if (distance_m < 800) { // If the plane has moved >400m between begin/end of pause, do not treat as pause (skipped data instead).
                    // We know the distance_m across the pause, so use an estimated speed to calculate the new time between pause data points
                    let pause_speed_ms = Math.max(25, Math.min(60, prev_point.speed_ms * 0.9));
                    console.log("Using pause speed from prior point: "+pause_speed_ms.toFixed(1)+" ms");
                    let unpause_s = Math.max(sample_period, distance_m / pause_speed_ms); // The amount of time we will replace the pause with.
                    console.log("Using "+unpause_s+" s as time delta replacing pause.");
                    time_adj_s += unpause_s - sample_delta_s;
                    console.log("B21_Tracklog.skip_pause_logpoints() time adjust = "+ time_adj_s.toFixed(2) + " seconds");
                } else {
                    console.log(`B21_Tracklog.skip_pause_logpoints() pause at [${i}] ignored, distance too high for valid pause.`);
                }
            }

            sample_period = Math.min(12,sample_period * 0.9 + sample_delta_s * 0.1);

            if (time_adj_s != 0) {
                point.ts = point.ts + time_adj_s;
                let t = new Date(Date.UTC(1970,0,1));
                t.setUTCMilliseconds(point.ts*1000);
                point.time_iso = t.toISOString();
            }

            new_points.push(point);

            //ts = tracklog.logpoints_file[i].ts;
            prev_point = tracklog.logpoints_file[i];
        }
        // Copy remaining logpoints from logpoints_file
        for (let i = tracklog.logpoints_file.length-SAMPLE_LENGTH; i<tracklog.logpoints_file.length; i++) {
            let point = Object.assign({},tracklog.logpoints_file[i]);
            if (time_adj_s != 0) {
                point.ts = point.ts + time_adj_s;
                let t = new Date(Date.UTC(1970,0,1));
                t.setUTCMilliseconds(point.ts*1000);
                point.time_iso = t.toISOString();
            }
            new_points.push(point);
        }

        tracklog.logpoints = new_points;
        tracklog.pauses_skipped = true;
        console.log(`B21_Tracklog.skip_pause_logpoints() ${tracklog.filename} completed.`);
    }

    // ******************************
    // ICON DATA on/off
    // ******************************

    // Show the ICON DATA above the glider icon on the map
    show_icon_name_data() {
        let tracklog = this;
        tracklog.icon_name_display = true;
        tracklog.aircraft_marker_update(tracklog);
        tracklog.aircraft_marker.openPopup();
    }

    // Hide the ICON DATA above the glider icon on the map
    hide_icon_name_data() {
        let tracklog = this;
        tracklog.icon_name_display = false;
        tracklog.aircraft_marker_update(tracklog);
        if (!tracklog.icon_altitude_display && !tracklog.icon_speed_display) {
            tracklog.aircraft_marker.closePopup();
        }
    }

    // Show the ICON DATA above the glider icon on the map
    show_icon_altitude_data() {
        let tracklog = this;
        tracklog.icon_altitude_display = true;
        tracklog.aircraft_marker_update(tracklog);
        tracklog.aircraft_marker.openPopup();
    }

    // Hide the ICON DATA above the glider icon on the map
    hide_icon_altitude_data() {
        let tracklog = this;
        tracklog.icon_altitude_display = false;
        tracklog.aircraft_marker_update(tracklog);
        if (!tracklog.icon_name_display && !tracklog.icon_speed_display) {
            tracklog.aircraft_marker.closePopup();
        }
    }
    // Show the ICON DATA above the glider icon on the map
    show_icon_speed_data() {
        let tracklog = this;
        tracklog.icon_speed_display = true;
        tracklog.aircraft_marker_update(tracklog);
        tracklog.aircraft_marker.openPopup();
    }

    // Hide the ICON DATA above the glider icon on the map
    hide_icon_speed_data() {
        let tracklog = this;
        tracklog.icon_speed_display = false;
        tracklog.aircraft_marker_update(tracklog);
        if (!tracklog.icon_name_display && !tracklog.icon_altitude_display) {
            tracklog.aircraft_marker.closePopup();
        }
    }

    // Scroll the 'charts' element until our chart is shown.
    scroll_chart() {
        let tracklog = this;
        tracklog.map_chart_el.scrollIntoView(false);
    }

    // *****************************************************************************************
    // ********* Score this tracklog relative to the current task ******************************
    // *****************************************************************************************
    // Calculate the Task start/finish times etc. for this TrackLog
    //    Updates:
    //       tracklog.scoring_data:
    //          {   started_ok: { logpoints_index: , wp_index: }
    //              finished_ok: { logpoints_index: , wp_index: , task_time_s: , task_speed_ms: , distance_m: },
    //              waypoints[wp_index] = {
    //                  "logpoints_index": i,       // Logpoint index when this waypoint radius was entered
    //                  "is_aat": true|false,       // true if this wp is an AREA
    //                  "logpoints_index_exit": j,  // logpoint index when this area was last exited
    //                  "logpoints_index_aat": k    // logpoint index for max AAT distance
    //              }
    //              landout: {
    //                  ts: ,                               // ts of land event
    //                  event_logpoints_index: ,            // nearest logpoint before landout
    //                  event_key: 'SLEW' | 'LAND' | 'END'
    //                  max_distance_m: will be added by score_max_task_distance_m
    //          }
    //
    //      tracklog.scoring_events:
    //          [
    //              {
    //                  ts: XX,
    //                  event_key: "LTIM|SLEW|etc",
    //                  text: " ...",
    //                  disabled: null | true
    //                  file_events_index: original file event was .file_events[file_event_index]
    //              },
    //              ...
    //          ]

    score_task() {
        let tracklog = this;

        console.log("**************************** score_task() ****************************************");
        console.log(`B21_Tracklog.score_task() tracklog_index:${tracklog.index} ${tracklog.name} ${tracklog.filename}`);

        // Initialise scoring
        tracklog.scoring_data = { waypoints: [] };
        tracklog.init_penalty_data();

        let task = tracklog.planner.task;
        if (task == null || task.start_index == null || task.finish_index == null) {
            console.log("B21_Tracklog.score_task(): no good task");
            return;
        }

        let status = "PRE-START"; // "PRE-START", "STARTED", "WAYPOINTS", "FINISHED"

        console.log(`B21_Tracklog.score_task() tracklog_index:${tracklog.index} status=${status}`);

        let wp_index = task.start_index + 1;

        // Is the start set in tracklog.task_fixup_info ?
        let start_fixed = tracklog.task_fixup_info != null && tracklog.task_fixup_info[""+task.start_index] != null;
        //console.log("score_task start_fixed=",start_fixed);
        let start_enabled = true; // will disable further starts if start is fixed

        let p1 = tracklog.logpoints[0];

        for (let i = 1; i < tracklog.logpoints.length; i++) {
            let p2 = tracklog.logpoints[i];

            if (i > 8070 && i < 8080) {
                console.log(`TrackLog.score_task()[${i}] at ${p2.time_iso}, status=${status}`);
            }

            // **********************
            // Detect START
            // **********************
            if (status == "PRE-START" || status == "STARTED") {
                let new_start = false;
                // Special consideration if the start has been 'fixed up' (i.e. manually adjusted)
                if (start_fixed && start_enabled) {
                    start_enabled = false;
                    let logpoints_index = tracklog.task_fixup_info[""+task.start_index];
                    p1 = tracklog.logpoints[logpoints_index];
                    tracklog.score_start(logpoints_index, task.start_index);
                    status = "STARTED";
                    console.log(`B21_Tracklog.score_task() logpoint[${i}] tracklog_index:${tracklog.index} status=${status}`);
                    new_start = true;
                    i = logpoints_index + 1;
                    console.log("score_task skipping to logpoint",i);
                } else if (start_enabled && task.is_start(p1, p2)) {
                    tracklog.score_start(i-1,task.start_index);
                    status = "STARTED";
                    console.log(`B21_Tracklog.score_task() logpoint[${i}] tracklog_index:${tracklog.index} status=${status}`);
                    new_start = true;
                }
                if (new_start) {
                    // Mark any tracklog segments before start as inactive
                    for (let i=0; i<p1.segment_index; i++) {
                        tracklog.skip_segment(i);
                    }
                    //tracklog.draw_chart();
                    console.log(`B21_Tracklog ${tracklog.filename} started at`,p1);
                }

            }

            // **************************
            // Detect rounding WAYPOINTS
            // **************************
            if (status == "STARTED" || status == "WAYPOINTS") {

                // If previous waypoint was an AAT area, and we've just exited it, record logpoints_index_exit in scoring_data
                // if the pilot flies into the same AAT area multiple times this will update the exit logpoint in scoring_data
                let prev_wp_index = wp_index - 1;
                if (task.waypoints[prev_wp_index].isAAT() && task.is_wp_exit(prev_wp_index, p1, p2)) {
                    console.log(`tracklog.score_task setting AAT WP[${prev_wp_index}] exit at logpoint[${i-1}]`);
                    tracklog.score_wp_exit(i-1, prev_wp_index); // actual exit logpoint is i - 1 i.e. previous logpoint
                }

                if (wp_index != task.finish_index) {
                    // Special treatment if waypoint has been 'fixed up'
                    if (tracklog.task_fixup_info != null && tracklog.task_fixup_info[""+wp_index] != null) {
                        let logpoints_index = tracklog.task_fixup_info[""+wp_index];
                        p2 = tracklog.logpoints[logpoints_index];
                        tracklog.score_wp(logpoints_index, wp_index);
                        status = "WAYPOINTS";
                        console.log(`B21_Tracklog.score_task() logpoint[${i}] FIXUP tracklog[${tracklog.index}] WP[${wp_index}] status=${status}`);
                        start_enabled = false;
                        wp_index++;
                        i = logpoints_index + 1;
                    } else if (task.is_wp(wp_index, p1, p2)) {
                        tracklog.score_wp(i, wp_index);
                        status = "WAYPOINTS";
                        console.log(`B21_Tracklog.score_task() logpoint[${i}] tracklog[${tracklog.index}] WP[${wp_index}] status=${status}`);
                        start_enabled = false;
                        wp_index++;
                    }
                } else {
            // **************************
            // Detect FINISH
            // **************************
                    if ((tracklog.task_fixup_info == null || tracklog.task_fixup_info[""+wp_index] == null) && task.is_finish(p1, p2)) {
                        tracklog.score_finish(i,p2,wp_index);
                        status = "FINISHED";
                        console.log(`B21_Tracklog.score_task() logpoint[${i}] tracklog_index:${tracklog.index} status=${status}`);
                        break;
                    }
                }
            }
            // **********************************
            // Increment to next tracklog point
            // **********************************
            p1 = p2;
        }

        if (wp_index == task.finish_index && tracklog.task_fixup_info != null && tracklog.task_fixup_info[""+wp_index] != null) {
            let logpoints_index = tracklog.task_fixup_info[""+wp_index];
            let p = tracklog.logpoints[logpoints_index];
            tracklog.score_finish(logpoints_index, p, wp_index);
            status = "FINISHED";
            console.log(`B21_Tracklog.score_task() logpoint[${logpoints_index}] FIXUP tracklog[${tracklog.index}] status=${status}`);
        }

        if (status != "FINISHED") {
            console.log(`B21_Tracklog.score_task() Task not finished, status(${status}) wp[${wp_index}] ${JSON.stringify(tracklog.scoring_data)}`);
        }

        if (status != "PRE-START") {
            tracklog.score_events(tracklog); // will create scoring_data.landout

            if (tracklog.scoring_data.landout != null) {
                tracklog.clean_scoring_data_for_landout(tracklog);
                tracklog.score_landout_max_distance(tracklog);
            }

            if (tracklog.planner.task.isAAT()) {
                tracklog.score_aat();
                if (tracklog.planner.scoring_penalties()) {
                    tracklog.apply_aat_penalties();
                }
            }

            if (tracklog.finished_ok()) {
                if (tracklog.planner.scoring_penalties()) {
                    tracklog.score_vne();
                    tracklog.apply_speed_penalties();
                }
            }
        }

        console.log("**************************** score_task() completed ****************************************");

        // Redraw the polyline if we've skipped some segments
        if (tracklog.draw_map_invalid) {
            tracklog.draw_map();
        }
    }

    score_start(logpoints_index, wp_index) {
        let tracklog = this;
        console.log(`B21_Tracklog.score_start tracklog_index:${logpoints_index} wp_index:${wp_index}`);
        // started_ok: { logpoints_index: , wp_index: }
        tracklog.scoring_data.started_ok = { logpoints_index: logpoints_index, wp_index: wp_index} ;
        //tracklog.scoring_data.start_index = i;
        tracklog.scoring_data.waypoints[tracklog.planner.task.start_index] = { logpoints_index: logpoints_index, is_aat: false };
        //let start_time_str = (new Date(p1.time_iso)).toTimeString().split(' ')[0];
        //console.log("TrackLog: started[" + i + "] at " + start_time_str);

        //tracklog.draw_chart_line(tracklog, p1, "Start", 2, "green");
    }

    score_wp(logpoints_index, wp_index) {
        let tracklog = this;
        //console.log(`B21_Tracklog.score_wp tracklog_index:${logpoints_index} wp_index:${wp_index}`);

        // Read AAT (area waypoint) status from task waypoint
        let wp_is_aat = tracklog.planner.task.waypoints[wp_index].isAAT();

        tracklog.scoring_data.waypoints[wp_index] = {
            logpoints_index: logpoints_index,
            is_aat: wp_is_aat
        };
        // Values here only for debug console output
        //let wp_time_str = (new Date(tracklog.logpoints[logpoints_index].time_iso)).toTimeString().split(' ')[0];
        //let wp_name = tracklog.planner.task.waypoints[wp_index].name;
        if (wp_is_aat) {
            //console.log(`B21_TrackLog.score_wp: Entered AAT WP[${wp_index}] ${wp_name} logpoints[${logpoints_index}] at ${wp_time_str}`);
        } else {
            tracklog.scoring_data.waypoints[wp_index].leg_distance_m = tracklog.planner.task.waypoints[wp_index].leg_distance_m;

            //console.log(`B21_TrackLog.score_wp: Completed WP[${wp_index}] ${wp_name} logpoints[${logpoints_index}] at ${wp_time_str}`);
        }
        //tracklog.draw_chart_line(tracklog, p2, wp_name, 1, "green");
    }

    // Record exit of AAT area in scoring_data
    score_wp_exit(logpoints_index, wp_index) {
        let tracklog = this;
        // The last trackpoint INSIDE the area was at logpoint_index.
        tracklog.scoring_data.waypoints[wp_index]["logpoints_index_exit"] = logpoints_index;
        // Values here only for debug console output
        let wp_time_str = (new Date(tracklog.logpoints[logpoints_index].time_iso)).toTimeString().split(' ')[0];
        let wp_name = tracklog.planner.task.waypoints[wp_index].name;
        console.log(`score_wp_exit logpoint[${logpoints_index}] WP[${wp_index}] "${wp_name}" at ${wp_time_str}`);
    }


    score_finish(logpoints_index, p2, wp_index) {
        let tracklog = this;
        console.log(`Tracklog.score_finish logpoint[${logpoints_index}] wp_index:${wp_index}`);
        //finished_ok: { logpoints_index: , wp_index: , task_time_s: , task_speed_ms }
        tracklog.scoring_data.finished_ok = { logpoints_index: logpoints_index, wp_index: wp_index, is_aat: false };

        let start_logpoint = tracklog.logpoints[tracklog.scoring_data.started_ok["logpoints_index"]];
        let start_ts = start_logpoint["ts"];
        let finish_ts = p2["ts"];
        let task_time_s = finish_ts - start_ts;

        tracklog.scoring_data.finished_ok.task_time_s = task_time_s;
        //tracklog.scoring_data.finished_ok["pre_penalty_task_time_s"] = task_time_s;       // task time before any penalties

        let task_speed_ms = null; // Will complete for non-AAT tasks

        if (!tracklog.planner.task.isAAT()) {
            let distance_m = tracklog.planner.task.get_task_distance_m();
            task_speed_ms = task_time_s > 0 ? distance_m / task_time_s : 0;
            tracklog.scoring_data.finished_ok.distance_m = distance_m;
        }

        // task_speed_ms will be updated from null in score_aat()
        tracklog.scoring_data.finished_ok.task_speed_ms = task_speed_ms
        //tracklog.scoring_data.finished_ok["pre_penalty_task_speed_ms"] = task_speed_ms;   // task speed before any penalties

        tracklog.scoring_data.waypoints[wp_index] = {
            logpoints_index: logpoints_index,
            is_aat: false,
            leg_distance_m: tracklog.planner.task.waypoints[wp_index].leg_distance_m,
        };

        console.log(`Tracklog.score_finish logpoint[${logpoints_index}] wp_index:${wp_index} task_speed_ms=${task_speed_ms}`);
    }

    altitude_str(alt_m) {
        let tracklog = this;
        let units_str = tracklog.planner.settings.altitude_units == "m" ? "m" : "feet";
        let units_factor = tracklog.planner.settings.altitude_units == "m" ? 1 : tracklog.M_TO_FEET;
        return (alt_m * units_factor).toFixed(0) + "&nbsp;"+units_str;
    }

    is_finished() {
        let tracklog = this;
        return tracklog.scoring_data != null && tracklog.scoring_data["finished_ok"] != null;
    }

    apply_speed_penalties() {
        let tracklog = this;
        if (tracklog.finished_ok() && tracklog.penalties) {
            let distance_m = tracklog.scoring_data.finished_ok.distance_m; // either from task or ATT achieved
            let total_penalties_s = tracklog.vne_penalty_s + tracklog.aat_penalty_s;
            let speed_ms = distance_m / (tracklog.scoring_data.finished_ok.task_time_s + total_penalties_s);
            tracklog.scoring_data.finished_ok.task_speed_ms = speed_ms;
        }
    }

    apply_aat_penalties() {
        let tracklog = this;
        if (tracklog.finished_ok()) {
            let task_time_s = tracklog.scoring_data.finished_ok.task_time_s;
            if (tracklog.planner.task.aat_min_time_s != null && task_time_s < tracklog.planner.task.aat_min_time_s) {
                tracklog.aat_penalty_s = tracklog.planner.task.aat_min_time_s - task_time_s;
                //task_time_s = tracklog.planner.task.aat_min_time_s;
                tracklog.penalties = true;
            }
        }
    }

    // ************************************************************
    // Score VNE
    // ************************************************************

    vne_init() {
        let tracklog = this;

        tracklog.vne_time_s = 0;        // Cumulative time (seconds) in Vne
        tracklog.vne_tas_max_ms = 0;    // Maximum TAS m/s in tracklog
        tracklog.vne_tas_start_ms = 0;  // Speed through start gate
        tracklog.vne_count = 0;         // Number of times pilot entered Vne since start
        tracklog.vne_ms_s = 0;          // Vne m/s seconds i.e. integration of overspeed_ms * time
        tracklog.vne_penalty_s = 0;
        tracklog.VNE_TAS_MS = null;     // TAS Vne from B21_GLIDERS

        if (tracklog.glider_data != null && tracklog.glider_data.VNE_TAS_KPH != null) {
            console.log(`Tracklog.vne_init() ${tracklog.glider_type} has VNE of ${tracklog.glider_data.VNE_TAS_KPH.toFixed(2)}kph`);
            tracklog.VNE_TAS_MS = tracklog.glider_data.VNE_TAS_KPH / tracklog.MS_TO_KPH;
        }
    }

    score_vne() {
        let tracklog = this;
        tracklog.vne_init();
        if (tracklog.planner.settings.scoring_penalties != "yes") {
            return;
        }
        if (tracklog.VNE_TAS_MS == null) {
            return;
        }
        if (tracklog.using_airspeed != "TAS") {
            return;
        }
        if (!tracklog.finished_ok()) {
            return;
        }
        const start_index = tracklog.scoring_data["started_ok"]["logpoints_index"];
        const finish_index = tracklog.scoring_data["finished_ok"]["logpoints_index"];
        const p0 = tracklog.logpoints_file[start_index];
        let v0_ms = p0.speed_ms;
        let t0_s = p0.ts;
        tracklog.vne_start(v0_ms); // check for high speed start
        for (let logpoints_index=start_index+1; logpoints_index < finish_index; logpoints_index++) {
            let p1 = tracklog.logpoints_file[logpoints_index];
            try {
                let t1_s = p1.ts;
                let v1_ms = p1.speed_ms;
                tracklog.vne_increment(t0_s,v0_ms,t1_s,v1_ms);
                t0_s = t1_s;
                v0_ms = v1_ms;
            } catch (e) {
                console.log(`vne_update fail ${logpoints_index}`,e);
            }
        }

        // CALCULATE VNE PENALTY
        if (tracklog.vne_ms_s > 5) {
            tracklog.penalties = true;
            tracklog.vne_penalty_s = (tracklog.vne_ms_s - 5) * 2.5 + 10;
        }
    }

    // Check for overspeed start
    vne_start(start_ms) {
        let tracklog = this;
        if (start_ms > tracklog.VNE_TAS_MS * 1.02) { // 2% margin
            tracklog.vne_tas_start_ms = start_ms - tracklog.VNE_TAS_MS;
        }
    }

    // Update Vne values for given logpoints_index
    vne_increment(t0_s,v0_ms,t1_s,v1_ms) {
        let tracklog = this;
        const p0_overspeed = v0_ms > tracklog.VNE_TAS_MS * 1.02; // 2% margin
        const p1_overspeed = v1_ms > tracklog.VNE_TAS_MS * 1.02; // 2% margin
        if (t1_s > t0_s && (p0_overspeed || p1_overspeed)) { // Only update vne if time forwards and overspeeding
            if (p0_overspeed && p1_overspeed) {
                tracklog.vne_time_s += t1_s - t0_s;
                tracklog.vne_ms_s += (v0_ms + v1_ms - 2 * tracklog.VNE_TAS_MS) / 2;
                if (v0_ms > tracklog.vne_tas_max_ms) {
                    tracklog.vne_tas_max_ms = v0_ms;
                }
                if (v1_ms > tracklog.vne_tas_max_ms) {
                    tracklog.vne_tas_max_ms = v1_ms;
                }
                if (tracklog.vne_count == 0) {
                    tracklog.vne_count = 1;
                }
            } else {
                let p = (tracklog.VNE_TAS_MS - v0_ms) / (v1_ms - v0_ms);
                if (v1_ms > tracklog.VNE_TAS_MS) {  // entering Vne
                    tracklog.vne_count += 1;
                    p = 1 - p;
                    let inc_time_s = p * (t1_s - t0_s);
                    tracklog.vne_time_s += inc_time_s;
                    tracklog.vne_ms_s += inc_time_s * (v1_ms - tracklog.VNE_TAS_MS) / 2;
                    if (v1_ms > tracklog.vne_tas_max_ms) {
                        tracklog.vne_tas_max_ms = v1_ms;
                    }
                } else {                            // leaving Vne
                    let inc_time_s = p * (t1_s - t0_s);
                    tracklog.vne_time_s += inc_time_s;
                    tracklog.vne_ms_s += inc_time_s * (v0_ms - tracklog.VNE_TAS_MS) / 2;
                }
            }
        }
    }

    // ********************************************************* //
    // ******* score AAT distance                     ********** //
    // ********************************************************* //
    // Will update tracklog.scoring_data with AAT info e.g. (Poundy_AAT.igc):
    // {
    //      "started_ok": {"logpoints_index":740, "wp_index":1 },
    //      "finished_ok":{"logpoints_index":5562, "wp_index":5, "is_aat":true, "task_time_s": 4822,"task_speed_ms": 61.3139, "distance_m": 295656.05 }
    //      "landout": {max_distance_m: max_logpoints_index: last_leg_distance_m: next_wp_index: }
    //      "waypoints":[
    //          null,
    //          {"logpoints_index":740, "is_aat":false },
    //          {"logpoints_index":1333, "is_aat":true, "logpoints_index_exit":1754, "logpoints_index_aat":1514 },
    //          {"logpoints_index":2132, "is_aat":true, "logpoints_index_exit":2840, "logpoints_index_aat":2459 },
    //          {"logpoints_index":2854, "is_aat":true, "logpoints_index_exit":4109, "logpoints_index_aat":3396 },
    //          {"logpoints_index":5562, "is_aat":false }
    //      ],
    // }

    // Called by score_task() to update scoring_data if task.isAAT()
    score_aat() {
        let tracklog = this;
        console.log(`B21_TrackLog.score_aat() ${tracklog.get_name()}`);
        let aat_distance_m = 0;
        let max_logpoints_index = 0;
        let last_leg_distance_m = 0;
        let i;
        for (i=1; i<10; i++) {
            let score_info = tracklog.score_aat_one_pass();
            let dist_m = score_info.distance_m;
            if (dist_m <= aat_distance_m) {
                break;
            } else {
                aat_distance_m = dist_m;
                max_logpoints_index = score_info.logpoints_index;
                last_leg_distance_m = score_info.last_leg_distance_m;
            }
        }
        console.log(`B21_TrackLog.score_aat() aat_distance_m at iteration:${i} ${(aat_distance_m/1000).toFixed(2)}km`);

        if (tracklog.scoring_data.landout != null) {
            console.log(`B21_TrackLog.score_aat() landout != null, max_logpoint_index=${max_logpoints_index}`);
            tracklog.scoring_data.landout.max_distance_m = aat_distance_m;
            tracklog.scoring_data.landout.max_logpoints_index = max_logpoints_index;
            tracklog.scoring_data.landout.last_leg_distance_m = last_leg_distance_m;
            //tracklog.scoring_data.landout.next_wp_index = wp_index;

        } else if (tracklog.finished_ok()) {
            console.log(`B21_TrackLog.score_aat() finished_ok()=true`);
            tracklog.scoring_data.finished_ok.distance_m = aat_distance_m;
            tracklog.scoring_data.finished_ok.is_aat = true;
            let task_time_s = tracklog.scoring_data.finished_ok.task_time_s;
            tracklog.scoring_data.finished_ok.task_speed_ms = aat_distance_m / task_time_s;
        } else {
            console.log(`B21_TrackLog.score_aat() landout == null & !finished_ok() max_logpoint_index=${max_logpoints_index}`);
        }

    }

    // Will update scoring data for each AAT waypoint
    // Returns { distance_m: , logpoints_index: , last_leg_distance_m }
    score_aat_one_pass() {
        let tracklog = this;
        let task = tracklog.planner.task;
        console.log(`score_aat_one_pass()`, JSON.stringify(tracklog.scoring_data));

        let wp_index = task.start_index;
        let point_A = task.waypoints[wp_index].position;
        wp_index++;
        let task_distance_m = 0;
        // initialise as if first point in each area is the 'max distance' point.
        // In this loop we calculate scoring_data.waypoints[wp_index].leg_distance_m for completed wp's
        // and accumulate those leg distances into task_distance_m
        while (wp_index < task.finish_index && tracklog.scoring_data.waypoints[wp_index] != null) {
            let leg_distance_m;
            let wp = task.waypoints[wp_index];
            console.log(`score_aat_one_pass() wp_index=${wp_index}, ${wp.get_name()} AAT=${wp.isAAT()}`);
            // For a non-AAT area WP or a WP not reached we simply add the leg length to the wp
            if (!wp.isAAT()) {
                let wp_pos = task.waypoints[wp_index].position;
                leg_distance_m = Geo.get_distance_m(point_A, wp_pos);
                point_A = wp_pos;
                //console.log(`wp_dist wp[${wp_index}] ${(leg_distance_m/1000).toFixed(2)}`);
            } else {
                // AAT AREA waypoint

                let point_B; // point_A and point_B are BEFORE/AFTER current AAT wp

                // Find point AFTER current area
                if (!task.waypoints[wp_index+1].isAAT()) {
                    // if next wp is a non-AAT just take wp position
                    console.log(`score_aat_one_pass() wp_index=${wp_index}, ${wp.get_name()} next WP is non-AAT.`);
                    point_B = task.waypoints[wp_index+1].position;
                } else {
                    // if next wp is AAT AREA then take current logpoints_index_aat
                    console.log(`score_aat_one_pass() wp_index=${wp_index}, ${wp.get_name()} next WP is AAT.`);
                    if (tracklog.scoring_data.waypoints[wp_index+1] == null ||
                        tracklog.scoring_data.waypoints[wp_index+1].logpoints_index_aat == null) {
                        point_B = task.waypoints[wp_index+1].position;
                        console.log(`score_aat_one_pass() wp_index=${wp_index} using next WP center as point_B`);
                    } else {
                        point_B = tracklog.logpoints[tracklog.scoring_data.waypoints[wp_index+1].logpoints_index_aat];
                        console.log(`score_aat_one_pass() wp_index=${wp_index} using next WP AAT logpoint as point_B`);
                    }
                }

                let index_exit = tracklog.scoring_data.waypoints[wp_index].logpoints_index_exit;
                if (index_exit == null || typeof index_exit == "undefined") {
                    console.log(`score_aat_one_pass() wp_index=${wp_index} landout in AAT area`);
                    index_exit = tracklog.scoring_data.landout.event_logpoints_index;
                }
                let area_max = tracklog.score_aat_into_area(
                    wp,
                    point_A,
                    point_B,
                    tracklog.scoring_data.waypoints[wp_index].logpoints_index,
                    index_exit
                );

                tracklog.scoring_data.waypoints[wp_index].logpoints_index_aat = area_max.logpoints_index;

                leg_distance_m = Geo.get_distance_m(point_A, tracklog.logpoints[area_max.logpoints_index]);

                point_A = tracklog.logpoints[area_max.logpoints_index];
            }
            //console.log(`B21_TrackLog.score_aat_one_pass() wp[${wp_index}] leg_distance_m=${leg_distance_m.toFixed(1)}`);

            tracklog.scoring_data.waypoints[wp_index].leg_distance_m = leg_distance_m;

            task_distance_m += leg_distance_m;
            wp_index++;
        }

        console.log(`score_aat_one_pass() to wp[${wp_index-1}] task_distance_m=${task_distance_m}`,tracklog.scoring_data.waypoints[wp_index-1]);
        let return_info = {}; // Data to be returned

        if (tracklog.finished_ok()) {
            // Successful completion
            // Add distance to finish
            let finish_distance_m = Geo.get_distance_m(point_A, task.waypoints[wp_index].position);

            console.log(`B21_TrackLog.score_aat_one_pass() finished OK finish_distance_m=${finish_distance_m.toFixed(1)}`);

            tracklog.scoring_data.waypoints[wp_index].leg_distance_m = finish_distance_m;

            task_distance_m += finish_distance_m;
        } else {
            // Landout
            console.log(`B21_TrackLog.score_aat_one_pass() calculating landout to wp[${wp_index}] after task_distance_m=${task_distance_m.toFixed(1)}`);
            let index_A; // Logpoint index to start finding min distance FROM
            let full_leg_distance_m;
            if (tracklog.scoring_data.waypoints[wp_index-1].is_aat) {
                // last WP is AAT  => index_A = logpoints_index_aat, full leg is from tracklog point
                index_A = tracklog.scoring_data.waypoints[wp_index-1].logpoints_index_aat;
                full_leg_distance_m = Geo.get_distance_m(point_A, task.waypoints[wp_index].position);
            } else {
                // last WP not AAT => index_A = scoring_data.waypoints[x].logpoints_index (i.e. entry)
                // full leg is simply task leg distance
                index_A = tracklog.scoring_data.waypoints[wp_index-1].logpoints_index;
                full_leg_distance_m = task.waypoints[wp_index].leg_distance_m;
            }
            let pos = tracklog.planner.task.waypoints[wp_index].position; // We're measuring distance to here
            let min_distance_info = tracklog.find_min_distance(index_A, tracklog.scoring_data.landout.event_logpoints_index, pos);

            let last_leg_distance_m = full_leg_distance_m - min_distance_info.distance_m;

            // Add to return_info
            return_info.logpoints_index = min_distance_info.logpoints_index;
            return_info.last_leg_distance_m = last_leg_distance_m;

            // full leg distance:
            //   not AAT => simply next_wp.leg_distance_m
            //   AAT => distance(point_A .. next_wp.position)
            // find_min_distance(point_A, landout.event_logpoints_index, next_wp.position)
            // last_leg_distance_m  = full_leg_distance - min_distance
            //let straight_last_leg_distance_m = Geo.get_distance_m(point_A, task.waypoints[wp_index].position);
            //let last_leg_distance_m = tracklog.scoring_data.landout.last_leg_distance_m;
            //console.log(`B21_TrackLog.score_aat_one_pass() landout last_leg_distance: ${(last_leg_distance_m/1000).toFixed(2)}km`);
            task_distance_m += last_leg_distance_m;
        }
        //console.log(`B21_TrackLog.score_aat_one_pass() task distance km=${(task_distance_m/1000).toFixed(1)}`);

        //tracklog.scoring_data.landout.max_distance_m = max_distance_m;
        //tracklog.scoring_data.landout.max_logpoints_index = max_logpoints_index;
        //tracklog.scoring_data.landout.last_leg_distance_m = last_leg_distance_m;
        //tracklog.scoring_data.landout.next_wp_index = wp_index;

        return_info.distance_m = task_distance_m;

        return return_info;
    }

    // Maximum distance from A to B via one point in area
    // Returns {distance_m, logpoints_index}
    score_aat_into_area(wp, point_A,point_B,logpoints_index_in, logpoints_index_exit) {
        let tracklog = this;
        console.log(`score_aat_distance_into_area [${point_A.lng},${point_A.lat}] to [${point_B.lng},${point_B.lat}] points[${logpoints_index_in}..${logpoints_index_exit}]`);
        let max_distance_m = 0;
        let max_point_index = 0;
        let max_first_leg_distance_m = 0;
        let max_second_leg_distance_m = 0;
        for (let logpoints_index=logpoints_index_in; logpoints_index<=logpoints_index_exit; logpoints_index++) {
            let point = tracklog.logpoints[logpoints_index];
            // Note scoring_data logpoints_index .. logpoints_index_exit can include points NOT in sector
            if (wp.in_sector(point)) {
                let first_leg_distance_m = Geo.get_distance_m(point_A, point);
                let second_leg_distance_m = Geo.get_distance_m(point, point_B);
                let distance_m = first_leg_distance_m + second_leg_distance_m;
                //console.log(`trying logpoints[${logpoints_index_in}] to logpoints[${logpoints_index_exit}] via logpoints[${logpoints_index}] distance=${distance_m.toFixed(2)}`);
                if (distance_m > max_distance_m) {
                    max_first_leg_distance_m = first_leg_distance_m;
                    max_second_leg_distance_m = second_leg_distance_m;
                    max_point_index = logpoints_index;
                    max_distance_m = distance_m;
                }
            }
        }

        // collect these values for log
        let wp_str = `wp[${wp.index}]`;
        let ts_str = `${tracklog.logpoints[max_point_index].time_iso}`;
        let leg1_str = `leg1:${(max_first_leg_distance_m/1000).toFixed(1)}`;
        let leg2_str = `leg2:${(max_second_leg_distance_m/1000).toFixed(1)}`;
        console.log(`wp_dist ${wp_str} at ${ts_str} ${leg1_str} ${leg2_str} area_distance_km=${(max_distance_m/1000).toFixed(2)}`);

        return { distance_m: max_distance_m, logpoints_index: max_point_index };
    }

    // ************************************************************************************************
    // ************************************************************************************************
    // ************** score_events                                                          ***********
    // **************   Mainly for NB21 event records like LTIM, SLEW, ENG                  ***********
    // **************   Populates the tracklog.scoring_events[] list                        ***********
    // ************************************************************************************************

    score_events(tracklog) {
        console.log(`B21_Tracklog.score_events ${tracklog.filename}`);
        tracklog.scoring_events = [];
        if (!tracklog.isNB21() || tracklog.scoring_data.started_ok == null) {
            console.log(`B21_Tracklog.score_events ${tracklog.filename} is not NB21 so returning.`);
            return;
        }

        // Detect landout (before check for 'no penalties' settings)
        tracklog.score_event_LAND(tracklog);

        if (tracklog.planner.settings.scoring_penalties != "yes") {
            console.log(`B21_Tracklog.score_events ${tracklog.filename} penalties disabled so returning.`);
            return;
        }

        if (tracklog.NB21_fcheck == null || tracklog.NB21_fcheck["IGC"] == null || tracklog.NB21_fcheck["IGC"] == "fail") {
            tracklog.igc_penalty = true;
            tracklog.penalties = true;
        }
        tracklog.score_event_LTIM(tracklog);
        tracklog.score_event_SLEW(tracklog); // Detect SLEW and set scoring_data.landout {ts: event_logpoints_index:}
        tracklog.score_event_JUMP(tracklog); // Detect altitude JUMP e.g. back-to-fly
        tracklog.score_event_ENG(tracklog);
        tracklog.score_event_RATE(tracklog);
        //console.log("B21_Tracklog.score_events completed "+tracklog.filename, tracklog.scoring_events);
        tracklog.score_event_WTHR(tracklog);
        tracklog.score_event_TOTW(tracklog);
    }

    // **************************************************************************
    // *** Score event WTHR
    // **************************************************************************

    score_event_WTHR(tracklog) {
        console.log(`B21_Tracklog.score_event_WTHR`);
        tracklog.weather_start_hash = null;
        tracklog.weather_start_name = null;
        let start_ts = tracklog.logpoints_file[tracklog.scoring_data.started_ok.logpoints_index].ts;
        console.log(`weather: score_event_WTHR with start time ${B21_Utils.hh_mm_ss_from_ts(start_ts)}`);
        for (let file_events_index=0; file_events_index<tracklog.file_events.length; file_events_index++) {
            let file_event = tracklog.file_events[file_events_index];
            if (file_event.event_key == "WTHR") {
                let hash = file_event.values[0];
                let name = tracklog.planner.weather.hash_to_name(hash);
                if (file_event.ts < start_ts) {
                    console.log(`Set weather_start_hash/name ${B21_Utils.hh_mm_ss_from_ts(file_event.ts)} ${hash} / ${name}`);
                    tracklog.weather_start_hash = hash;
                    tracklog.weather_start_name = name;
                } else {
                    console.log(`weather: add scoring-event ${B21_Utils.hh_mm_ss_from_ts(file_event.ts)} ${hash} / ${name}`);
                    tracklog.weather_penalty = true;
                    tracklog.penalties = true;
                    tracklog.scoring_events.push({
                        ts: file_event.ts,
                        event_key: "WTHR",
                        file_events_index: file_event.file_events_index,
                        text: name == null ? `Weather change unknown #${tracklog.format_weather_hash(hash)}` : `Weather: ${name}`
                    });
                }
            }
        }
    }

    // **************************************************************************
    // *** Score event TOTW
    // *** set tracklog.ballast_plus_penalty | overweight_penalty
    // **************************************************************************

    score_event_TOTW(tracklog) {
        console.log(`B21_Tracklog.score_event_TOTW`);
        let start_ts = tracklog.logpoints_file[tracklog.scoring_data.started_ok.logpoints_index].ts;
        console.log(`tracklog.score_event_TOTW() with start time ${B21_Utils.hh_mm_ss_from_ts(start_ts)}`);
        let start_weight_kg = null;
        let max_weight_kg = null;
        if (tracklog.glider_data != null && tracklog.glider_data.MAX_WEIGHT_KG != null) {
            console.log(`Tracklog.score_event_TOTW() ${tracklog.glider_type} has MAX_WEIGHT_KG of ${tracklog.glider_data.MAX_WEIGHT_KG}kg`);
            max_weight_kg = tracklog.glider_data.MAX_WEIGHT_KG;
        }

        for (let file_events_index=0; file_events_index<tracklog.file_events.length; file_events_index++) {
            let file_event = tracklog.file_events[file_events_index];
            if (file_event.event_key == "TOTW") {
                let weight_kg = file_event.values[0];
                if (file_event.ts < start_ts) {
                    console.log(`tracklog.score_event_TOTW() start_weight_kg ${B21_Utils.hh_mm_ss_from_ts(file_event.ts)} ${weight_kg}`);
                    start_weight_kg = weight_kg;
                } else {
                    //console.log(`tracklog.score_event_TOTW() after start ${B21_Utils.hh_mm_ss_from_ts(file_event.ts)} ${weight_kg}`);
                    if (weight_kg > max_weight_kg+2) {
                        console.log(`tracklog.score_event_TOTW() overweight ${B21_Utils.hh_mm_ss_from_ts(file_event.ts)} ${weight_kg}`);
                        tracklog.overweight_penalty = true;
                        tracklog.penalties = true;
                    }
                    if (weight_kg > start_weight_kg+1) {
                        console.log(`tracklog.score_event_TOTW() ballast+ ${B21_Utils.hh_mm_ss_from_ts(file_event.ts)} start:${start_weight_kg} now:${weight_kg}`);
                        tracklog.ballast_plus_penalty = true;
                        tracklog.penalties = true;
                    }
                }
            }
        }
    }

    // *****************************************
    // *** Score event LTIM
    // *****************************************
    score_event_LTIM(tracklog) {
        //console.log(`B21_Tracklog.score_event_LTIM`);
        let start_ts = tracklog.logpoints_file[tracklog.scoring_data.started_ok.logpoints_index].ts;
        let finish_ts = null;
        if (tracklog.finished_ok()) {
            finish_ts = tracklog.logpoints_file[tracklog.scoring_data.finished_ok.logpoints_index].ts;
        }
        // Now we need to check for NB21_LTIM records between start_ts and finish_ts
        let ltim_file_events = [];
        for (let file_events_index=0; file_events_index<tracklog.file_events.length; file_events_index++) {
            let file_event = tracklog.file_events[file_events_index];
            if (file_event.event_key == "LTIM" && file_event.ts > start_ts && (finish_ts == null || file_event.ts < finish_ts)) {
                ltim_file_events.push(file_event);
            }
        }
        //console.log("B21_Tracklog.score_event_LTIM "+tracklog.filename,ltim_file_events);

        // compress time_records to combine LTIM records close to each other
        let scoring_event_records = []
        for (let i=0; i<ltim_file_events.length; i++) {
            //console.log("B21_Tracklog.score_event_LTIM ["+i+"]");
            let ltim_file_event = ltim_file_events[i];
            // Add this record if it's the first, or more than 30 seconds after the previous time record
            if (i==0 || ltim_file_event.ts - scoring_event_records[scoring_event_records.length-1].ts > 30) {
                scoring_event_records.push({
                    ts: ltim_file_event.ts,
                    sim_time: ltim_file_event.values[1],
                    change_s: tracklog.LTIM_change_seconds(ltim_file_event.values[2]),
                    event_key: "LTIM",
                    file_events_index: ltim_file_event.file_events_index
                });
            } else {
                // If this LTIM record is within 30 seconds of the previous one, then combine them
                scoring_event_records[scoring_event_records.length-1].change_s += tracklog.LTIM_change_seconds(ltim_file_event.values[2]);
                scoring_event_records[scoring_event_records.length-1].ts = ltim_file_event.ts;
                scoring_event_records[scoring_event_records.length-1].sim_time = ltim_file_event.values[1];
                scoring_event_records[scoring_event_records.length-1].file_events_index = ltim_file_event.file_events_index;
            }
        }

        // Iterate compressed time_records and add text
        for (let i=0; i < scoring_event_records.length; i++) {
            scoring_event_records[i].text = tracklog.LTIM_text(scoring_event_records[i]);
        }

        //console.log("B21_Tracklog.score_event_LTIM text "+ tracklog.filename,scoring_event_records);
        // add to scoring_events:
        for (let i=0;i<scoring_event_records.length;i++) {
            tracklog.scoring_events.push(scoring_event_records[i]);
        }
    }


    // Calculate seconds from +/-hhmmss
    LTIM_change_seconds(t_str) {
        let sign = t_str.substring(0,1) == "+" ? 1 : -1;
        let h = parseInt(t_str.substring(1,3));
        let m = parseInt(t_str.substring(3,5));
        let s = parseInt(t_str.substring(5,7));
        return sign * (h*3600+m*60+s);
    }

    LTIM_text(time_record) {
        let sim_time_str = time_record.sim_time.substring(0,2)+":"+
            time_record.sim_time.substring(2,4)+":"+
            time_record.sim_time.substring(4,6);
        let change_s = Math.abs(time_record.change_s);
        let ss = ("0"+Math.floor(change_s % 60)).slice(-2);
        let mm = ("0"+Math.floor(change_s % 3600 / 60)).slice(-2);
        let hh = Math.floor(change_s / 3600);
        let advanced_str = time_record.change_s < 0 ? "+" : "-";
        return `Sim time ${advanced_str}${hh}:${mm}:${ss} to ${sim_time_str}`;
    }

    // **************************************************************************
    // *** Score event LAND
    // *** If LAND after Start then:
    // ***    scoring_data.landout != null
    // ***    scoring_data.landout = {
    // ***      ts: ,
    // ***      event_logpoints_index: ,
    // ***      event_key: "LAND" | "END",
    // ***      max_distance_m: will be added by score_max_task_distance_m
    // ***    }
    // *** where 'ts' is for the LAND
    // *** logpoints_index is the nearest logpoint
    // **************************************************************************

    score_event_LAND(tracklog) {
        //console.log(`B21_Tracklog.score_event_LAND`);
        tracklog.score_nb21_landout(tracklog,"LAND"); // NB21 Tracklog normally ends here
        //DEBUG we can add a simple landout detect to this if necessary (groundspeed zero?)
        if (tracklog.scoring_data.finished_ok == null) {
            //DEBUG is end of file correct here??
            let logpoints_index = tracklog.logpoints_file.length-1;
            let landout_ts = tracklog.logpoints_file[logpoints_index].ts;
            if (tracklog.scoring_data.landout == null || landout_ts < tracklog.scoring_data.landout.ts) {
                //console.log(`B21_Tracklog.score_event_LAND landout at logpoint[${logpoints_index}]`);
                tracklog.scoring_data.landout = {
                    ts: landout_ts,
                    event_logpoints_index: tracklog.logpoints_file.length-1,
                    event_key: "END"
                };
            }
        }
    }

    // **************************************************************************
    // *** Score event SLEW
    // *** If SLEW after Start then:
    // ***    scoring_data.landout != null
    // ***    scoring_data.landout = {
    // ***      ts: ,
    // ***      event_logpoints_index: ,
    // ***      event_key:
    // ***      max_distance_m: will be added by score_max_task_distance_m
    // ***    }
    // *** where 'ts' is for the SLEW
    // *** logpoints_index is the nearest logpoint
    // **************************************************************************

    score_event_SLEW(tracklog) {
        //console.log(`B21_Tracklog.score_event_SLEW`);
        tracklog.score_nb21_landout(tracklog, "SLEW");
    }

    score_event_JUMP(tracklog) {
        console.log("score_event_JUMP()");
        if (tracklog.slew_penalty) {
            console.log("JUMP exit slew penalty");
            return;
        }
        const start_index = tracklog.scoring_data["started_ok"]["logpoints_index"];
        let end_index = tracklog.logpoints_file.length;
        if (tracklog.scoring_data["finished_ok"] != null) {
            end_index = tracklog.scoring_data["finished_ok"]["logpoints_index"];
        }
        let p0 = tracklog.logpoints_file[start_index];
        for (let logpoints_index=start_index+1; logpoints_index < end_index; logpoints_index++) {
            let p1 = tracklog.logpoints_file[logpoints_index];
            let delta_ts = Math.max(1,p1.ts-p0.ts);
            const climb_ms = (p1.alt_m - p0.alt_m)/delta_ts;
            const accel_ms = (p1.speed_ms - p0.speed_ms)/delta_ts;
            const jump = climb_ms > 80 && accel_ms > -3;
            if (jump && (tracklog.scoring_data.landout == null || tracklog.scoring_data.landout.ts > p1.ts) ) {
                console.log(`JUMP adding scoring_data.landout`, p1);
                tracklog.scoring_data.landout = { ts: p1.ts, event_logpoints_index: logpoints_index, event_key: "JUMP" };
                break;
            }
            p0 = p1;
        }
    }

    // **************************************************************************
    // *** Score event ENG
    // **************************************************************************

    score_event_ENG(tracklog) {
        // Auto-generate a start " ENG  ON" FileEvent if not done already;
        let logpoint = tracklog.logpoints_file[tracklog.scoring_data.started_ok.logpoints_index];
        if (logpoint.ENL) {
            const ts = logpoint.ts+1;
            let remove_event_index = null;
            let existing_event = false;
            for (let i=0; i<tracklog.file_events.length; i++) {
                const file_event = tracklog.file_events[i];
                if (file_event.auto && file_event.event_key == "ENG") {
                    if (file_event.ts == ts) {
                        existing_event = true;
                        console.log(`B21_Tracklog.score_event_ENG() found existing file_event`);
                    } else {
                        remove_event_index = i;
                    }
                    break;
                }
            }
            if (remove_event_index != null) {
                console.log(`B21_Tracklog.score_event_ENG() removing file_event`);
                tracklog.file_events.slice(remove_event_index,1);
            }
            if (!existing_event) {
                console.log(`B21_Tracklog.score_event_ENG() adding file_event`);
                tracklog.file_events.push(new Tracklog_FileEvent("ENG","",ts,tracklog.file_events.length));
            }
        }

        tracklog.score_nb21_landout(tracklog, "ENG");
    }

    // **************************************************************************
    // *** Score event RATE
    // **************************************************************************

    score_event_RATE(tracklog) {
        tracklog.score_nb21_landout(tracklog, "RATE");
    }

    // ****************************************************************************
    // ** score_nb21_landout
    // *** updates tracklog.scoring_data.landout where event_key found in tracklog
    // ****************************************************************************

    score_nb21_landout(tracklog, event_key) {
        let proc_name = `B21_Tracklog.score_nb21_landout(${event_key})`;
        //console.log(proc_name);
        if (!tracklog.isNB21() || tracklog.scoring_data.started_ok == null) {
            return;
        }
        let start_logpoints_index = tracklog.scoring_data.started_ok.logpoints_index;
        let start_ts = tracklog.logpoints_file[start_logpoints_index].ts;
        let finish_ts = null;
        if (tracklog.finished_ok()) {
            finish_ts = tracklog.logpoints_file[tracklog.scoring_data.finished_ok.logpoints_index].ts;
        }
        // Now we need to check for event_key records between start_ts and finish_ts (or end of tracklog)
        for (let i=0; i<tracklog.file_events.length; i++) {
            let file_event = tracklog.file_events[i];
            // Currently taking first found, ignoring event_key parameters e.g. SLEW "ON" or SLEW "OFF"
            if (file_event.event_key == event_key && file_event.ts > start_ts && (finish_ts == null || file_event.ts < finish_ts)) {
                // nb21_key found during task!
                //console.log(`${proc_name} NB21 event event_key found at ${B21_Utils.hh_mm_ss_from_ts(file_event.ts)} ${file_event.disabled != null ? "disabled" : "not disabled"}`);
                if (event_key == "SLEW") {
                    tracklog.slew_penalty = true;
                    tracklog.penalties = true;
                } else if (event_key == "ENG") {
                    tracklog.eng_penalty = true;
                    tracklog.penalties = true;
                } else if (event_key == "RATE") {
                    tracklog.rate_penalty = true;
                    tracklog.penalties = true;
                } else if (event_key == "LAND") {
                    // Search forwards in case there's a 'TOFF' within a few seconds (MSFS glitch)
                    for (let j = i+1; j<tracklog.file_events.length; j++) {
                        let next_event = tracklog.file_events[j];
                        // Allow 3 seconds grace for a LAND event
                        if (next_event.event_key == "TOFF" && (next_event.ts - file_event.ts) < 3) {
                            file_event.disabled = true;
                            console.log(`${proc_name} NB21 LAND at ${B21_Utils.hh_mm_ss_from_ts(file_event.ts)} ${file_event.disabled != null ? "disabled" : "not disabled"}`);
                            break;
                        }
                    }
                }
                if (file_event.disabled == null && (tracklog.scoring_data.landout == null || tracklog.scoring_data.landout.ts > file_event.ts) ) {
                    //console.log(`${proc_name} adding scoring_data.landout`);
                    tracklog.scoring_data.landout = { ts: file_event.ts, event_logpoints_index: null, event_key: event_key };
                    tracklog.scoring_events.push( {
                        ts: file_event.ts,
                        event_key: event_key,
                        text: `(${event_key}: Landout)`,
                        file_events_index: file_event.file_events_index
                    });
                }
            }
        }
        // updated the landout event_logpoints_index if necessary
        if (tracklog.scoring_data.landout != null && tracklog.scoring_data.landout.event_logpoints_index == null) {

            let wp_logpoints_index = start_logpoints_index;
            // Skip forwards through scored waypoints to find logpoint for last waypoint before landout
            // This is just an efficiency optimisation so we search logpoints from there.
            for (let wp_index=tracklog.planner.task.start_index; wp_index < tracklog.planner.task.finish_index; wp_index++) {
                let wp_data = tracklog.scoring_data.waypoints[wp_index];
                if (wp_data == null) {
                    //console.log(`${proc_name} found end of completed WP's`);
                    break;
                }
                let wp_ts = tracklog.logpoints_file[wp_data.logpoints_index].ts;
                if (tracklog.scoring_data.landout.ts < wp_ts) {
                    //console.log(`${proc_name} landout_ts ${tracklog.scoring_data.landout.ts} before wp ${wp_index}`);
                    break;
                }
                wp_logpoints_index = wp_data.logpoints_index;
            }

            // now iterate through logpoints from here to find last one before/equal to end flight
            //console.log(`${proc_name} searching for landout from logpoint ${wp_logpoints_index}`);
            let logpoints_index;
            for (logpoints_index = wp_logpoints_index; logpoints_index < tracklog.logpoints_file.length - 1; logpoints_index++) {
                if (tracklog.logpoints_file[logpoints_index].ts > tracklog.scoring_data.landout.ts) {
                    logpoints_index--;
                    break;
                }
            }
            tracklog.scoring_data.landout.event_logpoints_index = logpoints_index;
            //console.log(`${proc_name} landout at logpoint ${logpoints_index}`);
        }
    }

    // **************************************************************************
    // *** clean_scoring_data_for_landout()
    // *** Removes completed waypoints and finish_ok if landout
    // **************************************************************************

    clean_scoring_data_for_landout(tracklog) {
        let proc_name = `B21_Tracklog.clean_scoring_data_for_landout()`;
        //console.log(`${proc_name}`);
        if (tracklog.scoring_data != null && tracklog.scoring_data.landout != null) {
            console.log(`${proc_name} cleaning ${JSON.stringify(tracklog.scoring_data)}`);
            tracklog.scoring_data.finished_ok = null;
            let event_logpoints_index = tracklog.scoring_data.landout.event_logpoints_index;
            let landout_logpoint = tracklog.logpoints_file[event_logpoints_index];
            //console.log(`${proc_name} landout at logpoints[${event_logpoints_index}] ${B21_Utils.hh_mm_ss_from_ts(landout_logpoint.ts)}`);
            for (let wp_index = 0; wp_index < tracklog.planner.task.waypoints.length; wp_index++) {
                if (tracklog.scoring_data.waypoints[wp_index] != null &&
                        tracklog.scoring_data.waypoints[wp_index].logpoints_index > event_logpoints_index) {
                    //console.log(`${proc_name} removing score for wp[${wp_index}]`);
                    tracklog.scoring_data.waypoints[wp_index] = null;
                }
            }
        }
    }
    // **************************************************************************
    // *** score_landout_max_distance()
    // *** Will create/update scoring_data.landout.max_task_distance
    // **************************************************************************

    // task_distance = (straight distance around task to next wp) - ('landout' distance from next wp)
    // scoring_data.landout adds {
    //           max_distance_m: ,
    //           max_logpoints_index:
    //           last_leg_distance_m:
    //           next_wp_index
    // }
    score_landout_max_distance(tracklog) {
        console.log(`B21_Tracklog.score_landout_max_distance()`);
        // If no landout, do nothing
        if (tracklog.scoring_data == null || tracklog.scoring_data.landout == null) {
            return;
        }

        console.log(`B21_Tracklog.score_landout_max_distance() landout already detected at ${B21_Utils.hh_mm_ss_from_ts(tracklog.scoring_data.landout.ts)}`);
        // If finished, acheived task distance is the total task distance
        // Task started but not finished, so find sum(completed leg distances) + (best distance on outlanding leg)
        let legs_distance_m = 0;
        let logpoints_index = tracklog.scoring_data.waypoints[tracklog.planner.task.start_index].logpoints_index;
        let wp_index = tracklog.planner.task.start_index + 1;
        // Accumulate the straight-line distances around completed waypoints PLUS to the next one.
        // We'll subtract the (max) distance the plane still has to go to the next waypoint.
        let wp = null;
        while (tracklog.scoring_data.waypoints[wp_index] != null) {
            wp = tracklog.planner.task.waypoints[wp_index];  // current waypoint
            legs_distance_m += wp.leg_distance_m;
            logpoints_index = tracklog.scoring_data.waypoints[wp_index].logpoints_index;
            wp_index++;
        }

        // legs_distance_m is cumulative task distance up to last acheived waypoint
        let next_wp = tracklog.planner.task.waypoints[wp_index]; // next waypoint

        console.log(`B21_Tracklog.score_landout_max_distance() task legs ${(legs_distance_m/1000).toFixed(2)}km to wp[${wp_index}]`);
        let ts_str = B21_Utils.hh_mm_ss_from_ts(tracklog.logpoints_file[logpoints_index].ts);
        console.log(`B21_Tracklog.score_landout_max_distance() calculating final leg from logpoint[${logpoints_index}] at ${ts_str}`);

        let landout_logpoints_index = tracklog.scoring_data.landout.event_logpoints_index;
        let min_distance_info = tracklog.find_min_distance(logpoints_index, landout_logpoints_index, next_wp.position);
        let last_leg_distance_m = next_wp.leg_distance_m - min_distance_info.distance_m;
        let max_distance_m = legs_distance_m + last_leg_distance_m;
        let max_logpoints_index = min_distance_info.logpoints_index;

        console.log(`B21_Tracklog.score_landout_max_distance() min_distance_info:`,min_distance_info);

        ts_str = B21_Utils.hh_mm_ss_from_ts(tracklog.logpoints_file[min_distance_info.logpoints_index].ts);
        console.log(`B21_Tracklog.score_landout_max_distance() achieved last leg:${(last_leg_distance_m/1000).toFixed(2)}km`);
        console.log(`B21_Tracklog.score_landout_max_distance() max_distance:${(max_distance_m/1000).toFixed(2)}km at ${ts_str}`);
        tracklog.scoring_data.landout.max_distance_m = max_distance_m;
        tracklog.scoring_data.landout.max_logpoints_index = max_logpoints_index;
        tracklog.scoring_data.landout.last_leg_distance_m = last_leg_distance_m;
        tracklog.scoring_data.landout.next_wp_index = wp_index;
    }

    // Find tracklog point between index_A .. index_B with MINIMUM distance to position pos.
    find_min_distance(index_A, index_B, pos) {
        let tracklog = this;
        let logpoints_index = index_A;
        let min_distance_m = null;
        let min_logpoints_index;
        // Search for max distance after the last completed waypoint
        while (logpoints_index <= index_B) {
            let distance_m = Geo.get_distance_m(tracklog.logpoints_file[logpoints_index], pos);
            if (min_distance_m == null || distance_m < min_distance_m) {
                min_distance_m = distance_m;
                min_logpoints_index = logpoints_index;
            }
            logpoints_index++;
        }
        return { distance_m: min_distance_m, logpoints_index: min_logpoints_index };
    }

    // ************************************************************************************************
    // ************************************************************************************************
    // ************** Display task completion info for this tracklog on "Tracklog Info" tab ***********
    // ************************************************************************************************
    // ************************************************************************************************

    display_info() {
        let tracklog = this;
        //console.log(`TrackLog.display_info() index=${tracklog.index} ${tracklog.filename}`);

        B21_Utils.clear_div(tracklog.info_name_el);
        let name_str = tracklog.get_name();
        let pilot_name = tracklog.get_pilot_name();
        let filename_str = tracklog.get_filename();
        let name_width = tracklog.info_name_el.offsetWidth;
        let filename_size = Math.max(...(filename_str.split(/[\s-]+/).map(el => el.length))); // find length of longest word in name
        //console.log("tracklog.display_info name_size=",filename_size, "name_width=", name_width);
        if (filename_size > 56) {
            //let divider = Math.round(Math.max(41,filename_size / 2));
            let fontsize = "14px"; //Math.max(9, Math.min( 16, name_width / 700 * 20)).toFixed(0)+"px";
            let front = filename_str.slice(0,48);
            let back = filename_str.slice(-8);
            filename_str = front + " ... " + back;
            //console.log("tracklog.display_info() adjusted filename_str="+filename_str);
            //console.log("tracklog.display_info() adjusting font size:",fontsize);
            tracklog.info_name_el.style = "font-size: "+fontsize; // scale font down from 16px
        }
        tracklog.info_name_el.innerHTML = "\""+pilot_name + "\" " + name_str + "<br/>" + filename_str;

        // Show load task button
        if (tracklog.hasTask) {
            tracklog.info_load_task_el.style.display = "inline-flex";
        } else {
            tracklog.info_load_task_el.style.display = "none";
        }

        // Show "draw AAT task" button
        if (tracklog.planner.task.isAAT()) {
            tracklog.info_draw_aat_task_el.style.display = "inline-flex";
        } else {
            tracklog.info_draw_aat_task_el.style.display = "none";
        }

        tracklog.unset_select_point_status(tracklog, null);
        tracklog.display_info_alerts();
        tracklog.display_info_body();
        tracklog.display_info_footer();
        tracklog.display_info_chart();
    }

    display_info_alerts() {
        let tracklog = this;
        B21_Utils.clear_div(tracklog.info_alerts_el);
        tracklog.display_info_alerts_summary();
        tracklog.display_info_vne_alert();
        tracklog.display_info_aat_alert();
    }

    display_info_alerts_summary() {
        let tracklog = this;
        let alert_str = "";
        if (tracklog.igc_penalty) {
            alert_str +="<div class='info_alert'>IGC</div>";
        }
        if (tracklog.slew_penalty) {
            alert_str +="<div class='info_alert'>SLEW</div>";
        }
        if (tracklog.eng_penalty) {
            alert_str +="<div class='info_alert'>MOTOR</div>";
        }
        if (tracklog.rate_penalty) {
            alert_str +="<div class='info_alert'>SIM_RATE</div>";
        }
        if (tracklog.vne_penalty_s > 0) {
            alert_str +="<div class='info_alert'>VNE</div>";
        }
        if (tracklog.weather_penalty) {
            alert_str +="<div class='info_alert'>WEATHER</div>";
        }

        if (tracklog.overweight_penalty) {
            alert_str +="<div class='info_alert'>WEIGHT</div>";

        }
        if (tracklog.ballast_plus_penalty) {
            alert_str +="<div class='info_alert'>BALLAST+</div>";
        }

        if (alert_str != "") {
            let summary_el = document.createElement("div");
            summary_el.className = "info_alerts_summary";
            summary_el.innerHTML = "<div class='alert_summary'>Alert summary:</div>"+alert_str;
            tracklog.info_alerts_el.appendChild(summary_el);
        }
    }

    display_info_vne_alert() {
        let tracklog = this;
        if (tracklog.vne_penalty_s > 1) {
            let info_alert = document.createElement("div");
            info_alert.className = "info_alert"
            let speed_units_str = "kph";
            let speed_factor = tracklog.MS_TO_KPH;
            if (tracklog.planner.settings.speed_units == "knots") {
                speed_units_str = "knots";
                speed_factor = tracklog.MS_TO_KNOTS;
            }
            let time_str = tracklog.vne_time_s.toFixed(0)+"s";
            let max_overspeed_ms = tracklog.vne_tas_max_ms - tracklog.VNE_TAS_MS;
            let vne_max_str = (max_overspeed_ms * speed_factor).toFixed(1) + speed_units_str;
            let penalty_str = B21_Utils.h_m_ss_from_ts_delta(tracklog.vne_penalty_s);
            let start_str = "";
            if (tracklog.vne_tas_start_ms > 0) {
                start_str = `START +${(tracklog.vne_tas_start_ms * speed_factor).toFixed(1)}${speed_units_str}`;
            }
            info_alert.textContent = `(beta) VNE ${start_str}: x${tracklog.vne_count}, ${time_str}, max +${vne_max_str}, sum ${tracklog.vne_ms_s.toFixed(1)} adjusted: ${penalty_str}`;
            tracklog.info_alerts_el.appendChild(info_alert);
        }
    }

    display_info_aat_alert() {
        let tracklog = this;
        if (tracklog.aat_penalty_s > 1) {
            let info_alert = document.createElement("div");
            info_alert.className = "info_alert"
            let penalty_str = B21_Utils.h_m_ss_from_ts_delta(tracklog.aat_penalty_s)
            info_alert.textContent = `(beta) AAT below min time: adjusted ${penalty_str}`;
            tracklog.info_alerts_el.appendChild(info_alert);
        }
    }

    display_info_body() {
        let tracklog = this;
        tracklog.display_info_details(); // General tracklog info on left
        tracklog.display_info_timeline();    // Timeline around task on right
    }

    // Display tracklog details on the left side of the tracklog_info_body area
    display_info_details() {
        let tracklog = this;
        console.log("TrackLog.display_info_details()");
        B21_Utils.clear_div(tracklog.info_details_el);

        if (tracklog.pilot_name != null & tracklog.pilot_name != "") {
            let div = document.createElement("div");
            div.className = "pilot";
            div.textContent = "Pilot: " + tracklog.pilot_name;
            tracklog.info_details_el.appendChild(div);
            //tracklog.info_details_el.innerHTML += "<b>Pilot: " + tracklog.pilot_name+"</b>";
        }

        if (tracklog.competition_id != null & tracklog.competition_id != "") {
            let div = document.createElement("div");
            div.className = "comp_id";
            div.innerHTML = "<b>Comp ID:</b> " + tracklog.competition_id;
            tracklog.info_details_el.appendChild(div);
            //tracklog.info_details_el.innerHTML += "<br/><b>Comp ID:</b> " + tracklog.competition_id;
        }

        if (tracklog.glider_type != null & tracklog.glider_type != "") {
            let div = document.createElement("div");
            div.className = "plane";
            div.innerHTML = "<b>Plane:</b> " + tracklog.glider_type;
            tracklog.info_details_el.appendChild(div);
            //tracklog.info_details_el.innerHTML += "<br/><b>Plane:</b> " + tracklog.glider_type;
        }

        if (tracklog.file_obj != null && tracklog.file_obj.creator != null && tracklog.file_obj.creator != "") {
            let div = document.createElement("div");
            div.className = "logger";
            div.innerHTML = "<b>Logger:</b> " + tracklog.file_obj.creator;
            tracklog.info_details_el.appendChild(div);
            //tracklog.info_details_el.innerHTML += "<br/><b>Logger:</b> " + tracklog.file_obj.creator;
        }

        if (tracklog.NB21_fcheck != null && !(JSON.stringify(tracklog.NB21_fcheck) === "{}")) {
            if (tracklog.NB21_fcheck["IGC"] != null) {
                let div = document.createElement("div");
                div.className = "igc";
                if (tracklog.NB21_fcheck["IGC"].startsWith("ok")) {
                    div.innerHTML = "🔒  tracklog";
                    //tracklog.info_details_el.innerHTML += "<br/>🔒" + "  tracklog";
                } else {
                    div.innerHTML = "⚠ IGC checksum error";
                    div.classList.add("alert");
                    //tracklog.info_details_el.innerHTML += "<br/>⚠ IGC checksum error";
                }
                tracklog.info_details_el.appendChild(div);
            } else {
                let div = document.createElement("div");
                div.className = "igc";
                div.innerHTML = "⚠ no IGC checksum";
                div.classList.add("alert");
                tracklog.info_details_el.appendChild(div);
                //tracklog.info_details_el.innerHTML += "<br/>⚠ no IGC checksum";
            }

            let ACFG_result = tracklog.NB21_fcheck["ACFG"];
            if (ACFG_result != null) {
                let div = document.createElement("div");
                div.className = "acfg";
                if (ACFG_result.startsWith("ok")) {
                    div.innerHTML = "🔒"+ACFG_result.slice(2) + " aircraft.cfg";
                    //tracklog.info_details_el.innerHTML += "<br/>"+"🔒" + " aircraft.cfg";
                } else {
                    div.classList.add("alert");
                    div.innerHTML = "⚠ aircraft.cfg checksum:<br/>&nbsp;&nbsp; "+ACFG_result;
                    //tracklog.info_details_el.innerHTML += "<br/>⚠ aircraft.cfg checksum:<br/>&nbsp;&nbsp; "+tracklog.NB21_fcheck["ACFG"];
                }
                tracklog.info_details_el.appendChild(div);
            } else {
                let div = document.createElement("div");
                div.className = "acfg";
                div.innerHTML = "⚠ no aircraft.cfg checksum";
                //tracklog.info_details_el.innerHTML += "<br/>⚠ no aircraft.cfg checksum";
            }

            let FMCG_result = tracklog.NB21_fcheck["FMCG"];
            if (FMCG_result != null) {
                let div = document.createElement("div");
                div.className = "fmcg";
                if (FMCG_result.startsWith("ok")) {
                    div.innerHTML = "🔒"+FMCG_result.slice(2) + " flight_model.cfg";
                    //tracklog.info_details_el.innerHTML += "<br/>"+"🔒"+FMCG_result.slice(2) + " flight_model.cfg";
                } else {
                    div.classList.add("alert");
                    div.innerHTML = "⚠ flight_model.cfg checksum:<br/>&nbsp;&nbsp; "+FMCG_result;
                    //tracklog.info_details_el.innerHTML += "<br/>⚠ flight_model.cfg checksum:<br/>&nbsp;&nbsp; "+tracklog.NB21_fcheck["FMCG"];
                }
                tracklog.info_details_el.appendChild(div);
            } else {
                let div = document.createElement("div");
                div.className = "acfg";
                div.classList.add("alert");
                div.innerHTML = "⚠ no flight_model.cfg checksum";
                //tracklog.info_details_el.innerHTML += "<br/>⚠ no flight_model.cfg checksum";
            }
        }
    }

    format_weather_hash(hash) {
        let tracklog = this;
        return `${hash.slice(0,3)}.${hash.slice(3,5)}.${hash.slice(5)}`;
    }

    // Display timed info for this TrackLog around the Task
    display_info_timeline() {
        let tracklog = this;
        console.log("TrackLog.display_info_timeline()");
        tracklog.select_point_info = null; // reset 'select point' status
        let task = tracklog.planner.task;
        B21_Utils.clear_div(tracklog.info_timeline_el);

        if (task.waypoints.length==0) {
            let no_task_el = document.createElement("div");
            no_task_el.innerHTML = "NO TASK LOADED";
            tracklog.info_timeline_el.appendChild(no_task_el);
            return;
        }
        if (tracklog.scoring_data==null) {
            let no_scoring_el = document.createElement("div");
            no_scoring_el.innerHTML = "TRACKLOG NOT SCORED";
            tracklog.info_timeline_el.appendChild(no_scoring_el);
            return;
        }

        //Show weather if we have it
        let weather_el = document.createElement("div");
        weather_el.className = "tracklog_info_weather";
        if (tracklog.weather_start_hash != null) {
            if (tracklog.weather_start_name != null) {
                weather_el.textContent = `Start weather: ${tracklog.weather_start_name}`;
            } else {
                weather_el.textContent = `Start weather #${tracklog.format_weather_hash(tracklog.weather_start_hash)} (unknown)`;
            }
        } else {
            weather_el.textContent = `Weather unknown`;
        }

        tracklog.info_timeline_el.appendChild(weather_el);

        // Write the tracklog task info into a FOUR COLUMN table (time, label, value(s))
        let timeline_table_el = document.createElement("table");
        timeline_table_el.id = "tracklog_info_timeline_table";

        // Add th header row to timeline table
        let header_el = document.createElement("tr");
        let header_time_el = document.createElement("th");
        header_time_el.innerText = "UTC Time";
        header_el.appendChild(header_time_el);
        header_el.appendChild(document.createElement("th"));
        header_el.appendChild(document.createElement("th"));
        header_el.appendChild(document.createElement("th"));

        timeline_table_el.appendChild(header_el);

        tracklog.info_timeline_el.appendChild(timeline_table_el);

        let wp_missed = false;
        let prev_wp_ts = null;
        // This 'outer loop' is iterating the waypoints start..finish
        for (let wp_index=task.start_index; wp_index<=task.finish_index; wp_index++) {
            let wp_scoring_data = tracklog.scoring_data.waypoints[wp_index];
            let wp = task.waypoints[wp_index];
            if (wp_scoring_data != null) {
                let logpoints_index;
                if (wp_scoring_data.is_aat) {
                    logpoints_index = wp_scoring_data.logpoints_index_aat;
                } else {
                    logpoints_index = wp_scoring_data.logpoints_index;
                }

                let logpoint = tracklog.logpoints_file[logpoints_index];
                if (wp_index>task.start_index) {
                    tracklog.display_scoring_events(timeline_table_el, prev_wp_ts, logpoint.ts);
                    tracklog.display_info_leg(timeline_table_el, wp, logpoint, prev_wp_ts);
                }
                prev_wp_ts = logpoint.ts;
                tracklog.display_info_wp(timeline_table_el, wp, logpoints_index);
            } else {
                // wp_scoring_data == null i.e. no completion time for this WP
                if (wp_index>task.start_index) {
                    tracklog.display_scoring_events(timeline_table_el, prev_wp_ts, null);
                    let logpoint = tracklog.logpoints_file[tracklog.scoring_data.landout.max_logpoints_index];
                    tracklog.display_info_landout(timeline_table_el);
                    tracklog.display_info_leg(timeline_table_el, wp, logpoint, prev_wp_ts);
                }
                tracklog.display_info_wp_missed(timeline_table_el, wp, wp_missed);
                wp_missed = true;
                // terminate loop here
                break;
            }
        }
    }

    // Display the leg distance / time / speed BEFORE the current WP
    display_info_leg(timeline_table_el, wp, logpoint, prev_wp_ts) {
        let tracklog = this;

        let info_el = document.createElement("tr");
        //info_el.className = "tracklog_wp_info";

        let spacer_el = document.createElement("td");
        info_el.appendChild(spacer_el);

        let leg_el = document.createElement("td");
        leg_el.setAttribute("colspan","2");

        leg_el.className = "tracklog_wp_info_leg";

        let time_s = logpoint.ts - prev_wp_ts;
        console.log(`B21_Tracklog.display_info_leg() time_s = ${time_s.toFixed(1)} prev_wp_ts = ${prev_wp_ts}`);
        let time_str = B21_Utils.h_mm_ss_from_ts_delta(time_s);

        let leg_distance_m;
        if (tracklog.scoring_data.waypoints[wp.index] != null) {
            leg_distance_m = tracklog.scoring_data.waypoints[wp.index].leg_distance_m;
        } else {
            leg_distance_m = tracklog.scoring_data.landout.last_leg_distance_m;
        }
        let distance_str = "";
        let speed_ms  = time_s > 0 ? leg_distance_m / time_s : 0;
        let speed_str = "";

        if (tracklog.planner.settings.distance_units == "miles") {
            let speed_knots = speed_ms * tracklog.MS_TO_KNOTS;
            speed_str = speed_knots.toFixed(1) + " knots";
            distance_str = (leg_distance_m * tracklog.M_TO_MILES).toFixed(1) + " miles";
        } else {
            let speed_kph = speed_ms * 3.6;
            speed_str = speed_kph.toFixed(1) + " kph";
            distance_str = (leg_distance_m / 1000).toFixed(1) + " km";
        }

        leg_el.innerText = `${distance_str} ${time_str}  ${speed_str}`;
        info_el.appendChild(leg_el);

        // Leg notes
        let leg_notes_el = document.createElement("td");
        //leg_notes_el.setAttribute("colspan","1");
        leg_notes_el.className = "tracklog_wp_info_leg_notes";
        info_el.appendChild(leg_notes_el);

        timeline_table_el.appendChild(info_el);

    }

    display_info_wp(timeline_table_el, wp, logpoints_index) {
        let tracklog = this;

        let logpoint = tracklog.logpoints_file[logpoints_index];

        let info_el = document.createElement("tr");
        info_el.className = "tracklog_wp_info";
        // Time
        let time_el = document.createElement("td");
        time_el.className = "tracklog_wp_info_time";

        time_el.innerHTML = "<b>"+B21_Utils.hh_mm_ss_from_iso(logpoint.time_iso)+"</b>";

        info_el.appendChild(time_el);
        // Name
        let aat_str = "";
        if (wp.isAAT()) {
            aat_str = "[AAT] ";
        }
        let name_el = document.createElement("td");
        name_el.className = "tracklog_wp_info_name";
        name_el.innerText = aat_str + wp.get_name();
        info_el.appendChild(name_el);
        // Altitude
        let alt_el = document.createElement("td");
        alt_el.className = "tracklog_wp_info_alt";
        alt_el.innerHTML = "<b>"+tracklog.altitude_str(logpoint.alt_m)+"</b>";
        info_el.appendChild(alt_el);

        // Notes
        let wp_notes_el = document.createElement("td");
        wp_notes_el.className = "tracklog_wp_info_notes";
        let notes_str = "";
        if (wp.is_task_start() || wp.is_task_finish()) {
            // Add TAS in notes_str to Start & Finish
            let tas_ms = tracklog.get_tas_ms(logpoints_index);
            if (tas_ms != null) {
                if (tracklog.planner.settings.speed_units == "knots") {
                    let speed_knots = tas_ms * tracklog.MS_TO_KNOTS;
                    notes_str = speed_knots.toFixed(0) + " knots";
                } else {
                    let speed_kph = tas_ms * 3.6;
                    notes_str = speed_kph.toFixed(0) + " kph";
                }
            }
            // Add weight and in-sim date/time to Start
            if (wp.is_task_start()) {
                // Add weight at start to notes_str
                let weight_kg = tracklog.get_weight_kg(logpoints_index);
                if (weight_kg != null) {
                    notes_str += " @ "+weight_kg.toFixed(0)+"kg";
                }
                // Add in-sim date/time to notes_str
                let sim_date = tracklog.get_sim_date(logpoints_index);
                let sim_time = tracklog.get_sim_time(logpoints_index);
                if (sim_date != null && sim_time != null) {
                    let month_index = parseInt(sim_date.substring(4,6));
                    let month = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"][month_index-1];
                    let date_str = "Sim time: "+sim_date.substring(6,8)+" "+month+" "+sim_date.substring(0,4);
                    let time_str = sim_time.substring(0,2)+":"+sim_time.substring(2,4)+":"+sim_time.substring(4,6);
                    notes_str += "<br/>"+date_str+" "+time_str;
                }
            }
        }
        wp_notes_el.innerHTML = notes_str;
        info_el.appendChild(wp_notes_el);

        timeline_table_el.appendChild(info_el);

    }

    // Add 'missed waypoint' row to tracklog info, 'wp_missed' true if EARLIER wp already missed
    display_info_wp_missed(timeline_table_el, wp, wp_missed) {
        let tracklog = this;
        let info_el = document.createElement("tr");
        info_el.className = "tracklog_wp_info";
        // Time (blank for missed wp)
        let time_el = document.createElement("td");
        time_el.className = "tracklog_wp_info_time";
        info_el.appendChild(time_el);
        // Name
        let name_el = document.createElement("td");
        name_el.className = "tracklog_wp_info_name";
        name_el.innerHTML = wp.get_name();
        info_el.appendChild(name_el);
        // Missed
        let missed_el = document.createElement("td");
        missed_el.className = "tracklog_wp_info_missed";
        missed_el.innerHTML = wp_missed ? "-----" : "MISSED";
        info_el.appendChild(missed_el);
        // Button
        let missed_button_el = document.createElement("td");
        missed_button_el.className = "tracklog_wp_info_missed_button";
        if (wp_missed) {
            missed_button_el.innerHTML = "";
        } else {
            let button_el = document.createElement("button");
            tracklog.unset_select_point_status(tracklog, button_el);
            button_el.addEventListener("click", (e) => { tracklog.pre_task_fixup(tracklog, e, wp.index); });
            missed_button_el.appendChild(button_el);
        }
        info_el.appendChild(missed_button_el);
        // Notes
        let wp_notes_el = document.createElement("td");
        wp_notes_el.className = "tracklog_wp_info_notes";
        wp_notes_el.innerHTML = "";
        info_el.appendChild(wp_notes_el);

        timeline_table_el.appendChild(info_el);
    }

    // Add landout record to timeline
    display_info_landout(timeline_table_el) {
        let tracklog = this;
        if (tracklog.scoring_data.landout == null) {
            console.warn(`B21_Tracklog.display_info_landout() ${tracklog.name} no scoring_data.landout`);
            return;
        }

        let scoring_landout = tracklog.scoring_data.landout;

        let max_logpoints_index = scoring_landout.max_logpoints_index;
        if (max_logpoints_index == null) {
            console.warn(`B21_Tracklog.display_info_landout() ${tracklog.name} no max_logpoints_index`);
            return;
        }

        let info_el = document.createElement("tr");
        info_el.className = "tracklog_wp_info";

        // Time
        let time_el = document.createElement("td");
        time_el.className = "tracklog_wp_info_time";

        let ts = tracklog.logpoints_file[max_logpoints_index].ts;
        let time_str = B21_Utils.hh_mm_ss_from_ts(ts);
        time_el.innerHTML = `<b>${time_str}</b>`;

        info_el.appendChild(time_el);

        // Landout
        let landout_el = document.createElement("td");
        landout_el.setAttribute("colspan","3");

        landout_el.className = "tracklog_wp_info_name";
        landout_el.innerText = "Landout";
        info_el.appendChild(landout_el);

        timeline_table_el.appendChild(info_el);
    }

    // Create/display the timeline entries for events between from_ts and to_ts
    display_scoring_events(timeline_table_el, from_ts, to_ts) {
        let tracklog = this;
        console.log(`B21_Tracklog.display_scoring_events() ${tracklog.name} from ${B21_Utils.hh_mm_ss_from_ts(from_ts)} to ${B21_Utils.hh_mm_ss_from_ts(to_ts)}`);
        // Sort the events by ts
        tracklog.scoring_events.sort( (a,b) => { return a.ts - b.ts });

        for (let i=0; i<tracklog.scoring_events.length; i++) {
            let scoring_event = tracklog.scoring_events[i];
            if (scoring_event.ts > from_ts && (to_ts == null || scoring_event.ts < to_ts)) {
                let info_el = document.createElement("tr");
                info_el.className = "tracklog_wp_info_events";

                // Time
                let time_el = document.createElement("td");
                time_el.className = "tracklog_wp_info_time";

                let time_str = B21_Utils.hh_mm_ss_from_ts(scoring_event.ts);
                time_el.innerHTML = time_str;

                info_el.appendChild(time_el);

                // Event
                let event_el = document.createElement("td");
                event_el.setAttribute("colspan","3");

                event_el.className = "tracklog_wp_info_event";
                let checkbox_str = "";
                if (tracklog.isNB21()) {
                    if (scoring_event.event_key == "SLEW" ||
                        scoring_event.event_key == "RATE" ||
                        scoring_event.event_key == "ENG" ||
                        scoring_event.event_key == "LAND") {
                        let file_events_index = scoring_event.file_events_index;
                        let checked = tracklog.file_events[file_events_index].disabled == null ? "checked" : "";
                        checkbox_str = `<input type="checkbox" onclick="b21_task_planner.scoring_event_click(${tracklog.index},${i})" ${checked} />`;
                    }
                }
                event_el.innerHTML = checkbox_str + scoring_event.text;
                info_el.appendChild(event_el);

                timeline_table_el.appendChild(info_el);
            }
        }
    }

    scoring_event_click(scoring_events_index) {
        let tracklog = this;
        console.log(`B21_Tracklog.scoring_event_click(${scoring_events_index})`);
        let file_events_index = tracklog.scoring_events[scoring_events_index].file_events_index;
        tracklog.file_events[file_events_index].disabled = true;
        // re-score this tracklog, and re-display the tracklog info & chart
        tracklog.score_task();
        tracklog.display_info();
        tracklog.draw_chart();
        tracklog.planner.display_tracklogs(tracklog.planner)
    }

    display_info_footer() {
        let tracklog = this;
        let task = tracklog.planner.task;
        B21_Utils.clear_div(tracklog.info_footer_el);
        // Write TASK COMPLETION FOOTER
        if (tracklog.scoring_data["finished_ok"] != null) {
            let finish_data = tracklog.scoring_data.finished_ok;
            let task_completion_el = document.createElement("div");
            task_completion_el.setAttribute("id", "tracklog_task_completion");
            tracklog.info_footer_el.appendChild(task_completion_el);

            //finished_ok: { logpoints_index: , wp_index: , task_time_s: , task_speed_ms }
            // Append task completion time
            let task_completion_time_el = document.createElement("div");
            task_completion_time_el.setAttribute("id", "tracklog_task_completion_time");
            task_completion_el.appendChild(task_completion_time_el);
            let task_time_s = finish_data["task_time_s"];
            let ss = ("0"+Math.floor(task_time_s % 60)).slice(-2);
            let mm = ("0"+Math.floor(task_time_s % 3600 / 60)).slice(-2);
            let hh = Math.floor(task_time_s / 3600);

            // Get task distance
            let distance_m;
            if (task.isAAT()) {
                distance_m = tracklog.scoring_data.finished_ok.distance_m;
            } else {
                distance_m = task.get_task_distance_m();
            }
            let dist_str;
            if (tracklog.planner.settings.distance_units == "miles") {
                dist_str = (distance_m * tracklog.M_TO_MILES).toFixed(2) + " miles";
            } else {
                dist_str = (distance_m / 1000).toFixed(2) + " km";
            }
            task_completion_time_el.innerText = `${dist_str} completed in ${hh}:${mm}:${ss}`;

            // Append task completion speed
            let task_completion_speed_el = document.createElement("div");
            task_completion_speed_el.setAttribute("id", "tracklog_task_completion_speed");
            task_completion_el.appendChild(task_completion_speed_el);
            // Make speed display string
            let speed_ms = distance_m / task_time_s;
            if (tracklog.planner.settings.distance_units == "miles") {
                let speed_knots = speed_ms * tracklog.MS_TO_KNOTS;
                task_completion_speed_el.innerHTML = `Task speed ${speed_knots.toFixed(2)} knots`;
            } else {
                let speed_kph = speed_ms * 3.6;
                task_completion_speed_el.innerHTML = `Task speed ${speed_kph.toFixed(2)} kph`;
            }
        } else if (tracklog.scoring_data.landout != null) {
            // Write LANDOUT FOOTER
            let landout = tracklog.scoring_data.landout;
            let task_landout_el = document.createElement("div");
            task_landout_el.setAttribute("id", "tracklog_task_landout");
            tracklog.info_footer_el.appendChild(task_landout_el);

            //landout: { logpoints_index: , event_key: , max_distance_m:, max_logpoints_index: , ts: }
            // Append task landout reason "Landout (SLEW at 20:33:24)"
            let task_landout_reason_el = document.createElement("div");
            task_landout_reason_el.setAttribute("id", "tracklog_task_landout_reason");
            task_landout_el.appendChild(task_landout_reason_el);

            let event_ts = landout.ts;
            let event_time_str = B21_Utils.hh_mm_ss_from_ts(event_ts);
            let reason_str = tracklog.landout_reason_str(landout.event_key);
            task_landout_reason_el.innerHTML = `Landout (${reason_str} at ${event_time_str})`;

            // Append task landout speed
            let task_landout_distance_el = document.createElement("div");
            task_landout_distance_el.setAttribute("id", "tracklog_task_landout_speed");
            task_landout_el.appendChild(task_landout_distance_el);
            let max_distance_m = landout.max_distance_m;
            let max_ts = tracklog.logpoints_file[landout.max_logpoints_index].ts;
            let max_time_str = B21_Utils.hh_mm_ss_from_ts(max_ts);
            let max_distance_str;
            if (tracklog.planner.settings.distance_units == "miles") {
                max_distance_str =  `${(max_distance_m * tracklog.M_TO_MILES).toFixed(1)} miles`;
            } else {
                max_distance_str =  `${(max_distance_m / 1000).toFixed(1)} km`;
            }
            task_landout_distance_el.innerHTML = `Max distance ${max_distance_str} at ${max_time_str}`;
        }
    }

    landout_reason_str(event_key) {
        switch (event_key) {
            case "END":
                return "Tracklog ends";
            case "LAND":
                return "Landing";
            case "ENG":
                return "Engine use";
            case "SLEW":
                return "Slew";
            case "RATE":
                return "Sim rate change";
            default:
                return event_key;
        }
    }

    display_info_chart() {
        this.info_chart.draw(this.info_chart_el, false);
    }

    // ****************************************************************************************
    // Scoring WP fixup code, i.e. allow user to select a tracklog point for WP success
    // ****************************************************************************************

    // User has clicked "Set Point" button to fix up some missed waypoint on Tracklog Info
    pre_task_fixup(tracklog, e, wp_index) {
        console.log("tracklog.pre_task_fixup for WP ", wp_index);
        if (tracklog.select_point_info == null) {
            tracklog.set_select_point_status(tracklog, e.target);
            tracklog.select_point_info = { "mode": "task_fixup", "wp_index": wp_index };
        } else {
            // Reset the task fixup process by redrawing the task info
            tracklog.display_info();
        }
    }

    task_fixup(tracklog, wp_index, logpoints_index) {
        console.log("Task_fixup", wp_index, logpoints_index);
        let task = tracklog.planner.task;
        // Ensure the waypoint can't be fixed up to BEFORE a prior waypoint
        if (wp_index > 0 &&
            tracklog.scoring_data != null &&
            tracklog.scoring_data.waypoints[wp_index-1] != null &&
            logpoints_index <= tracklog.scoring_data.waypoints[wp_index-1]["logpoints_index"]
            ) {
            alert("Cannot fixup a WP completion BEFORE prior waypoint");
        } else {
            if (tracklog.task_fixup_info == null) {
                tracklog.task_fixup_info = {};
            }
            tracklog.task_fixup_info[""+wp_index] = logpoints_index;
        }
        tracklog.score_task();

        tracklog.display_info();

        tracklog.planner.display_tracklogs(tracklog.planner);
    }

    cancel_fixup(tracklog) {
        console.log("Cancel fixup for tracklog "+tracklog.index);
        if (tracklog.info_chart.chart == null) {
            console.error(`B21_Tracklog.cancel_fixup() ${tracklog.filename} exit no chart.`);
            return;
        }
        tracklog.info_chart.chart.update({ chart: { backgroundColor: "white" }});
        tracklog.display_info();
    }

    // Flip the planner into 'select point' mode for a waypoint fixup
    set_select_point_status(tracklog, button_el) {
        console.log(`B21_Tracklog.set_select_point_status() ${tracklog.filename}`);
        if (tracklog.info_chart.chart == null) {
            console.error(`B21_Tracklog.set_select_point_status() ${tracklog.filename} exit no chart.`);
            return;
        }

        let select_color = '#FCFFC5';
        button_el.innerHTML = "CLICK POINT ON BARO CHART";
        button_el.style.backgroundColor = select_color;
        button_el.title = "Click on the tracklog baro chart to select a point for this WP, or click this button again to cancel.";
        tracklog.planner.tracklog_fixup_button_el.addEventListener("click",(e) => { tracklog.cancel_fixup(tracklog); });
        tracklog.planner.replay_el.style.display = "none";
        tracklog.planner.tracklog_fixup_el.style.display = "block";
        tracklog.planner.tracklog_info_el.style.display = "none";
        tracklog.info_chart.draw(tracklog.map_chart_el, true);
        tracklog.info_chart.chart.update({ chart: { backgroundColor: select_color }});
    }

    unset_select_point_status(tracklog, button_el) {
        //console.log(`B21_Tracklog.unset_select_point_status() ${tracklog.filename}`);
        if (tracklog.info_chart.chart == null) {
            console.error(`B21_Tracklog.unset_select_point_status() ${tracklog.filename} exit no chart.`);
            return;
        }

        if (button_el != null) {
            button_el.innerHTML = "CHOOSE POINT TO FIX";
            // Revert the color highlight in case they were previously set
            button_el.style.removeProperty("background-color");
            button_el.title = "You can change this WP to 'success' by choosing a point on the tracklog.";
        }
        tracklog.planner.replay_el.style.display = "flex";
        tracklog.planner.tracklog_fixup_el.style.display = "none";
        tracklog.planner.tracklog_info_el.style.display = "block";
        console.log("tracklog.unset_select_point_status() chart.update()",
            tracklog.name, tracklog.info_chart.options, tracklog.info_chart.chart);
        //tracklog.info_chart.chart.update({ chart: { backgroundColor: 'white' }})
    }

    // **************************************************************************************
    // ************ Create the SVG glider aircraft_marker to show position on map   *********
    // **************************************************************************************

    create_marker() {
        let tracklog = this;
        let position = new L.latLng(0, 0);
        let c1 = "#fff";
        let c2 = "#fff";
        if (tracklog.index!=0) {
            c1 = tracklog.color1;
            c2 = tracklog.color2 == null ? tracklog.color1 : tracklog.color2;
        }
        // Glider icon with separate wings & fuselage for coloring
        const svgIcon = L.divIcon({
            html: `
            <svg width="64" height="64" xmlns="http://www.w3.org/2000/svg">
             <g id="Layer_1">
              <title>Layer 1</title>
              <path id="wings" d="M33 37 h 14 l 12 2 v 2 h -56 v -2 l 12 -2 z" stroke="#000" fill="`+c1+`"/>
              <path id="fuselage" d="M30 31 h 2 l 1 6 v4 l -1 20  h 5 v 2 h -12 v -2  h 5 l -1 -20 v -4 z" stroke="#000" fill="`+c2+`"/>
             </g>
            </svg>
            `,
            className: "",
            iconSize: [64,64],
            iconAnchor: [32,32]
        });

        let aircraft_marker = L.marker([0,0], {
            icon: svgIcon,
            clickable: false,
            interactive: false,
            bubblingMouseEvents: true,
            rotationOrigin: 'center'
        }); // extended using leaflet.rotationMarker

        let popup = L.popup({
            closeButton: false,
            className: "tracklog_popup",
            autoPan: false,
            autoClose: false
        }).setContent("no name set");

        aircraft_marker.bindPopup(popup);

        //aircraft_marker.on('mouseover', function(event) {
        //    aircraft_marker.openPopup();
        //});
        //aircraft_marker.on('mouseout', function(event) {
        //    aircraft_marker.closePopup();
        //});
        //aircraft_marker.on('click', (e) => {
        //    console.log("User icon click, popup open=",aircraft_marker.isPopupOpen(), aircraft_marker.getPopup().isOpen());
        //    aircraft_marker.openPopup();
        //});

        aircraft_marker.addTo(tracklog.planner.map);

        return aircraft_marker;
    }

    aircraft_marker_update(tracklog) {
        try {
            let name_str = tracklog.name;

            if (tracklog.logpoints_index != null) {
                let p1 = tracklog.logpoints[tracklog.logpoints_index];

                let alt_str = "";
                let speed_str = "";
                let seperator = "";

                if (tracklog.icon_altitude_display) {
                    alt_str = (p1.alt_m * tracklog.alt_scalar).toFixed(0) + tracklog.alt_units_str;
                    seperator = "<br/>";
                }

                if (tracklog.icon_speed_display) {
                    speed_str = seperator + ((p1.speed_ms == null ? 0 : p1.speed_ms) * tracklog.speed_scalar).toFixed(
                        0) + tracklog.speed_units_str ;
                }

                let competition_id_str = "";
                if (tracklog.competition_id != null) {
                    competition_id_str = tracklog.competition_id;
                }

                let tail_str = "";
                if (tracklog.icon_name_display && competition_id_str != "") {
                    tail_str = '<div><div class="tracklog_icon_competition_id">'+competition_id_str+"</div></div>";
                }

                let popup_str = '<div class="tracklog_icon_popup">'+alt_str + speed_str + tail_str + "</div>";

                tracklog.aircraft_marker.setPopupContent(popup_str);
            } else {
                tracklog.aircraft_marker.setPopupContent(name_str);
            }
            // Set text for the glider aircraft_marker popup
        } catch (e) {
            console.log("aircraft_marker_update exception",e);
        }
    }

    // *****************************************************************************************************
    // *****************************      Load Task       **************************************************
    // *****************************************************************************************************

    load_task(task) {
        let tracklog = this;
        //DEBUG temporarily disabling NB21 check if (tracklog.isNB21()) {
        if (tracklog.file_obj.file_type=="igc") {
            tracklog.file_obj.load_task(task);
        }
    }

    // *****************************************************************************************************
    // *****************************         Replay       **************************************************
    // *****************************************************************************************************

    // Will be called by b21_task_planner, given incremental timestamps
    replay_ts(ts) {
        let tracklog = this;
        //console.log(`tracklog[${tracklog.index}] replay_ts`, ts);
        // This returns the
        let logpoints_index = tracklog.ts_to_logpoints_index_proportion(tracklog.logpoints_index,ts + tracklog.replay_ts_offset);
        try {
            tracklog.set_logpoints_index(logpoints_index, true); // the 'true' flag says we're in replay, so don't update charts
        } catch (e) {
            console.log(`// DEBUG B21_Tracklog.replay_ts exception ${tracklog.filename} logpoints_index=${logpoints_index}`, e);
            throw new Error('replay_ts exception');
        }
    }

    replay_restart() {
        let tracklog = this;
        console.log("B21_Tracklog.replay_restart()");
        //console.log(`tracklog[${tracklog.index}] replay_restart()`);
        tracklog.set_logpoints_index(0);
        if (tracklog.checked) {
            tracklog.draw_map();
        }
    }

    // Called by b21_task_planner to offset the timing of this tracklog, to sync starts
    replay_update_offset(replay_start_ts) {
        let tracklog = this;
        if (replay_start_ts == null) {
            tracklog.replay_ts_offset = 0;
        } else {
            let start_ts = tracklog.get_start_ts();
            if (start_ts == null) {
                tracklog.replay_ts_offset = 0;
            } else {
                tracklog.replay_ts_offset = start_ts - replay_start_ts;
            }
        }
        //console.log("replay_update_offset for tracklog",tracklog.index,replay_start_ts, tracklog.replay_ts_offset);
    }


    // *****************************************************************************************************
    // *****************************    Local Player from LNB21 Logger      ********************************
    // *****************************************************************************************************

    // Initialise this tracklog for a local NB21 aircraft
    init_local_player() {
        let tracklog = this;
        try {
            tracklog.file_obj = new B21_File_IGC(tracklog);
        } catch (e) {
            console.log("B21_Tracklog.create_local exception");
            console.error(e);
        }
    }

    update_local_player_header(msg) {
        let tracklog = this;

        //console.log(`B21_Tracklog.update_local_player_header(${msg})`);
        if (tracklog.file_obj != null) {
            tracklog.file_obj.update_local_player_header(msg);
        } else {
            console.log(`B21_Tracklog.update_local_player_header() file_obj == null`);
            return;
        }
        if (tracklog.hasTask) {
            console.log(`B21_Tracklog.update_local_player_header() header contains task.`);
            if (tracklog.file_obj.c_records_changed()) {
                // We will not override a manually loaded task PLN file
                if (!tracklog.planner.task.available() || tracklog.planner.task.isLocal()) {
                    tracklog.planner.init_task(tracklog.planner);
                    tracklog.planner.load_task_from_tracklog(tracklog);
                    //tracklog.planner.task.isNB21(true);
                    //tracklog.planner.task.isLocal(true);
                } else {
                    console.log(`B21_Tracklog.update_local_player_header() no task load as PLN already loaded.`);
                }
            } else {
                console.log(`B21_Tracklog.update_local_player_header() no task load as c_records unchanged.`);
            }
        }
    }

    // Create a new tracklog point (if B record)
    update_local_player(msg) {
        let tracklog = this;
        //console.log(`B21_Tracklog.update_local_player(${msg})`);
        if (tracklog.file_obj != null) {
            return tracklog.file_obj.update_local_player(msg);
        } else {
            console.log(`B21_Tracklog.update_local_player() file_obj == null`);
            return null;
        }
    }

    // ************************************************************
    // Display entry on planner "Tracklogs" tab
    // ************************************************************

    display_entry(table_el) {
        let tracklog = this;
        let planner = tracklog.planner;

        // The index of this tracklog is tracklog.index
        // The task planner 'current tracklog' is planner.tracklog_index
        //console.log("B21_TaskPlanner.Displaying tracklogs entry tracklog.index=" + tracklog.index + " current=" + planner.tracklog_index);
        let tracklogs_entry_el = document.createElement("tr");
        tracklogs_entry_el.className = tracklog.index == planner.tracklog_index ? "tracklogs_entry_current" : "tracklogs_entry";

        // ***********************************
        // entry_checkbox
        // ***********************************
        let checkbox_td_el = document.createElement("td");
        checkbox_td_el.className = "tracklogs_entry_checkbox";
        tracklogs_entry_el.appendChild(checkbox_td_el);

        let checkbox_el = document.createElement("input");
        checkbox_el.setAttribute("type", "checkbox");
        if (tracklog.checked) {
            checkbox_el.setAttribute("checked", "checked");
        }

        // Set up click callback, where e will be the element clicked
        checkbox_el.addEventListener("click", (e) => {
            planner.tracklog_checkbox_clicked(planner, e, tracklog.index);
        });

        checkbox_td_el.appendChild(checkbox_el);

        // ***********************************
        // entry_info
        // ***********************************
        let tracklogs_entry_info_el = document.createElement("td"); // TrackLog name
        tracklogs_entry_info_el.className = "tracklogs_entry_info";
        tracklogs_entry_info_el.title = "Click for task results.";
        tracklogs_entry_info_el.addEventListener("click", (e) => {
            console.log("B21_TaskPlanner tracklogs_entry clicked. Tracklog index="+tracklog.index);
            if (tracklog.index == planner.tracklog_index &&
                    getComputedStyle(planner.tracklog_info_el, null).getPropertyValue("display") == "block") {
                planner.close_tracklog_info();
            } else {
                planner.set_current_tracklog(tracklog.index);
                planner.show_tracklog_info();
            }
        });

        // IF we have pilot_name info, list this first
        //if (tracklog.pilot_name != null) {
        //    let pilot_name_el = document.createElement("div");
        //    pilot_name_el.textContent = tracklog.pilot_name;
        //    tracklogs_entry_info_el.appendChild(pilot_name_el);
        //}

        // Create first row (NAME) div content
        let name_el = document.createElement("div");
        name_el.className = "tracklogs_entry_name";

        let igc_check = ""; // Create prepend string for tracklogs with good checksums
        if (tracklog.NB21_fcheck != null &&
            tracklog.NB21_fcheck["IGC"] != null && tracklog.NB21_fcheck["IGC"].startsWith("ok")) {
            igc_check = "🔒";
        }

        let name_str = igc_check + tracklog.get_name();
        console.log("B21_TaskPlanner.tracklogs_entryinfo tracklog.get_name() returned tracklog.name "+name_str);
        name_el.textContent = name_str;
        let name_size = Math.max(...(name_str.split(/[\s-]+/).map(el => el.length))); // find length of longest word in name
        //console.log("B21TaskPlanner name_size=", name_size, name_str);
        if (name_size > 28) {
            name_el.style = "font-size: " + (14 * 28 / name_size).toFixed(0) + "px;"; // scale font down from 14px
        }

        // ***********************************
        // entry_finished
        // ***********************************
        let tracklogs_entry_finished_el = document.createElement("div"); // TrackLog finished task indicator
        tracklogs_entry_finished_el.className = "tracklogs_entry_finished";
        //tracklogs_entry_finished_el.addEventListener("click", (e) => {
        //    planner.set_current_tracklog(tracklog.index);
        //    planner.show_tracklog_info();
        //});
        if (planner.task.waypoints.length > 0) {
            if (tracklog.is_finished()) {
                tracklogs_entry_finished_el.className = "tracklogs_entry_finished_ok"+(tracklog.penalties ? " penalties" : "");
                if (tracklog.scoring_data["finished_ok"] != null && tracklog.scoring_data.finished_ok.task_speed_ms != null) {
                    let scoring_content_el = document.createElement("span");

                    // Task time "1:20:22"
                    let task_time_s = tracklog.scoring_data.finished_ok.task_time_s;
                    let task_time_str = B21_Utils.h_mm_ss_from_ts_delta(task_time_s);

                    // Speed "123.4kph"
                    let speed_ms = tracklog.scoring_data.finished_ok.task_speed_ms;
                    let speed = planner.settings.distance_units == "km" ? speed_ms * planner.MS_TO_KPH : speed_ms * planner.MS_TO_KNOTS;
                    let speed_str = speed.toFixed(1) + (planner.settings.distance_units == "km" ? "kph" : "knots");

                    // Distance for AAT
                    let aat_distance_str = "";
                    if (planner.task.isAAT()) {
                        let distance_m = tracklog.scoring_data.finished_ok.distance_m;
                        let distance = planner.settings.distance_units == "km" ? distance_m / 1000 : distance_m * planner.M_TO_MILES;
                        aat_distance_str = distance.toFixed(1) +  (planner.settings.distance_units == "km" ? "km" : "miles");
                    }
                    scoring_content_el.innerText = ` ${task_time_str} ${aat_distance_str} ${speed_str}`;
                    tracklogs_entry_finished_el.appendChild(scoring_content_el);
                }
            } else if (tracklog.scoring_data != null && tracklog.scoring_data.landout != null) {
                tracklogs_entry_finished_el.style.backgroundColor = "pink";
                let content_el = document.createElement("span");

                let distance_m = tracklog.scoring_data.landout["max_distance_m"];
                let distance_str;
                if (planner.settings.distance_units == "miles") {
                    distance_str =  `${(distance_m * planner.M_TO_MILES).toFixed(1)} miles`;
                } else {
                    distance_str =  `${(distance_m / 1000).toFixed(1)} km`;
                }
                content_el.innerHTML = `${distance_str}`;

                tracklogs_entry_finished_el.appendChild(content_el);
            }
        }

        name_el.appendChild(tracklogs_entry_finished_el);


        tracklogs_entry_info_el.appendChild(name_el);

        // info: filename
        let filename_el = document.createElement("div");
        filename_el.className = "tracklogs_entry_filename";
        let filename_str = tracklog.get_filename();
        filename_el.innerHTML = filename_str;
        let filename_size = Math.max(...(filename_str.split(" ").map(el => el.length))); // find length of longest word in name
        //console.log("B21TaskPlanner filename_size=",filename_size, filename_str);
        if (filename_size > 38) {
            if (filename_size > 53) {
                let front = filename_str.slice(0,27);
                let back = filename_str.slice(-18);
                filename_el.innerHTML = front+"&nbsp;...&nbsp;"+back;
                filename_size = 38;
            }
            filename_el.style = "font-size: " + Math.min(12,Math.max(8, 14 * 38 / filename_size)).toFixed(0) + "px;"; // scale font down from 14px
        }
        tracklogs_entry_info_el.appendChild(filename_el);

        // info: begin_date
        let begin_date_el = document.createElement("div");
        begin_date_el.innerHTML = "Begins: " + (new Date(tracklog.get_begin_ts() * 1000)).toUTCString().substring(5, 22) + "Z";
        tracklogs_entry_info_el.appendChild(begin_date_el);

        tracklogs_entry_el.appendChild(tracklogs_entry_info_el);

        // ***********************************************************
        // entry_colors - this shows the color-code for this tracklog
        // ***********************************************************
        let entry_colors_el = document.createElement("td"); // TrackLog colors bar
        entry_colors_el.className = "tracklogs_entry_colors_td";

        // Create the DOM object (3 stacked divs) to hold the tracklog colors
        let colors_el = document.createElement("div");
        colors_el.className = "tracklogs_entry_colors"; // set width of column
        entry_colors_el.appendChild(colors_el);

        let color_top_el = document.createElement("div");
        color_top_el.className = "tracklogs_entry_color_top";
        colors_el.appendChild(color_top_el);

        let color_middle_el = document.createElement("div");
        color_middle_el.className = "tracklogs_entry_color_middle";
        colors_el.appendChild(color_middle_el);

        let color_bottom_el = document.createElement("div");
        color_bottom_el.className = "tracklogs_entry_color_bottom";
        colors_el.appendChild(color_bottom_el);

        //console.log(`display_tracklogs_entry setting tracklog ${tracklog.name} color1=${tracklog.color1} color2=${tracklog.color2}`);
        color_top_el.style.backgroundColor = tracklog.color1;
        color_middle_el.style.backgroundColor = tracklog.color2 == null ? tracklog.color1 : tracklog.color2;
        color_bottom_el.style.backgroundColor = tracklog.color1;

        //console.log(`display_tracklogs_entry set tracklog ${tracklog.name} color_top_el=${color_top_el.style.backgroundColor}`);

        // ***********************************************************
        // Append this tracklogs_entry
        // ***********************************************************
        tracklogs_entry_el.appendChild(entry_colors_el);

        table_el.appendChild(tracklogs_entry_el);

        tracklog.tracklogs_entry_el = tracklogs_entry_el;
    }


    // ************************************************************
    // Display entry on planner "Tracklogs" tab scoresheet
    // ************************************************************

    display_scoresheet_entry(scoresheet_el, csv) {
        let tracklog = this;
        let planner = tracklog.planner;
        let task = planner.task;

        let tracklog_el = document.createElement("div");

        let name = tracklog.pilot_name == null ? '?' : tracklog.pilot_name;
        let id = tracklog.competition_id == null ? '?' : tracklog.competition_id;
        let glider_type = tracklog.glider_type == null ? '?' : tracklog.glider_type;
        let task_speed = "";
        let task_distance = "";
        let task_time = "";
        let penalties = "";
        let speed_factor = planner.settings.distance_units == "km" ? planner.MS_TO_KPH : planner.MS_TO_KNOTS;
        let speed_units = planner.settings.distance_units == "km" ? "kph" : "knots";
        if (tracklog.finished_ok() && tracklog.scoring_data.finished_ok.task_speed_ms != null) {
            let task_speed_ms = tracklog.scoring_data.finished_ok.task_speed_ms;
            // Get task distance
            let distance_m = tracklog.scoring_data.finished_ok.distance_m;

            task_distance = (distance_m / 1000).toFixed(1);
            let task_time_s = tracklog.scoring_data.finished_ok.task_time_s;
            if (tracklog.planner.settings["scoring_penalties"] == "yes") {
                if (tracklog.vne_penalty_s > 0) {
                    penalties += `(Vne ${B21_Utils.h_m_ss_from_ts_delta(tracklog.vne_penalty_s)}) `;
                }
                if (tracklog.aat_penalty_s > 0) {
                    penalties += `(AAT ${B21_Utils.h_m_ss_from_ts_delta(tracklog.aat_penalty_s)}) `;
                }
            }
            task_speed = (task_speed_ms * speed_factor).toFixed(1);
            task_time = B21_Utils.h_mm_ss_from_ts_delta(task_time_s);

        }
        if (tracklog.scoring_data.landout != null && tracklog.scoring_data.landout["max_distance_m"] != null) {
            task_distance = (tracklog.scoring_data.landout["max_distance_m"] / 1000).toFixed(1);
        }
        // Display scoresheet entry as CSV or padded plain text
        if (csv) {
            // Display CSV
            tracklog_el.innerText = `${name},${id},${glider_type},${task_distance},${task_time},${task_speed},${penalties}`;
        } else {
            // Display plain text
            name = name.padEnd(15,' ');
            id = id.padEnd(9,' ');
            glider_type = glider_type.padEnd(7,' ');
            task_speed = task_speed.padStart(5,' ');
            task_time = task_time;
            if (tracklog.scoring_data.landout != null) {
                task_distance = task_distance.padStart(6,' ').padStart(13,' ');
                tracklog_el.innerText = `${name} ${id} ${glider_type} ${task_distance}km`;
            } else {
                if (task.isAAT()) {
                    task_distance = task_distance.padStart(6,' ');
                    tracklog_el.innerText = `${name} ${id} ${glider_type} ${task_distance}km ${task_time} ${task_speed}${speed_units} ${penalties}`;
                } else {
                    tracklog_el.innerText = `${name} ${id} ${glider_type} ${task_time} ${task_speed}${speed_units} ${penalties}`;
                }
            }
        }
        scoresheet_el.appendChild(tracklog_el);
    }

} // End class B21_TrackLog

// ***********************************************
// ** Class Tracklog_FileEvent                       **
// ** Holds entry for each Tracklog_FileEvent record **
//  { buf: original record string               **
//    ts: JS UTC timestamp                      **
//    event_key: Tracklog_FileEvent record type      **
//                   e.g. "TOTW"                **
//    values: [val1, val2.. depends on type]    **
//    file_events_index: index in .file_events   **
//  }                                           **
// ***********************************************

class Tracklog_FileEvent {

    constructor(event_key, buf, ts, file_events_index) {
        // buf
        this.buf = buf;
        this.ts = ts;
        this.values = null;
        this.auto = event_key != null; // this FileEvent auto-generated during scoring
        this.event_key = event_key == null ? buf.substring(13,17).trim() : event_key; // e.g. "TOTW", "ENG"
        this.file_events_index = file_events_index;

        switch (this.event_key) {
            // Aircraft checksums
            case "FCHK":
                break;
            // Date/Time affecting records
            // In-sim local date change
            case "LDAT":
                //              sim date before       sim date after
                this.values = [ buf.substring(18,26), buf.substring(27,35)]; // e.g. "20231207"
                break;
            // In-sim local time change
            case "LTIM":
                //              sim time before       sim time after        change in +/-hhmmss
                this.values = [ buf.substring(18,24), buf.substring(25,31), buf.substring(32)]; // e.g. "180327"
                break;
            // PC system clock change
            case "PTIM":
                break;
            // Sim rate change
            case "RATE":
                this.values = [ parseFloat(buf.substring(18,24)), parseFloat(buf.substring(24)) ];
                break;
            case "TOTW":
                this.values = [ parseInt(buf.substring(18,24))]; // e.g. "000599" kg
                break;
            case "PAUS":
                if (buf.includes("OFF")) {
                    this.values = [ "OFF", parseInt(buf.substring(22)) ];
                } else {
                    this.values = [ "ON" ]
                }
                break;
            case "LDAC":
                this.values = [ buf.substring(18) ];
                break;
            case "ENG":
                this.values = [ buf.includes("OFF") ? "OFF" : "ON"];
                break;
            case "SLEW":
                this.values = [ buf.includes("OFF") ? "OFF" : "ON", parseInt(buf.substring(22))];
                break;
            // Takeoff / Landing
            case "TOFF":
                break;
            case "LAND":
                break;
            // Weather change
            case "WTHR":
                this.values = [ buf.substring(18,26)]; // e.g. "012345"
            // Wind band records
            case "WBND":
                break;
            case "WCAG":
                break;
            case "WSAG":
                break;
            case "WDAG":
                break;
            case "WCMS":
                break;
            case "WSMS":
                break;
            case "WDMS":
                break;
            default:
                //throw new Error(`B21_File_IGC.Tracklog_FileEvent unrecognized record type ${this.event_key}`);
                break;
        } // end switch
    } // end constructor
} // end class Tracklog_FileEvent

"use strict"

class B21_Utils {

    static clear_div(d) {
        while (d.firstChild) {
            d.removeChild(d.lastChild);
        }
    }

    static hh_mm_ss_from_iso(time_iso) {
        // "2023-11-22T19:04:28.000Z"
        let pos_t = time_iso.indexOf('T');
        return time_iso.slice(pos_t + 1, pos_t + 9);
        //return (new Date(time_iso)).toTimeString().split(' ')[0];
    }

    // convert seconds to H:MM:SS where H is variable number of digits
    static h_mm_ss_from_ts_delta(delta_s) {
        let s = Math.round(delta_s);
        let hours = Math.floor(s / 3600);
        let mins = Math.floor((s - hours * 3600) / 60);
        let secs = Math.floor(s % 60);

        let mm = ("0"+mins).slice(-2)+":";

        let ss = ("0"+secs).slice(-2);

        return hours+":"+mm+ss;
    }

    // convert seconds to HH:MM:SS where HH optional, MM can be single digit
    static h_m_ss_from_ts_delta(delta_s) {
        let s = Math.round(delta_s);
        let hours = Math.floor(s / 3600);
        let mins = Math.floor((s - hours * 3600) / 60);
        let secs = Math.floor(s % 60);

        let hh = hours==0 ? "" : hours+":";

        let mm = ("0"+mins).slice(-2)+":";

        if (hh=="" && mm.startsWith("0")) {
            mm = mm.slice(1);
        }

        let ss = ("0"+secs).slice(-2);

        return hh+mm+ss;
    }

    // convert seconds to HH:MM:SS where HH is optional, MM minimum 2 digits
    static hh_mm_ss_from_ts_delta(delta_s) {
        let s = Math.round(delta_s);
        let hours = Math.floor(s / 3600);
        let mins = Math.floor((s - hours * 3600) / 60);
        let secs = Math.floor(s % 60);

        let hh = "";
        if (hours >= 10) {
            hh = ""+hours+":";
        } else if (hours > 0) {
            hh = "0"+hours+":";
        }

        let mm = ("0"+mins).slice(-2)+":";

        let ss = ("0"+secs).slice(-2);

        return hh+mm+ss;
    }

    // convert seconds to HH:MM
    static hh_mm_from_ts_delta(delta_s) {
        // Round to nearest minute
        let s = Math.round(delta_s / 60) * 60;
        if (delta_s == null || isNaN(s)) {
            return null;
        }
        let hh_mm_ss = B21_Utils.h_mm_ss_from_ts_delta(s);
        return ("0"+hh_mm_ss.slice(0,-3)).slice(-5);
    }

    // convert seconds timestamp ts as "hh:mm:ss"
    static hh_mm_ss_from_ts(ts) {
        let d = new Date(ts * 1000);
        return B21_Utils.hh_mm_ss_from_datetime(d);
    }

    // convert JS datetime to "hh:mm:ss"
    static hh_mm_ss_from_datetime(d) {
        let hh = ('0'+d.getUTCHours()).slice(-2);
        let mm = ('0'+d.getUTCMinutes()).slice(-2);
        let ss = ('0'+d.getUTCSeconds()).slice(-2);
        return hh+":"+mm+":"+ss;
    }

    // convert hh:mm to seconds, hh optional
    static hh_mm_to_time_s(str) {
        return B21_Utils.hh_mm_ss_to_time_s(str+":00");
    }

    // convert hh:mm:ss to seconds, hh & mm optional
    static hh_mm_ss_to_time_s(str) {
        let time_parts = str.split(":");
        try {
            let s = parseInt(time_parts[time_parts.length-1]);
            let m = 0;
            let h = 0;
            if (time_parts.length > 1) {
                m = parseInt(time_parts[time_parts.length-2]);
            }
            if (time_parts.length > 2) {
                h = parseInt(time_parts[time_parts.length-3]);
            }
            let time_s = s + 60*m + 3600*h;
            if (isNaN(time_s)) {
                return null;
            }
            return time_s;
        } catch(e) {
            console.warn(e);
            return null;
        }
    }

    // Convert hhmmss into time-of-day in seconds
    static hhmmss_to_time_s(str) {
        return parseInt(str.substring(0,2)) * 3600 + parseInt(str.substring(2,4)) * 60 + parseInt(str.substring(4,6));
    }

    static file_suffix(filename) {
        return filename.toLowerCase().split('.').pop();
    }
}
// ******************************************************************************
// ***********   B21_Weather class          ************************************
// ******************************************************************************

// Imports MSFS WPR weather file data into a JS B21_Weather object

class B21_Weather {

    constructor(planner) {
        let wx = this;
        console.log("B21_Weather.constructor");

        wx.planner = planner;
    }

    init() {
        let wx = this;
        // Common properties in WPR file
        wx.filename = null;
        wx.name = null; // Preset name that's displayed inside MSFS
        wx.alt_amgl = null;       // status of WPR IsAltitudeAMGL flag, i.e. true if altitudes are ABOVE GROUND
        wx.pressure_mb = null;    // air pressure in millibars
        wx.temperature_k = null;  // temperature in Kelvin

        // Wind properties
        wx.windlayers = []; // { alt_m, speed_ms, angle_deg }
        wx.windlayer_index = null; // current wind layer

        // Cloud layers
        wx.cloudlayers = []; // {alt_bottom_m, alt_top_m, density, cover, scatter}

        // Properties for 'default wind' using in wind rose
        wx.speed_ms = null; // chosen 'default' wind speed for this weather (WPR contains multiple layers)
        wx.angle_deg = null; // wind angle for the wx.speed_ms 'default' wind speed
        wx.alt_m = null;    // altitude of 'default' wind

        wx.hash = null;
    }

    set_filename(filename) {
        let wx = this;
        wx.filename = filename;
    }

    load_wpr_str(wpr_str) {
        let wx = this;
        console.log("B21_Weather.load_wpr_str");
        const parser = new DOMParser();
        try {
            const dom = parser.parseFromString(wpr_str, "application/xml");
            let wpr_el = dom.getElementsByTagName("WeatherPreset.Preset")[0];

            wx.load_name(wpr_el);

            if (wx.name != null) {
                wx.hash = wx.name_to_hash(wx.name);
            }

            wx.load_alt_amgl(wpr_el);

            wx.load_pressure(wpr_el);

            wx.load_temperature(wpr_el);

            // ***************************
            // WindLayers
            let windlayer_els = wpr_el.getElementsByTagName("WindLayer"); //XMLNodeList
            for (let i = 0; i < windlayer_els.length; i++) {
                wx.add_windlayer(windlayer_els[i]);
            }

            // ***************************
            // Cloud layers
            let cloudlayer_els = wpr_el.getElementsByTagName("CloudLayer"); //XMLNodeList
            for (let i = 0; i < cloudlayer_els.length; i++) {
                wx.add_cloudlayer(cloudlayer_els[i]);
            }

            // Set wx.speed_ms, alt_m, angle-deg values
            wx.set_default_wind();

            return true;
        } catch (e) {
            console.log("B21_Weather.DEBUG WPR load exception",e);
            return false;
        }
    }

    // ***************
    // name
    // ***************

    load_name(wpr_el) {
        let wx = this;
        let name = wpr_el.getElementsByTagName("Name")[0].childNodes[0].nodeValue;
        if (name != null) {
            wx.name = name;
        }
        console.log("B21_Weather name = " + wx.name);
    }

    // ***************
    // pressure (mb)
    // ***************

    load_pressure(wpr_el) {
        let wx = this;
        let pressure_str = wpr_el.getElementsByTagName("MSLPressure")[0].getAttribute("Value");
        let pressure_units_str = wpr_el.getElementsByTagName("MSLPressure")[0].getAttribute("Unit");
        if (pressure_units_str == "pa") {
            wx.pressure_mb = parseFloat(pressure_str) / 100;
        } else {
            wx.pressure_mb = 1013.25;
        }
        console.log("B21_Weather pressure = " + wx.pressure_mb);
    }

    // ***************
    // temperature (k)
    // ***************

    load_temperature(wpr_el) {
        let wx = this;
        let temperature_str = wpr_el.getElementsByTagName("MSLTemperature")[0].getAttribute("Value");
        let temperature_units_str = wpr_el.getElementsByTagName("MSLTemperature")[0].getAttribute("Unit");
        if (temperature_units_str == "k") {
            wx.temperature_k = parseFloat(temperature_str);
        } else {
            wx.temperature_k = 273.15;
        }
        console.log("B21_Weather temperature = " + wx.temperature_k);
    }

    // ***************
    // alt_amgl
    // ***************

    load_alt_amgl(wpr_el) {
        let wx = this;
        let alt_amgl = wpr_el.getElementsByTagName("IsAltitudeAMGL")[0].childNodes[0].nodeValue;
        if (alt_amgl != null) {
            wx.alt_amgl = alt_amgl.toLowerCase() == "true";
        }
        console.log("B21_Weather alt_amgl = " + wx.alt_amgl);
    }

    // ***************
    // windlayer
    //   <WindLayer>
    //       <WindLayerAltitude Value="2149.843" Unit="m"></WindLayerAltitude>
    //       <WindLayerAngle Value="135.000" Unit="degrees"></WindLayerAngle>
    //       <WindLayerSpeed Value="17.000" Unit="knts"></WindLayerSpeed>
    //   </WindLayer>
    // ***************

    add_windlayer(windlayer_el){
        let wx = this;
        let windlayer = {};
        // alt_m
        let alt_str = windlayer_el.getElementsByTagName("WindLayerAltitude")[0].getAttribute("Value");
        let alt_units_str = windlayer_el.getElementsByTagName("WindLayerAltitude")[0].getAttribute("Unit");
        if (alt_units_str == "m") {
            windlayer["alt_m"] = parseFloat(alt_str);
        } else {
            windlayer["alt_m"] = parseFloat(alt_str) / wx.planner.M_TO_FEET;
        }

        // angle_deg
        let angle_str = windlayer_el.getElementsByTagName("WindLayerAngle")[0].getAttribute("Value");
        windlayer["angle_deg"] = parseFloat(angle_str);

        // speed_ms
        let speed_str = windlayer_el.getElementsByTagName("WindLayerSpeed")[0].getAttribute("Value");
        let speed_units_str = windlayer_el.getElementsByTagName("WindLayerSpeed")[0].getAttribute("Unit");
        if (speed_units_str == "knts") {
            windlayer["speed_ms"] = parseFloat(speed_str) / wx.planner.MS_TO_KNOTS;
        } else {
            windlayer["speed_ms"] = parseFloat(speed_str) / wx.planner.MS_TO_KPH;
        }

        wx.windlayers.push(windlayer);
        console.log("B21_Weather windlayer = ",windlayer);
    }

    //
    // <CloudLayer>
    //    <CloudLayerDensity Value="0.997" Unit="(0 - 1)"></CloudLayerDensity>
    //    <CloudLayerCoverage Value="0.000" Unit="(0 - 1)"></CloudLayerCoverage>
    //    <CloudLayerAltitudeBot Value="15625.913" Unit="m"></CloudLayerAltitudeBot>
    //    <CloudLayerAltitudeTop Value="15625.913" Unit="m"></CloudLayerAltitudeTop>
    //    <CloudLayerScattering Value="1.000" Unit="(0 - 1)"></CloudLayerScattering>
    // </CloudLayer>

    add_cloudlayer(cloudlayer_el) {
        let wx = this;
        let cloudlayer = {};

        // alt_bottom_m, alt_top_m
        let alt_bottom_str = cloudlayer_el.getElementsByTagName("CloudLayerAltitudeBot")[0].getAttribute("Value");
        let alt_units_str = cloudlayer_el.getElementsByTagName("CloudLayerAltitudeBot")[0].getAttribute("Unit");
        if (alt_units_str == "m") {
            cloudlayer["alt_bottom_m"] = parseFloat(alt_bottom_str);
        } else {
            cloudlayer["alt_bottom_m"] = parseFloat(alt_bottom_str) / wx.planner.M_TO_FEET;
        }

        let alt_top_str = cloudlayer_el.getElementsByTagName("CloudLayerAltitudeTop")[0].getAttribute("Value");
        if (alt_units_str == "m") {
            cloudlayer["alt_top_m"] = parseFloat(alt_top_str);
        } else {
            cloudlayer["alt_top_m"] = parseFloat(alt_top_str) / wx.planner.M_TO_FEET;
        }

        // density
        let density_str = cloudlayer_el.getElementsByTagName("CloudLayerDensity")[0].getAttribute("Value");
        cloudlayer["density"] = parseFloat(density_str);

        // cover
        let cover_str = cloudlayer_el.getElementsByTagName("CloudLayerCoverage")[0].getAttribute("Value");
        cloudlayer["cover"] = parseFloat(cover_str);

        // scatter
        let scatter_str = cloudlayer_el.getElementsByTagName("CloudLayerScattering")[0].getAttribute("Value");
        cloudlayer["scatter"] = parseFloat(scatter_str);

        wx.cloudlayers.push(cloudlayer);

    }

    set_default_wind() {
        let wx = this;
        // Choose a default wind speed and direction for the current WPR.
        // This is an approximation from the multiple layers in the WPR but is useful for simple applications
        // like a single wind arrow
        wx.speed_ms = 0;
        wx.angle_deg = 0;
        for (let i =0; i < wx.windlayers.length; i++) {
            let layer = wx.windlayers[i];
            if (layer["speed_ms"] > wx.speed_ms) { // current algorithm is simply to choose the fastest wind layer
                wx.speed_ms = layer["speed_ms"];
                wx.angle_deg = layer["angle_deg"];
                wx.alt_m = layer["alt_m"];
                wx.windlayer_index = i;
            }
        }
    }

    set_windlayer_index(windlayer_index) {
        let wx = this;
        console.log("B21_Weather.set_windlayer_index "+windlayer_index);
        if (windlayer_index != null && windlayer_index < wx.windlayers.length) {
            let layer = wx.windlayers[windlayer_index];
            wx.speed_ms = layer["speed_ms"];
            wx.angle_deg = layer["angle_deg"];
            wx.alt_m = layer["alt_m"];
            wx.windlayer_index = windlayer_index;
        }
    }

    // Display tabular details of the weather info in the 'weather' tab on the left_pane
    display_weather_info(weather_info_el) {
        let wx = this;
        let info_html = wx.header_template();

        // name
        info_html = info_html.replace("#WEATHER_NAME#",wx.name);

        // hash
        info_html = info_html.replace("#WEATHER_HASH#",wx.hash == null ? "unknown" : wx.hash);

        // amgl vs msl
        let amgl_str = wx.alt_amgl ? "AGL !!" : "MSL";
        info_html = info_html.replace("#WEATHER_AMGL#",amgl_str);

        // filename
        info_html = info_html.replace("#WEATHER_FILENAME#",wx.filename);

        // pressure
        info_html = info_html.replace("#WEATHER_PRESSURE#",wx.pressure_mb.toFixed(2)+" mb");

        // temperature
        info_html = info_html.replace("#WEATHER_TEMPERATURE#",(wx.temperature_k - 273.15).toFixed(0)+" °C");

        // WIND LAYERS

        let wind_html = wx.wind_header_template();
        // set speed units
        let speed_units_str = wx.planner.settings.speed_units == "kph" ? "kph" : "knots";
        wind_html = wind_html.replace("#SPEED_UNITS#", speed_units_str);
        // set altitude units
        let altitude_units_str = wx.planner.settings.altitude_units == "m" ? "m" : "feet";
        wind_html = wind_html.replace("#ALTITUDE_UNITS#", altitude_units_str + (wx.alt_amgl ? " AGL" : ""));

        let speed_scalar = wx.planner.settings.speed_units == "kph" ? wx.planner.MS_TO_KPH : wx.planner.MS_TO_KNOTS;

        let altitude_scalar = wx.planner.settings.altitude_units == "m" ? 1 : wx.planner.M_TO_FEET;

        for (let i=0; i<wx.windlayers.length; i++) {
            let wind = wx.windlayers[i];

            let windlayer_html = wx.wind_layer_template();

            if (wx.windlayer_index != null && i == wx.windlayer_index) {
                windlayer_html = windlayer_html.replace("#CLASSNAME#", 'class="weather_info_layer_selected"');
            } else {
                windlayer_html = windlayer_html.replace("#CLASSNAME#", '');
            }

            windlayer_html = windlayer_html.replace("#WINDLAYER_INDEX#", i);

            windlayer_html = windlayer_html.replace("#WIND_SPEED#", (wind.speed_ms * speed_scalar).toFixed(0));

            windlayer_html = windlayer_html.replace("#WIND_ALTITUDE#", (wind.alt_m * altitude_scalar).toFixed(0));

            windlayer_html = windlayer_html.replace("#WIND_DIRECTION#", wind.angle_deg.toFixed(0));

            wind_html += windlayer_html;
        }

        wind_html += wx.wind_footer_template();

        info_html += wind_html;

        // CLOUD LAYERS

        let cloud_html = wx.cloud_header_template();

        cloud_html = cloud_html.replace("#ALTITUDE_UNITS#", altitude_units_str + (wx.alt_amgl ? " AGL" : ""));

        for (let i=0; i<wx.cloudlayers.length; i++) {
            let cloud = wx.cloudlayers[i];
            let cloudlayer_html = wx.cloud_layer_template();

            let alt_range_str = (cloud.alt_bottom_m * altitude_scalar).toFixed(0)+".."+(cloud.alt_top_m * altitude_scalar).toFixed(0);
            cloudlayer_html = cloudlayer_html.replace("#ALTITUDE_RANGE#", alt_range_str);

            cloudlayer_html = cloudlayer_html.replace("#DENSITY#", cloud.density.toFixed(2));

            cloudlayer_html = cloudlayer_html.replace("#COVER#", (cloud.cover * 100).toFixed(0)+"%");

            cloudlayer_html = cloudlayer_html.replace("#SCATTER#", cloud.scatter.toFixed(2));

            cloud_html += cloudlayer_html;
        }

        cloud_html += wx.cloud_footer_template();

        info_html += cloud_html;

        // Header done, add this html to the "weather_info" element
        weather_info_el.innerHTML = info_html;
    }

    name_to_hash(name) {
        let wx = this;
        console.log("B21_Weather.name_to_hash", name);
        if (!(typeof wx.planner.B21_WEATHER_DATA == null)) {
            if (wx.planner.B21_WEATHER_DATA[name] != null) {
                return wx.planner.B21_WEATHER_DATA[name].hash;
            } else {
                return null;
            }
        } else {
            console.warn("B21_Weather wx.planner.B21_WEATHER_DATA not available");
            return null;
        }
    }

    hash_to_name(hash) {
        let wx = this;
        console.log("B21_Weather.hash_to_name", hash);
        if (!(typeof wx.planner.B21_WEATHER_DATA == null)) {
            for ( let name in wx.planner.B21_WEATHER_DATA ) {
                if (wx.planner.B21_WEATHER_DATA[name].hash == hash) {
                    return name;
                }
            }
        } else {
            console.warn("B21_Weather wx.planner.B21_WEATHER_DATA not available");
        }
        return null;
    }

    // ********************************************************************
    // We populate these HTML templates to build the Weather info content
    // ********************************************************************

    header_template() {
        return `
    <div><b>Name: #WEATHER_NAME#</b></div>
    <div><b>Ref: ##WEATHER_HASH#</b></div>
    <div><b>Altitudes are #WEATHER_AMGL#</b></div>
    <div><b>File:</b> #WEATHER_FILENAME#</div>
    <div><b>Pressure:</b> #WEATHER_PRESSURE#</div>
    <div><b>Temperature:</b> #WEATHER_TEMPERATURE#</div>
    `;
    }

    wind_header_template() {
        return `
    <h4>Winds</h4>
    <table>
        <tr><th>Speed<br/>#SPEED_UNITS#</th><th>Altitude<br/>#ALTITUDE_UNITS#</th><th>Direction</th></tr>
    `;
    }

    wind_layer_template() {
        return `
        <tr #CLASSNAME# onclick="b21_task_planner.set_windlayer_index(#WINDLAYER_INDEX#)"><td>#WIND_SPEED#</td><td>#WIND_ALTITUDE#</td><td>#WIND_DIRECTION#°</td></tr>
    `;
    }

    wind_footer_template() {
        return `
    </table>
    `;
    }

    cloud_header_template() {
        return `
    <h4>Cloud layers</h4>
    <table>
        <tr><th>Altitude<br/>#ALTITUDE_UNITS#</th><th>Density</th><th>Cover</th><th>Scatter</th></tr>
    `;
    }

    cloud_layer_template() {
        return `
        <tr><td>#ALTITUDE_RANGE#</td><td>#DENSITY#</td><td>#COVER#</td><td>#SCATTER#</td></tr>
    `;
    }

    cloud_footer_template() {
        return `
    </table>
    `;
    }

} // end B21_Weather class
"use strict"
// ******************************************************************************
// ***********   WP class (waypoint)       **************************************
// ******************************************************************************

class B21_WP {

    // Waypoint may be created by a click on the map:
    //          new WP(planner, index, position)
    // or as a result of loading an MSFS flightplan:
    //          new WP(planner,index,null,WP_dom_object)
    //

    // get_icon(WP)
    // get_name()
    // get_icao()
    // get_runway_id()
    // get_radius()
    // get_leg_bearing()

    constructor(planner) {
        const wp = this;
        wp.planner = planner; // reference to B21TaskPlanner instance
        wp.task = planner.task;

        wp.DEFAULT_RADIUS_M = 500;
        wp.DEFAULT_START_RADIUS_M = 2500;
        wp.DEFAULT_FINISH_RADIUS_M = 2000;
        wp.DEFAULT_AAT_RADIUS_M = 4000;

        wp.name = null;
        wp.position = null;
        wp.aat_position_min = null; // position on radius that gives minimum task distance
        wp.aat_position_max = null; // position on radius that gives maximum task distance
        wp.encoded_icao = null; // string to hold an 'encoded' ICAO for user waypoints (contains elevation, limits)
        wp.icao = null;
        wp.data_icao = null; // original ICAO code from source data (may not use in output PLN if not first/last waypoint)
        wp.runway_str = null; // Selected runway "RUNWAY_ID/RUNWAY_LENGTH_FEET"
        wp.runways = null; // List of available runways
        wp.alt_m = 0;
        wp.alt_m_updated = false; // true is elevation has been updated
        wp.radius_m = null;     // default wp limit radius of 1000m (still 500m default if NO limit specified)
        wp.max_alt_m = null;
        wp.min_alt_m = null;
        // turnpoint sector (Leaflet circle)
        wp.sector = null;
        wp.is_aat = false; // is this WP the center of an AREA ?

        // Values from task
        // Note each 'leg_' value is TO this waypoint
        wp.index = null;
        wp.task_line = null; // holds [L.polyline, L.polyline] used in task.js to draw task on map
        wp.aat_line = null; // holds [L.polyline, L.polyline] used in task.js to draw AAT lines for tracklog on map
        wp.leg_bearing_deg = null; // Bearing from previous WP to this WP
        wp.leg_distance_m = null; // Distance (meters) from previous WP to this WP
        wp.marker = null;
    }

    new_point(index, position) {
        const wp = this;
        //console.log("new WP", index, position, name);

        wp.position = position;
        wp.aat_position_min = position; // position on radius that gives minimum task distance
        wp.aat_position_max = position; // position on radius that gives maximum task distance
        wp.is_aat = false; // is this WP the center of an AREA ?

        // Values from task
        // Note each 'leg_' value is TO this waypoint
        wp.index = index;
        if (index == 0) {   // Remove radius on initial airport wp
            wp.radius_m = null;
        }
        wp.marker = wp.create_marker();
    }

    copy(index) {
        const wp = this;
        console.log("copying wp",wp.index,"into new",index);
        let new_wp = new B21_WP(wp.planner);
        new_wp.index = index;
        new_wp.position = wp.position;
        new_wp.name = wp.name;
        new_wp.alt_m = wp.alt_m;
        new_wp.icao = wp.icao;
        new_wp.runways = wp.runways;
        new_wp.marker = new_wp.create_marker();
        return new_wp;
    }

    // isAAT() returns true if this is an AAT waypoint, or can be SET by passing true/false
    isAAT(set_value) {
        const wp = this;
        if (set_value != null) {
            wp.is_aat = set_value;
        }
        return wp.is_aat;
    }

    create_marker() {
        const wp = this;

        let marker = L.marker(wp.position, {
            icon: wp.get_icon(wp),
            draggable: true,
            autoPan: true,
            bubblingMouseEvents: false
        });
        marker.on("dragstart", function(e) {
            wp.planner.map.closePopup();
        });
        marker.on("drag", function(e) {
            let marker = e.target;
            wp.position = marker.getLatLng();
            wp.task.update_waypoints();
            wp.task.draw();
            wp.task.display_task_info();
        });
        marker.on("dragend", function(e) {
            wp.task.set_current_wp(wp.index);
            console.log("WP dragend");
            let marker = e.target;
            wp.planner.request_alt_m(wp, wp.position, wp.request_alt_m_ok, wp.request_alt_m_fail);
        });

        // POPUP
        //console.log("creating WP popup",wp.get_name());
        var popup = L.popup({
                offset: [20, 10],
                className: "wp_popup",
                autoClose: false,
                bubblingMouseEvents: false
            })
            .setContent("no WP content yet");

        marker.bindPopup(popup);

        marker.on('popupopen', () => {
            //console.log(`wp.marker event on popupopen ${wp.get_name()}`);
            wp.task.set_current_wp(wp.index);
        });

        marker.addTo(wp.planner.map);

        return marker;
    }

    set_edit_mode(wp) {
        wp.marker.dragging.enable();
    }

    reset_edit_mode(wp) {
        //console.log("WP.reset_edit_mode "+wp.name);
        wp.marker.dragging.disable();
    }

    wp_click(wp, e) {
        //console.log("wp_click");
        wp.task.set_current_wp(wp.index);
    }

    // The ap "icon" is the permanently displayed div containing the name
    get_icon(wp) {
        //let icon_str = '<div onclick="b21_task_planner.task.set_current_wp(0);">';
        //let icon_str = ((1 + wp.index) + "." + wp.get_name()).replaceAll(" ", "&nbsp;");
        let icon_str = (wp.get_name()).replaceAll(" ", "&nbsp;");
        //icon_str += "</div>";
        let class_name = (wp.task.index == wp.index) ? "wp_icon_html_current" : "wp_icon_html";
        let icon_html = '<div class="' + class_name + '">' + icon_str + "</div>";
        let wp_icon = L.divIcon({
            className: "wp_icon",
            iconSize: [5, 5],
            iconAnchor: [0, 0],
            html: icon_html
        });

        return wp_icon;
    }

    // remove the task line drawn to this waypoint
    remove_line(wp) {
        if (wp.task_line != null) {
            for (let i = 0; i < wp.task_line.length; i++) {
                wp.task_line[i].remove(wp.planner.map);
            }
            wp.task_line = null;
        }
    }

    // Add a straight line between p1 and p2
    // This line is multiple polylines that all should be drawn (allowing an alternate color dash if needed).
    add_aat_line(wp, p1, p2, alt=false) {
        let task = wp.task;

        let latlngs = [p1, p2];
        let color1 = 'yellow';
        let color2 = 'brown';
        let line1_options = {
            color: alt ? color2 : color1
        };
        if (color2 != null && color2 != "" && color2 != "none") {
            line1_options["dashArray"] = '24 12';
            line1_options["lineCap"] = 'butt';
        }
        wp.aat_line = [L.polyline(latlngs, line1_options)];

        if (color2 != null && color2 != "" && color2 != "none") {
            wp.aat_line.push(L.polyline(latlngs, {
                color: alt ? color1 : color2,
                dashArray: '12 24',
                dashOffset: '12',
                lineCap: 'butt'
            }));
        }
        for (let i = 0; i < wp.aat_line.length; i++) {
            wp.aat_line[i].addTo(wp.task.planner.map);
        }
    }

    // remove the AAT line drawn to this waypoint
    remove_aat_line(wp) {
        if (wp.aat_line != null) {
            for (let i = 0; i < wp.aat_line.length; i++) {
                wp.aat_line[i].remove(wp.planner.map);
            }
            wp.aat_line = null;
        }
    }

    request_alt_m_ok(wp, position, alt_m) {
        console.log("wp.request_alt_m_ok elevation(m):", position, alt_m);
        wp.alt_m = alt_m;
        wp.alt_m_updated = true;
        // If this is the current waypoint, popup the wp menu
        if (wp.index == wp.task.index) {
            wp.display_menu(wp);
        }
        wp.task.display_task_info();
    }

    request_alt_m_fail(wp, position, error_str, error) {
        console.log("WP alt_m fetch error", error_str, error);
    }

    is_task_start() {
        const wp = this;
        return wp.index == wp.task.start_index;
    }

    is_task_finish() {
        const wp = this;
        return wp.index == wp.task.finish_index;
    }

    get_name() {
        const wp = this;
        if (wp.name == null) {
            if (wp.index == 0) {
                return "Origin";
            } else {
                return "WP " + (wp.index-1);
            }
        }
        return wp.name;
    }

    set_name(name) {
        const wp = this;
        wp.name = name;
        wp.update_icon(wp);
    }

    get_icao() {
        const wp = this;
        return wp.icao == null ? "" : wp.icao;
    }

    set_icao(icao) {
        const wp = this;
        console.log("wp.set_icao", icao);
        if (icao == "") {
            console.log("setting icao to null");
            wp.icao = null;
        } else {
            console.log("setting icao to '" + icao + "'");
            wp.icao = icao;
            if (wp.name == null) {
                wp.name = wp.icao;
                document.getElementById("wp_name").value = wp.icao;
            }
        }
        wp.update_icon(wp);
    }

    get_runway_id() {
        const wp = this;
        return wp.runway_str == null ? "" : wp.runway_str.split("/")[0];
    }

    get_runway_display_str(runway) {
        const wp = this;
        if (runway == null) return "";
        let rw_parts = runway.split("/");
        let len_str = "";
        if (rw_parts.length > 1) {
            len_str = " ("+rw_parts[1]+" ft)";
        }
        return rw_parts[0]+len_str;
    }

    // Set wp.runway_str = RUNWAY_ID/RUNWAY_LENGTH_FEET by lookup from wp.runways using id from input string
    set_runway_str(runway_str) {
        const wp = this;
        console.log(`WP ${wp.name} set_runway_str('${runway_str}') using `,wp.runways);

        if (runway_str == "") {
            wp.runway_str = null;
        } else {
            if (wp.runways == null) {
                console.warn(`WP ${wp.name} set_runway_str(${runway_str}) using given string as wp.runways == null`);
                wp.runway_str = runway_str;
            } else {
                let runway_id = runway_str.split("/")[0];
                console.log(`WP ${wp.name} set_runway_str(${runway_str}) runways lookup with ${runway_id}`);
                for (let i=0; i<wp.runways.length; i++) {
                    if (wp.runways[i] == runway_id || wp.runways[i].startsWith(runway_id+"/")) {
                        wp.runway_str = wp.runways[i];
                        break;
                    }
                }
            }
        }
        let popup_runway_el = document.getElementById("wp_runway");
        if (popup_runway_el != null) {
            popup_runway_el.value = wp.get_runway_id();
        }
    }

    set_radius(radius_m) {
        const wp = this;
        wp.radius_m = radius_m;
    }

    // return Wp radius in meters
    get_radius() {
        const wp = this;
        if (wp.radius_m != null) return wp.radius_m;
        if (wp.is_task_start()) return wp.DEFAULT_START_RADIUS_M;
        if (wp.is_task_finish()) return wp.DEFAULT_FINISH_RADIUS_M;
        return wp.DEFAULT_RADIUS_M;
    }

    get_leg_bearing() {
        const wp = this;
        if (wp.leg_bearing_deg == null) {
            return "";
        }
        return wp.leg_bearing_deg.toFixed(0);
    }

    update(prev_wp = null) {
        const wp = this;

        wp.aat_position_min = wp.position; // position on radius that gives minimum task distance
        wp.aat_position_max = wp.position; // position on radius that gives maximum task distance

        //console.log("update",wp.index);
        if (prev_wp != null) {
            wp.update_leg_distance(prev_wp);
            wp.update_leg_bearing(prev_wp);
        }
    }

    // Add .leg_distance_m property for distance (meters) from wp to this waypoint
    // Called when task is loaded
    update_leg_distance(prev_wp) {
        const wp = this;
        wp.leg_distance_m = Geo.get_distance_m(wp.position, prev_wp.position);
        //console.log("update_leg_distance", wp.index, wp.leg_distance_m);
    }

    // Add .bearing property for INBOUND bearing FROM wp TO this waypoint
    // Called when task is loaded
    update_leg_bearing(prev_wp) {
        const wp = this;
        wp.leg_bearing_deg = Geo.get_bearing_deg(prev_wp.position, wp.position);
    }

    update_icon(wp) {
        //console.log("update_icon for wp",wp.index);
        let icon = wp.get_icon(wp);
        wp.marker.setIcon(icon);
    }

    display_menu(wp) {
        //console.log(`wp.display_menu() ${wp.get_name()}`);
        // NAME
        let form_str = 'Name: <input id="wp_name" class="wp_name" onchange="b21_task_planner.change_wp_name(this.value)" value="' + wp.get_name() +
            '"</input>';

        // ICAO
        form_str += '<br/>ICAO: <input class="wp_icao" onchange="b21_task_planner.change_wp_icao(this.value)" value="' + wp.get_icao() +
            '"</input> ';

        // RUNWAY
        form_str +=
            ' R/w: <input id="wp_runway" class="wp_runway" onchange="b21_task_planner.change_wp_runway(this.value)" value="' +
            wp.get_runway_id() + '"</input> ';

        // RUNWAYS LIST
        if (wp.runways != null) {
            form_str += '<select class="wp_runway_select" onclick="b21_task_planner.select_wp_runway(this.value)" value="">';
            for (let i = 0; i < wp.runways.length; i++) {
                let rw_display_str = wp.get_runway_display_str(wp.runways[i]);
                form_str += `<option value="${wp.runways[i]}">${rw_display_str}</option>`;
            }
            form_str += '<option value=""></option>'; // Add 'blank' option for no runway selected
            form_str += '</select>';
        }

        // ELEVATION
        let alt_str = wp.alt_m.toFixed(0);
        let alt_units_str = "m.";
        if (wp.planner.settings.altitude_units == "feet") {
            alt_str = (wp.alt_m * wp.planner.M_TO_FEET).toFixed(0);
            alt_units_str = "feet.";
        }

        form_str += '<br/>Elevation: <input class="wp_alt" onchange="b21_task_planner.change_wp_alt(this.value)" value="' +
            alt_str + '"</input> ' + alt_units_str;

        // settings.soaring_task == true . It's a placeholder in case we want planner for non-soaring.
        if (wp.planner.settings.soaring_task == 1 && wp.index != 0) {
            // AAT checkbox
            form_str += '<div class="wp_aat">AAT: <input onclick="b21_task_planner.click_wp_aat(event)" type="checkbox"' + (wp.isAAT() ? " checked" :
                "") + '/></div> ';

            // START checkbox
            let start = wp.index == wp.task.start_index;
            form_str += '<br/><div class="wp_start">Start: <input onclick="b21_task_planner.click_wp_start(event)" type="checkbox"' + (start ? " checked" :
                "") + '/></div> ';

            // FINISH checkbox
            let finish = wp.index == wp.task.finish_index;
            form_str += '<div class="wp_finish">Finish: <input  onclick="b21_task_planner.click_wp_finish(event)" type="checkbox"' + (finish ? " checked" :
                "") + '/></div>';

            // RADIUS
            let radius_units_str = "m";
            if (wp.planner.settings.wp_radius_units == "feet") {
                radius_units_str = "feet";
            }
            let radius_str = "";
            if (wp.radius_m != null) {
                if (wp.planner.settings.wp_radius_units == "m") {
                    radius_str = wp.radius_m.toFixed(0);
                } else {
                    radius_str = (wp.radius_m * wp.planner.M_TO_FEET).toFixed(0);
                }
            }
            form_str += ' Radius: <input class="wp_radius" onchange="b21_task_planner.change_wp_radius(this.value)" value="' +
                radius_str + '"</input> ' + radius_units_str;

            // MAX ALT LIMIT
            let max_alt_str = "";
            if (wp.max_alt_m != null) {
                if (wp.planner.settings.altitude_units == "m") {
                    max_alt_str = wp.max_alt_m.toFixed(0);
                } else {
                    max_alt_str = (wp.max_alt_m * wp.planner.M_TO_FEET).toFixed(0);
                }
            }
            form_str += '<br/>Max Alt: <input class="wp_alt" onchange="b21_task_planner.change_wp_max_alt(this.value)" value="' +
                max_alt_str + '"</input> ';

            // MIN ALT LIMIT
            let min_alt_str = "";
            if (wp.min_alt_m != null) {
                if (wp.planner.settings.altitude_units == "m") {
                    min_alt_str = wp.min_alt_m.toFixed(0);
                } else {
                    min_alt_str = (wp.min_alt_m * wp.planner.M_TO_FEET).toFixed(0);
                }
            }
            form_str += ' Min Alt: <input class="wp_alt" onchange="b21_task_planner.change_wp_min_alt(this.value)" value="' +
                min_alt_str + '"</input> ' + alt_units_str;
        }

        // MENU items
        form_str += '<div class="wp_menu">';
        form_str += wp.planner.menuitem("Append to task", "append_wp_to_task");
        form_str += wp.planner.menuitem("Update elevation", "update_wp_elevation");
        form_str += wp.planner.menuitem('<img src="https://xp-soaring.github.io/tasks/b21_task_planner/images/delete.png"/>', "remove_wp_from_task");
        form_str += '</div>';

        // POPUP
        wp.marker.getPopup().setContent(form_str);
        //console.log("opening popup");
        wp.marker.openPopup();
    }

    // ********************************************
    // Tracklog calculations
    // Points are { lat, lng, alt_m }
    // ********************************************


    // is_start(p1, p2, leg_bearing) returns true if p1->p2 crosses the start line
    is_start(p1, p2, leg_bearing_deg) {
        const wp = this;
        //console.log("WP.is_start()");

        // Check p1 is in start sector
        if (wp.max_alt_m != null && p1.alt_m > wp.max_alt_m) {
            //console.log("WP.is_start() false p1 max_alt_m="+wp.max_alt_m+" vs "+p1.alt_m);
            return false;
        }
        if (wp.min_alt_m != null && p1.alt_m < wp.min_alt_m) {
            //console.log("WP.is_start() false p1 min_alt_m="+wp.min_alt_m+" vs "+p1.alt_m);
            return false;
        }

        let radius_m = wp.radius_m == null ? wp.DEFAULT_START_RADIUS_M : wp.radius_m;
        let p1_distance_m = Geo.get_distance_m(p1, wp.position);
        if (p1_distance_m > radius_m) {
            //console.log("WP.is_start() false radius_m="+radius_m.toFixed(0)+" vs "+distance_m.toFixed(0));
            return false;
        }
        let wp_bearing_deg = Geo.get_bearing_deg(p1, wp.position);
        let in_sector = Geo.in_sector(leg_bearing_deg, wp_bearing_deg, 180); // Check p1 within start sector angles
        if (!in_sector) {
            //console.log("WP.is_start() false p1 at "+wp_bearing_deg.toFixed(0)+" deg not in start sector");
            return false;
        }
        // OK so p1 is in the start sector, now we need to see if p2 is outside i.e. distance>radius or crosses the start line
        // We do this by seeing if p2 is in the 180-degree sector OPPOSITE the start sector
        // First check radius:
        //if (Geo.get_distance_m(p2, wp.position) > radius_m) {
        //    return true;
        //}
        // Inside radius, but have we crossed start line?
        let reverse_bearing_deg = (leg_bearing_deg + 180) % 360;
        wp_bearing_deg = Geo.get_bearing_deg(p2, wp.position);
        let over_start_line = Geo.in_sector(reverse_bearing_deg, wp_bearing_deg, 180);
        if (over_start_line) {
            //console.log("WP.is_start true at " + wp_bearing_deg.toFixed(0));
        } else {
            //console.log("WP.is_start false at "+wp_bearing_deg.toFixed(0));
        }
        return over_start_line;
    }

    is_finish(p1, p2) {
        const wp = this;
        //console.log("wp is_finish");

        return wp.in_finish_sector(p2) && !wp.in_finish_sector(p1);
        /*
        // check p1 is before finish sector
        let wp_bearing_deg = Geo.get_bearing_deg(p1, wp.position);
        let before_finish_line = Geo.in_sector(wp.leg_bearing_deg, wp_bearing_deg, 180);
        if (before_finish_line) {
            //console.log("WP.is_finish p1 before_finish_line=true at "+wp_bearing_deg.toFixed(0));
        } else {
            //console.log("WP.is_finish p1 before_finish_line=false at "+wp_bearing_deg.toFixed(0));
            return false;
        }
        // p1 is before finish

        // Check p2 is in finish sector
        if (wp.max_alt_m != null && p2.alt_m > wp.max_alt_m) {
            //console.log("WP.is_finish() false p2 max_alt_m="+wp.max_alt_m+" vs "+p2.alt_m);
            return false;
        }
        if (wp.min_alt_m != null && p2.alt_m < wp.min_alt_m) {
            //console.log("WP.is_finish() false p2 min_alt_m="+wp.min_alt_m+" vs "+p2.alt_m);
            return false;
        }

        let radius_m = wp.radius_m == null ? wp.DEFAULT_FINISH_RADIUS_M : wp.radius_m;
        let distance_m = Geo.get_distance_m(p2, wp.position);
        if (distance_m > radius_m) {
            //console.log("WP.is_finish() false p2 radius_m="+radius_m.toFixed(0)+" vs "+distance_m.toFixed(0));
            return false;
        }

        let reverse_bearing_deg = (wp.leg_bearing_deg + 180) % 360;
        wp_bearing_deg = Geo.get_bearing_deg(p2, wp.position);
        let p2_in_sector = Geo.in_sector(reverse_bearing_deg, wp_bearing_deg, 180); // Check p2 within finish sector angles
        if (!p2_in_sector) {
            //console.log("WP.is_finish() false p2 at "+wp_bearing_deg.toFixed(0)+" deg not in finish sector");
            return false;
        }

        //console.log("WP.is_finish() true");

        return true;
        */
    }

    // Return true if p1 -> p2 ENTERS this wp radius
    is_wp(p1, p2) {
        const wp = this;
        if (!wp.in_sector(p1) && wp.in_sector(p2)) {
            //console.log("wp is_wp() true");
            return true;
        }
        //console.log("wp is_wp() false");
        return false;
    }

    // Return true if p1 -> p2 EXITS this wp radius
    is_wp_exit(p1, p2) {
        const wp = this;
        if (wp.in_sector(p1) && !wp.in_sector(p2)) {
            //console.log("wp is_wp() true");
            return true;
        }
        //console.log("wp is_wp() false");
        return false;
    }

    in_finish_sector(p) {
        const wp = this;
        let wp_bearing_deg = Geo.get_bearing_deg(p, wp.position);
        let after_finish_line = Geo.in_sector((wp.leg_bearing_deg + 180) % 360, wp_bearing_deg, 180);
        return after_finish_line && wp.in_sector(p);
    }

    in_sector(p) {
        const wp = this;
        //console.log("in_wp_sector");
        if (wp.max_alt_m != null && p.alt_m > wp.max_alt_m) {
            //console.log("in_wp_sector false max_alt_m="+wp.max_alt_m+" vs "+p.alt_m);
            return false;
        }
        if (wp.min_alt_m != null && p.alt_m < wp.min_alt_m) {
            //console.log("in_wp_sector false min_alt_m="+wp.min_alt_m+" vs "+p.alt_m);
            return false;
        }
        let radius_m = wp.radius_m == null ? wp.DEFAULT_RADIUS_M : wp.radius_m;
        let distance_m = Geo.get_distance_m(p, wp.position);
        let in_sector = distance_m < radius_m;
        //console.log("in_wp_sector "+in_sector+" radius_m="+radius_m+" vs "+distance_m.toFixed(1));
        return in_sector;
    }

    // ********************************************
    // class toString
    // ********************************************

    toString() {
        const wp = this;
        return wp.name;
    }
} // end WP class
// ******************************************************************************
// ***********   B21_XCsoar_TSK class          **********************************
// ******************************************************************************

// Constructs an xcsoar .TSK file for output

// The general technique is to use the string TEMPLATES given at the end of this source for the
// XCSoar .tsk file header, each waypoint, and footer, populating those with the appropriate values from the
// B21 task object given to this constructor.

class B21_XCsoar_TSK {

    constructor(task) {

        this.task = task;
    }

    // Load the waypoints from the .TSK file string into this.task
    load_tsk_str(tsk_str) {
        console.log("load_tsk_str", tsk_str);
        const parser = new DOMParser();
        const dom = parser.parseFromString(tsk_str, "application/xml");
        let task_el = dom.getElementsByTagName("Task")[0];

        if (task_el.hasAttribute('name')) {
            this.task.name = task_el.getAttribute('name');
        }
        console.log("load_task_str name ='"+this.task.name+"'");

        if (task_el.hasAttribute('finish_min_height_ref')) {
            this.finish_min_height_ref = task_el.getAttribute('finish_min_height_ref');
            console.log('finish_min_height_ref', this.finish_min_height_ref);
        }

        if (task_el.hasAttribute('finish_min_height')) {
            this.finish_min_height = parseFloat(task_el.getAttribute('finish_min_height'));
            console.log('finish_min_height', this.finish_min_height);
        }

        if (task_el.hasAttribute('start_max_height_ref')) {
            this.start_max_height_ref = task_el.getAttribute('start_max_height_ref');
            console.log('start_max_height_ref', this.start_max_height_ref);
        }

        if (task_el.hasAttribute('start_max_height')) {
            this.start_max_height = parseFloat(task_el.getAttribute('start_max_height'));
            console.log('start_max_height', this.start_max_height);
        }

        // ***************************
        // Waypoints
        let point_els = dom.getElementsByTagName("Point"); //XMLNodeList
        for (let i = 0; i < point_els.length; i++) {
            this.add_tsk_wp(point_els[i]);
        }
    }

    // Add a WP to this.task from a tsk waypoint entry
    add_tsk_wp(point_el) {
        //this.index = this.waypoints.length;
        let wp_index = this.task.index == null ? 0 : this.task.index + 1;
        console.log(">>>>>>>b21_xcsoar_tsk.add_tsk_wp adding tsk wp with index", wp_index);
        let wp = new B21_WP(this.task.planner);
        this.update_wp_tsk(wp, wp_index, point_el);

        // Update task current index
        this.task.index = wp_index;
        //this.waypoints.push(wp);
        //INSERT this wp into waypoints at index
        this.task.waypoints.splice(wp_index, 0, wp);
        if (wp_index > 0) {
            this.task.add_line(this.task.waypoints[wp_index - 1], wp);
        }
        this.task.decode_wp_name(wp);
    }

    // Given an XCSoar waypoint XML element, update a B21 Waypoint with that content.
    update_wp_tsk(wp, index, point_el) {
        let point_type;
        if (point_el.hasAttribute('type')) {
            point_type = point_el.getAttribute("type");;
            console.log("New Point from TSK type:", point_type); // Start | Turn  | Finish
        }

        let wp_el = point_el.getElementsByTagName("Waypoint")[0];

        let name;
        if (wp_el.hasAttribute('name')) {
            name = wp_el.getAttribute("name");;
            console.log("New WP from TSK dom:", name);
        }

        let alt_m;
        if (wp_el.hasAttribute('altitude')) {
            alt_m = parseFloat(wp_el.getAttribute('altitude'));
            console.log('wp.alt_m', alt_m);
        }

        // Get lat/lng
        let loc_el = wp_el.getElementsByTagName("Location")[0];
        let lat = 0;
        let lng = 0;
        if (loc_el.hasAttribute('latitude')) {
            lat = parseFloat(loc_el.getAttribute('latitude'));
        } else {
            console.log("TSK file load no Location LATITUDE", point_el)
        }
        if (loc_el.hasAttribute('longitude')) {
            lng = parseFloat(loc_el.getAttribute('longitude'));
        } else {
            console.log("TSK file load no Location LONGITUDE", point_el)
        }

        // Set wp.position
        wp.new_point(index, new L.latLng(lat, lng));

        // Set wp.name
        wp.name = name;

        // Set wp.alt_m
        wp.alt_m = alt_m;

        // Set task.start_index and wp.max_alt_m
        if (point_type=="Start") {
            this.task.start_index = index;
            if (this.start_max_height != null) {
                if (this.start_max_height_ref=='AGL') {
                    wp.max_alt_m = this.start_max_height + alt_m;
                } else {
                    wp.max_alt_m = this.start_max_height;
                }
            }
        // Set task.finish_index and wp.min_alt_m
        } else if (point_type=="Finish") {
            this.task.finish_index = index;
            if (this.finish_min_height != null) {
                if (this.finish_min_height_ref=='AGL') {
                    wp.min_alt_m = this.start_max_height + alt_m;
                } else {
                    wp.min_alt_m = this.finish_min_height;
                }
            }
        }

        let zone_el = point_el.getElementsByTagName("ObservationZone")[0];

        // Set wp.radius_m for a Cylinder
        if (zone_el.hasAttribute('radius')) {
            wp.radius_m = parseFloat(zone_el.getAttribute('radius'));
            console.log('radius', wp.radius_m);
        }

        // Set wp.radius_m for a Line
        if (zone_el.hasAttribute('length')) {
            wp.radius_m = parseFloat(zone_el.getAttribute('length'));
            console.log('length', wp.radius_m);
        }

    }

    check() {
        if (this.task==null) {
            throw "Cannot create TSK file with no task";
        }

        if (this.task.waypoints.length<2) {
            throw "Cannot create TSK file with less than 2 waypoints";
        }
    }

    clean(str) {
        return str.replaceAll('"',"");
    }

    // Return the text string for a .TSK file from waypoints in this.task
    get_text() {
        this.check();

        // Default values for finish min alt, and start max alt. Will update if set in Start/Finish waypoints
        this.finish_min_m = 0;
        this.start_max_m = 0;

        let header_text = this.get_header_text();
        let wp_text = "";
        // Iterate through the waypoints in this.tasks
        // convert each one to the appropriate XCSoar waypoint stanza
        for (let i=0; i<this.task.waypoints.length; i++) {
            // If a task START waypoint is set, and the current waypoint is BEFORE this start, then skip over this waypoint
            if (this.task.start_index != null && i < this.task.start_index) {
                continue;
            }
            wp_text += this.get_wp_text(i);
        }
        let footer_text = this.get_footer_text();
        // Now fix up start/finish height limits picked up while iterating waypoints
        header_text = header_text.replace("#FINISH_MIN#",this.finish_min_m.toFixed(3));
        header_text = header_text.replace("#START_MAX#",this.start_max_m.toFixed(3));
        let text = header_text + wp_text + footer_text;
        return text;
    }

    get_title() {
        if (this.task.name != null) {
            return this.task.name;
        }
        let first_wp = this.task.waypoints[0];
        let last_wp = this.task.waypoints[this.task.waypoints.length-1];
        let from = first_wp.icao != null ? first_wp.icao : first_wp.get_name();
        let to = last_wp.icao != null ? last_wp.icao : last_wp.get_name();

        return from + " to " + to;
    }

    // Return the XML string for the 'header' part of the tsk file
    get_header_text() {
        let header_text = this.get_header_template();         // #FINISH_MIN# #START_MAX# #NAME#
        let title = this.clean(this.get_title());
        header_text = header_text.replace("#NAME#", title);

        return header_text;
    }

    // Return the XML string for each waypoint
    get_wp_text(index) {
        let wp = this.task.waypoints[index];
        console.log("B21_XCsoar_TSK get_wp_text", wp);
        //let encoded_name = this.clean(this.task.get_encoded_name(wp));
        let wp_text = "";
        let wp_name = wp.get_name();
        let wp_template;
        if (wp.is_task_start()) {
            console.log("B21_XCsoar_TSK start is ",wp_name);
            // Fixup max start altitude if in this WP
            if (wp.max_alt_m != null) {
                this.start_max_m = wp.max_alt_m;
            }
            wp_template = this.get_point_start_template(); // #ALTITUDE# #COMMENT# #ID# #NAME# #LATITUDE# #LONGITUDE# #LENGTH#
            wp_text = wp_template.replace("#LENGTH#",(2 * wp.get_radius()).toFixed(0));
        } else if (wp.is_task_finish()) {
            console.log("B21_XCsoar_TSK finish is ",wp_name);
            // Fixup min finish altitude if in this WP
            if (wp.min_alt_m != null) {
                this.finish_min_m = wp.min_alt_m;
            }
            wp_template = this.get_point_finish_template(); // #ALTITUDE# #COMMENT# #ID# #NAME# #LATITUDE# #LONGITUDE# #LENGTH#
            wp_text = wp_template.replace("#LENGTH#",( 2 * wp.get_radius()).toFixed(0));
        } else {
            wp_template = this.get_point_turn_template(); // #ALTITUDE# #COMMENT# #ID# #NAME# #LATITUDE# #LONGITUDE# #RADIUS#
            wp_text = wp_template.replace("#RADIUS#",wp.get_radius().toFixed(0));
        }
        // #ALTITUDE# #COMMENT# #ID# #NAME# #LATITUDE# #LONGITUDE#
        wp_text = wp_text.replace("#ALTITUDE#", wp.alt_m.toFixed(3) );
        wp_text = wp_text.replace("#COMMENT#", "");
        wp_text = wp_text.replace("#ID#", index.toFixed(0));
        wp_text = wp_text.replace("#NAME#", wp_name);
        wp_text = wp_text.replace("#LATITUDE#", wp.position.lat.toFixed(7));
        wp_text = wp_text.replace("#LONGITUDE#", wp.position.lng.toFixed(7));
        console.log("B21_XCsoar_TSK wp_text is ",wp_text);
        return wp_text;
    }

    // Return XML string for the end of the tsk file
    get_footer_text() {
        let footer_text = this.get_footer_template();
        return footer_text;
    }

    get_header_template() {
        // #FINISH_MIN# #START_MAX# #NAME#
        return `<Task fai_finish="0" finish_min_height_ref="MSL" finish_min_height="#FINISH_MIN#"
            start_max_height_ref="MSL" start_max_height="#START_MAX#" start_max_speed="0" start_requires_arm="0"
            aat_min_time="0" name="#NAME#" type="RT">
`;
    }

    get_point_start_template() {
        // #ALTITUDE# #COMMENT# #ID# #NAME# #LATITUDE# #LONGITUDE# #LENGTH#
        return `
    <Point type="Start">
        <Waypoint altitude="#ALTITUDE#" comment="#COMMENT#" id="#ID#" name="#NAME#">
            <Location latitude="#LATITUDE#" longitude="#LONGITUDE#"/>
        </Waypoint>
        <ObservationZone length="#LENGTH#" type="Line"/>
    </Point>
`;
    }

    get_point_turn_template() {
        // #ALTITUDE# #COMMENT# #ID# #NAME# #LATITUDE# #LONGITUDE# #RADIUS#
        return `
    <Point type="Turn">
        <Waypoint altitude="#ALTITUDE#" comment="#COMMENT#" id="#ID#" name="#NAME#">
            <Location latitude="#LATITUDE#" longitude="#LONGITUDE#"/>
        </Waypoint>
        <ObservationZone radius="#RADIUS#" type="Cylinder"/>
    </Point>
`;
    }

    get_point_finish_template() {
        // #ALTITUDE# #COMMENT# #ID# #NAME# #LATITUDE# #LONGITUDE# #LENGTH#
        return `
    <Point type="Finish">
        <Waypoint altitude="#ALTITUDE#" comment="#COMMENT#" id="#ID#" name="#NAME#">
            <Location latitude="#LATITUDE#" longitude="#LONGITUDE#"/>
        </Waypoint>
        <ObservationZone length="#LENGTH#" type="Line"/>
    </Point>
`;
    }

    get_footer_template() {
        return `
    </Task>
`;
    }
} // end B21_XCsoar_TSK class
"use strict"

// Instantiated in planner with planner.nb21 = new NB21Connect(planner, json=null)

// NB21Connect interface:
//      setup_connection(json) - json true|false
//      close_connection()
//      request_pln(nb21)

// uses interface to planner:
//      planner.local_player_connected()
//      planner.local_player_disconnected()
//      IGC:
//      planner.handle_nb21_header(nb21.planner,header_data)
//      planner.handle_nb21_message(nb21.planner, msg)
//      JSON:
//      planner.handle_nb21_message_json(nb21.planner, msg)
//      planner.handle_nb21_pln(nb21.planner, pln_xml)

/* HEADERDATA JSON
{
    "ver": "v2",
    "msg": "header",
    "logger_title": "NB21 Logger 1.0.5",
    "flight_date_utc": "291024",
    "pilot_name": "Ian FL",
    "aircraft_type": "JS3-18",
    "glider_id": "B21",
    "competition_class": "18m flapped",
    "pln_ref_id": 2,
    "task": {
        "name": "",
        "title": "SSC FR Nice AAT SW",
        "description": "SSC FR Nice AAT SW",
        "departure_id": "LFMC",
        "departure_runway": "27",
        "destination_id": "LFMC",
        "waypoints": [
            {
                "name": "Le Cannet Army",
                "icao": "LFMC",
                "lat": 43.38466944,
                "lon": 6.38691944,
                "alt_feet": 257
            },
            {
                "name": "*Start+266|5000x5000;AAT01:45;",
                "lat": 43.355475,
                "lon": 6.41953611,
                "alt_feet": -266
            },
            {
                "name": "WP 1+1325x80000;AAT;",
                "lat": 43.92658333,
                "lon": 7.63413889,
                "alt_feet": 1325
            },
            {
                "name": "WP 2+3789x60000;AAT;",
                "lat": 44.19205,
                "lon": 6.37619167,
                "alt_feet": 3789
            },
            {
                "name": "*Finish+259x4000",
                "lat": 43.38829167,
                "lon": 6.38092778,
                "alt_feet": 259
            },
            {
                "name": "Le Cannet Army",
                "icao": "LFMC",
                "lat": 43.38466944,
                "lon": 6.38691944,
                "alt_feet": 257
            }
        ]
    },
    "chksum_ac": "753B807E002326612ACFA3A3",
    "chksum_fm": "F906E5A4361827146F91950E"
}

REPEATDATA JSON
{
    "ver": "v2",
    "msg": "repeat",
    "utc": "094001",
    "local_time": "101539",
    "local_date": "20241029",
    "lat": 43.38474508,
    "lon": 6.38790018,
    "alt_m": 78.8,
    "agl_m": 0.6,
    "tas_kph": 0,
    "eng": 0,
    "flap": 2,
    "on_gnd": 1,
    "wind_y_ms": -0.04,
    "wind_kph": 22.6,
    "wind_deg": 45,
    "abs_time_s": 63865790139.4,
    "sim_time_s": 235.04,
    "hdg_true_deg": 269.3,
    "gps_ground_track_deg": 276.8,
    "master_bat": 0,
    "gps_ground_speed_ms": 0,
    "airspeed_ind_ms": 0,
    "ground_alt_m": 78.2,
    "ambient_temp_k": 296.5,
    "ambient_pressure_mb": 1003.9,
    "velocity_world_z_ms": 0,
    "velocity_world_x_ms": 0,
    "sim_rate": 1,
    "weather_hash": 9516964,
    "gear": 1
}


*/

class NB21Connect {

    constructor(planner) {
        let nb21 = this;

        const NB21_WS_IGC = ":54179/NB21_logger";
        const NB21_WS_JSON = ":54179/NB21_logger_json";

        console.log("NB21Connect created");
        nb21.planner = planner;
        nb21.pln_ref_id = 1; // logger will increment this on each PLN load

        nb21.WATCHDOG_PERIOD_MS = 2000; // Milliseconds period for watchdog timer loop

        let hostname = "localhost";
        if (location.protocol == "http:") {
            hostname = location.hostname;
        }
        nb21.WS_URL_IGC = "ws://"+hostname + NB21_WS_IGC;
        nb21.WS_URL_JSON = "ws://"+hostname + NB21_WS_JSON;
        nb21.HTTP_URL = "http://"+hostname+":54178/"; // HeaderData | RepeatData

        nb21.ws = null;
        nb21.connection_required = false;
        nb21.watchdog_timer = null;

    }

    setup_connection(json) {
        let nb21 = this;
        console.log("NB21Connect.setup_connection() json="+json);
        // check connection every 5 seconds
        nb21.connection_required = true;
        clearInterval(nb21.watchdog_timer);
        nb21.watchdog_timer = setInterval(() => { nb21.watchdog_handler(nb21); }, nb21.WATCHDOG_PERIOD_MS);
        nb21.connect(nb21, json);
        nb21.request_header(nb21, json);
    }

    close_connection() {
        let nb21 = this;
        console.log("NB21Connect.close_connection()");
        nb21.connection_required = false;
        clearInterval(nb21.watchdog_timer);
        if (nb21.ws != null) {
            nb21.ws.close();
        }
    }

    watchdog_handler(nb21) {
        //console.log(`NB21Connect.watchdog_timer() NB21 WS status:[${nb21.ws_state_str(nb21.ws)}]`);
        if (nb21.connection_required && nb21.ws.readyState == WebSocket.CLOSED) {
            nb21.connect(nb21);
        }

        //nb21.check_pln(nb21.planner, nb21);
    }

    connect(nb21, json) {
        console.log(`NB21Connect.connect() Trying connect ...`);

        let ws_url = json ? nb21.WS_URL_JSON : nb21.WS_URL_IGC;
        nb21.ws = new WebSocket(ws_url);

        nb21.ws.onmessage = e => {
            if (json) {
                nb21.handle_message_json(nb21, e.data);
            } else {
                nb21.handle_message(nb21, e.data);
            }
        };

        nb21.ws.onopen = e => {
            console.log(`NB21Connect 'ws.onopen' Opened websocket ...${ws_url}`);
            nb21.planner.local_player_connected();
        };

        nb21.ws.onclose = e => {
            console.log(`NB21Connect 'ws.onclose' Closed websocket....${ws_url}`);
            nb21.planner.local_player_disconnected();
        };
    };

    // ********************************************************************
    // ***** HTTP request for PLN XML                  ********************
    // ********************************************************************

    //DEBUG this not currently used
    async check_pln(planner, nb21) {
        const request_url = nb21.HTTP_URL+"check_pln";
        //console.log(`NB21Connect.check_pln() ${request_url}`);
        try {
            const response = await fetch(request_url);
            if (response.ok) {
                let check_pln_json = await response.json();
                console.log(`NB21Connect.check_pln() received json`, check_pln_json);
                if (check_pln_json.pln_ref_id != nb21.pln_ref_id) {
                    console.log("new PLN");
                    nb21.pln_ref_id = check_pln_json.pln_ref_id;
                }
            } else {
                console.log(`NB21Connect.request_pln() fetch response error: ${response.status}`);
            }
        } catch ( e ) {
            console.log(`NB21Connect.request_pln() fetch error:`, e);
        };
    }

    async request_pln(planner, nb21) {
        const request_url = nb21.HTTP_URL+"get_pln";
        console.log(`NB21Connect.request_pln() ${request_url}`);
        try {
            const response = await fetch(request_url);
            if (response.ok) {
                let pln_xml = await response.text();
                //console.log(`NB21Connect.request_pln() received header_response`, response);
                console.log(`NB21Connect.request_header() received pln`, pln_xml);
                //console.log(pln_xml);
                planner.handle_nb21_pln(planner, pln_xml);
            } else {
                console.log(`NB21Connect.request_pln() fetch response error: ${response.status}`);
            }
        } catch ( e ) {
            console.log(`NB21Connect.request_pln() fetch error:`, e);
        };
    }

    // ********************************************************************
    // ***** HTTP request for header data              ********************
    // ********************************************************************

    async request_header(nb21, json) {
        let fetch_url = nb21.HTTP_URL+"headerdata" + (json ? "_json" : "");
        console.log(`NB21Connect.request_header() json=${json} ${fetch_url}`);
        try {
            const response = await fetch(fetch_url);
            if (response.ok) {
                let header_data = await response.text();
                //console.log(`NB21Connect.request_header() received header_response`, response);
                console.log(`NB21Connect.request_header() received header_data:`)
                console.log(header_data);
                //console.log(header_data);
                if (json) {
                    nb21.handle_message_json(nb21,header_data);
                } else {
                    nb21.planner.handle_nb21_header(nb21.planner,header_data);
                }
            } else {
                console.log(`NB21Connect.request_header() error: ${response.status}`);
            }
        } catch ( e ) {
            //console.log(`NB21Connect.request_header() error:`, e);
        };
    }

    // ********************************************************************
    // ***** HTTP POST PLN XML task                    ********************
    // ********************************************************************

    async pln_set(nb21, pln_str) {
        let fetch_url = nb21.HTTP_URL+`pln_set?src=b21_task_planner&src_txt=B21 Task Planner ${nb21.planner.VERSION}`;
        console.log(`NB21Connect.pln_set() ${fetch_url}:`);
        console.log(pln_str);
        try {
            const response = await fetch(fetch_url, {
                method: "POST",
                body: pln_str,
                headers: {
                    "Content-type": "application/xml; charset=UTF-8"
                }
            });
            if (response.ok) {
                console.log(`NB21Connect.pln_set() POST ok`);
            } else {
                console.log(`NB21Connect.pln_set() POST error: ${response.status}`);
            }
        } catch ( e ) {
             console.log(`NB21Connect.pln_set() POST error:`, e);
        };
    }

    // ********************************************************************
    // ***** Message Handling              ********************************
    // ********************************************************************

    handle_message(nb21, msg) {
        //console.log(`NB21Connect.handle_message(${msg})`);
        if (msg.startsWith('I')) {
            nb21.request_header(nb21);
            nb21.planner.handle_nb21_message(nb21.planner, msg);
        } else if (msg.startsWith('B')) {
            nb21.planner.handle_nb21_message(nb21.planner, msg);
        } else {
            console.log(`NB21Connect.handle_message unknown ${msg}`);
        }
    }

    handle_message_json(nb21, msg) {
        try {
            //console.log("nb21.handle_message_json",msg);
            let msg_json = JSON.parse(msg);
            console.log("NB21Connect.handle_message_json",msg_json);
            nb21.planner.handle_nb21_message_json(nb21.planner, msg_json);
        } catch(e) {
            console.warn(e);
        }
    }

    // Return a string value for the websocket status
    ws_state_str(ws) {
        switch (ws.readyState) {
            case WebSocket.CLOSED:
                return 'CLOSED';
            case WebSocket.CLOSING:
                return 'CLOSING';
            case WebSocket.OPEN:
                return 'OPEN';
            default:
                return 'other';
        }
    }
} // End class NB21Connect
