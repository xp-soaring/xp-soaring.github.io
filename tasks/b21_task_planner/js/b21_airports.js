"use strict"
// ********************************************************************************************
// *********  Manager for the airports data                ************************************
//
// Loaded from AIRPORTS_JSON_URL (in this repo as airports/airports.json)
// Note each 'airport' entry in the JSON is a LIST, so the downloaded JSON is more compact
// so the JSON includes an "airport_keys" dictionary that maps property_name -> index.
// e.g. Mifflin County is:
// ['KRVL', 40.6773872375488, -77.6268310546875, 'Mifflin Co', 'msfs_airport', 247.80239207032346, '06 24']
// and airports_data.airports_keys is:
// "airport_keys": {"ident": 0, "lat": 1, "lng": 2, "name": 3, "type": 4, "alt_m": 5, "runways": 6}
// Note the "airport_keys" data is generated by the program that creates the airports data, and we
// may add additional properties, so the key indexes could change.
//
// Downloaded airports_data is:
// {
//      "airport_keys": KEY -> INDEX dictionary for airport properties (as above)
//      "box_coords":   BOX_ID -> BOX COORDINATES dictionary for each 'box' of airports
//      "boxes": BOX_ID -> list of airports (& each airport is a list of property values)
// }
//
// The whole point of this airports_data structure is to support fast lookup of airports within
// a given lat/lng box (i.e. the map bounds).
//
// ********************************************************************************************

class B21_Airports {

    constructor(planner) {
        this.AIRPORTS_JSON_URL = "https://xp-soaring.github.io/tasks/b21_task_planner/airports/airports.json";
        this.DEBUG_DRAW_MAP_BOXES = false;

        this.planner = planner;
        this.airports_data = null;
        this.markers = null; // dictionary IDENT -> marker for each airport drawn on map
        this.search_ident = null; // ident of an airport search result to be highlighted on map
        this.available = false;
    }

    // init() will asynchronously download the airports data
    init(map) {
        fetch(this.AIRPORTS_JSON_URL).then(response => {
            if (!response.ok) {
                alert("Failed to download the airports data")
                return null;
            }
            //response.headers.set('content-type','application/json');
            return response.text();
        }).then(results => {
            console.log("airports.json loaded");
            this.airports_data = JSON.parse(results);
            this.KEY_LAT = this.airports_data.airport_keys['lat'];
            this.KEY_LNG = this.airports_data.airport_keys['lng'];
            this.KEY_NAME = this.airports_data.airport_keys['name'];
            this.KEY_IDENT = this.airports_data.airport_keys['ident'];
            this.KEY_TYPE = this.airports_data.airport_keys['type']; //"closed_airport", "heliport", "large_airport", "medium_airport", "seaplane_base", "small_airport", "msfs_airport"
            this.KEY_ALT_M = this.airports_data.airport_keys['alt_m'];
            this.KEY_RUNWAYS = this.airports_data.airport_keys['runways'];
            this.available = true;
            this.draw(map);
        }).catch(error => {
            console.error('Network error accessing airports.json:', error);
        });
    }

    draw(map) {
        const ZOOM_MIN_MSFS = 8;
        const ZOOM_MIN_OTHER = 9;

        this.planner.airport_markers.clearLayers();

        if (!this.available) {
            console.log("b21_airports.draw(), airports not available, returning.");
            return;
        }

        this.markers = {};

        let zoom = map.getZoom();
        if (zoom < ZOOM_MIN_MSFS) {
            console.log("Too zoomed out to display airports");
            return;
        }
        //console.log("airports.draw(map) drawing");

        let map_bounds = map.getBounds();
        let map_box = {
            "min_lat": map_bounds.getSouth(),
            "min_lng": map_bounds.getWest(),
            "max_lat": map_bounds.getNorth(),
            "max_lng": map_bounds.getEast()
        }
        console.log("draw_airports", map_box);

        for (let box_id in this.airports_data.box_coords) {
            let box = this.airports_data.box_coords[box_id];
            if (this.DEBUG_DRAW_MAP_BOXES) {
                L.rectangle([
                    [box.min_lat, box.min_lng],
                    [box.max_lat, box.max_lng]
                ]).addTo(map);
            }
            if (Geo.box_overlap(box, map_box)) {
                //console.log("overlap",box_id, box);
                let airports = this.airports_data.boxes[box_id];
                for (let i = 0; i < airports.length; i++) {
                    let airport = airports[i];
                    let type = airport[this.KEY_TYPE];
                    if (type.includes("airport")) {
                        // Skip this airport if it's non-msfs and insufficient zoom
                        if (! type.includes("msfs") && zoom < ZOOM_MIN_OTHER) {
                            continue;
                        }
                        let position = new L.latLng(airport[this.KEY_LAT], airport[this.KEY_LNG]);
                        let ident = airport[this.KEY_IDENT];
                        //let type = airport[this.KEY_TYPE];
                        let name = airport[this.KEY_NAME].replaceAll('"', ""); // Remove double quotes if original name includes those.
                        let alt_m = airport[this.KEY_ALT_M];
                        let runways = airport[this.KEY_RUNWAYS];
                        let circle_radius = 3 * (zoom - 7);
                        if (type == "large_airport") {
                            circle_radius *= 3;
                        } else if (type == "medium_airport") {
                            circle_radius *= 2;
                        }
                        let marker = L.circleMarker(position, {
                            renderer: this.planner.canvas_renderer,
                            color: this.planner.task.is_msfs_airport(type) ? '#3388ff' : '#33ff88',
                            radius: circle_radius
                        });
                        marker.addTo(this.planner.airport_markers);

                        // add popup
                        let popup_content = name + "<br/>" + type + "<br/>" + ident;
                        let popup = L.popup({
                            autoPan: false
                        }).setContent(popup_content);
                        marker.bindPopup(popup);

                        marker.on('mouseover', function(event) {
                            marker.openPopup();
                        });
                        marker.on('mouseout', function(event) {
                            marker.closePopup();
                        });
                        marker.on('click', (e) => {
                            console.log("User click:", ident, name);
                            this.planner.task.add_new_poi(position, type, {
                                "ident": ident,
                                "name": name,
                                "alt_m": alt_m,
                                "runways": runways
                            });
                        });
                        if (ident == this.search_ident) {
                            marker.openPopup();
                            this.search_ident = null;
                        }
                        //this.markers[ident] = marker;
                    }
                }
            }
        }
    }

    // Return airport info given ident e.g. lookup("LSMM") returns
    // { alt_m: 579.1, ident: "LSMM", lat: 46.74333, lng: 8.109999, name: "Meiringen Mil", runways: "28 10", type: "msfs_airport" }
    // Note our airports data structure is highly optimised for a lookup by lat/long (i.e. stored by latlong 'boxes')
    // so for what would seem a simple 'lookup by ident' we actually have to search all the airports.
    lookup(ident) {
        if (!this.available) {
            console.log("ERROR: airports lookup request, but data not available", ident);
            return null;
        }
        console.log("b21_airports lookup", ident);
        for (const [box_key, airports_list] of Object.entries(this.airports_data.boxes)) {
            //console.log(box_key);
            for (let i = 0; i < airports_list.length; i++) {
                // airports_list is a list of the airports in the current 'box'
                // so airports_list[i] is the current airport we're checking for the ident
                // Each airport info is stored as a list of values, as defined in airport_keys
                if (airports_list[i][this.KEY_IDENT] == ident) {
                    console.log("airports lookup ident found", ident, airports_list[i]);
                    return this.airport_list_to_obj(airports_list[i]);
                }
            }
        }
        return null;
    }

    // Convert the compact airports list data to a JS obj
    airport_list_to_obj(airport_list) {
        let airport_info = {};
        // Note we use 'airport_keys' to map from key name (e.g. ident) to array entry (e.g. 0)
        for (const [key, value] of Object.entries(this.airports_data.airport_keys)) {
            airport_info[key] = airport_list[value]
        }
        airport_info["id"] = airport_info["ident"];
        airport_info["source"] = airport_info["type"] == "msfs_airport" ? "msfs_airports" : "ourairports";
        return airport_info
    }

    // User has typed in search box
    search(search_value) {
        let parent = this;
        const RESULTS_MAX = 50;
        let results = [];
        for (let box_id in this.airports_data.box_coords) {
            let airports = this.airports_data.boxes[box_id];
            for (let i = 0; i < airports.length; i++) {
                let airport = airports[i];
                let type = airport[this.KEY_TYPE];
                if (type.includes("airport")) {
                    let ident = airport[this.KEY_IDENT];
                    let name = airport[this.KEY_NAME].replaceAll('"', ""); // Remove double quotes if original name includes those.
                    if ((ident + "!" + name).toLowerCase().includes(search_value)) {
                        results.push(this.airport_list_to_obj(airport));
                        if (results.length > RESULTS_MAX) {
                            break;
                        }
                    }
                }
            }
            if (results.length > RESULTS_MAX) {
                break;
            }
        }

        return results;
    }

} // end class B21_Airports
